{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MemXTerminator Wiki!","text":"<p>MemXTerminator is a software for membrane analysis and subtraction in cryo-EM.</p> <p> MemXTerminator</p>"},{"location":"#overview","title":"Overview","text":"<p>This software utilizes 2D averages and their corresponding alignment information, employing methods such as Radon transform, cross-correlation, L1 norm, Bezier curves, Monte Carlo simulations, and Genetic Algorithm. It analyzes and subtracts membranes of any shape in cryo-EM, ultimately producing particle stacks and micrographs with membrane signals removed, which are suitable for subsequent membrane protein analysis.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Capable of analyzing biological membranes of any shape, including simple lines and arcs, as well as more complex shapes like S or W curves;</li> <li>Accurately locates and subtracts biological membrane signals;</li> <li>Utilizes GPU and CUDA acceleration to enhance computational speed;</li> <li>Features a user-friendly GUI for ease of use.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>This software requires a GPU and CUDA acceleration. So, the installation of CUDA drivers and libraries is necessary.</li> <li>pyem is also needed to convert cryoSPARC\u2019s <code>.cs</code> files to Relion\u2019s <code>.star</code> format for processing.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>For specific installation methods, please refer to the Installation section.</p>"},{"location":"#usage","title":"Usage","text":"<p>This software has a user-friendly GUI. To use this software, simply type:</p> <pre><code>MemXTerminator gui &amp;\n</code></pre> <p>For detailed usage tutorials, please refer to the Usage section.</p>"},{"location":"#license","title":"License","text":"<p>This software is licensed under GPL v3.0.  </p>"},{"location":"#acknowledgement","title":"Acknowledgement","text":"<p>Thanks to Jack(Kai) Zhang@Yale MB&amp;B for his guidance.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Always welcome! This software may still has room for improvement such as updating the usage documentation, improving the GUI design, and enhancing the software's usability.</p> <p>I am still working on improving this software. More exciting features are on the way!</p>"},{"location":"#contact","title":"Contact","text":"<p>If you have any questions, please feel free to contact me: zhen.victor.huang@gmail.com</p>"},{"location":"tutorials/basic-pipeline/","title":"Basic pipeline","text":"<p>Abstract</p> <p>This article primarily introduces the basic concept and steps of membrane subtraction.</p>"},{"location":"tutorials/basic-pipeline/#basic-concept","title":"Basic Concept","text":"<ol> <li>Use <code>cryoSPARC</code> to select particles with the biological membrane at the image center and their corresponding 2D averages;</li> <li>For each 2D average, use methods like Radon transform and Bezier curve fitting to derive the mathematical model of that type of biological membrane, which includes information about the membrane center, angle, curvature, etc. (for Radonfit) or the coordinates of some control points of bezier curves (for Bezierfit);</li> <li>Based on the mathematical model of the biological membrane and alignment information in <code>cryoSPARC</code>, perform membrane subtraction on all raw images of that type of biological membrane to obtain a particle stack after membrane subtraction;</li> <li>Place the membrane-subtracted particle stacks back into the original micrographs for subsequent analysis. For example, you can re-pick the protein-of-interest in these membrane-subtracted micrographs.</li> </ol>"},{"location":"tutorials/basic-pipeline/#basic-steps","title":"Basic Steps","text":""},{"location":"tutorials/basic-pipeline/#1-obtaining-2d-averages-with-the-membrane-center-at-the-image-center","title":"1 Obtaining 2D Averages with the Membrane Center at the Image Center","text":"<p>The goal of this step is to make the analysis of the membrane in the second step more accurate and easier, as the Radon transform might fail to analyze properly if the membrane center is not at the image center, especially with significant deviations.</p>"},{"location":"tutorials/basic-pipeline/#11-creating-a-series-of-templates-with-the-membrane-center-at-the-image-center","title":"1.1 Creating a Series of Templates with the Membrane Center at the Image Center","text":"<p>Select a 2D average with a good signal-to-noise ratio and dominant biological membrane signals from <code>cryoSPARC</code>. Based on it, create a series of 2D average templates where the biological membrane center is at the image center, the direction is vertical, but with varying curvatures.</p> <p> Kappa templates</p> <p>Use these generated templates as new templates to pick particles again, ensuring the accurate positioning of the particles' centers at the membrane center in the micrographs.</p> <p> Particles picked using cryoSPARC</p>"},{"location":"tutorials/basic-pipeline/#12-extract-particles-2d-classification","title":"1.2 Extract Particles &amp; 2D Classification","text":"<p>Extract those particles for 2D classification. The obtained 2D averages should have their membrane centers at the image center. Use these 2D averages for subsequent membrane analysis.</p> <p> Obtained 2D Averages</p>"},{"location":"tutorials/basic-pipeline/#2-analyzing-2d-averages-to-obtain-corresponding-mathematical-model","title":"2 Analyzing 2D Averages to Obtain Corresponding Mathematical Model","text":""},{"location":"tutorials/basic-pipeline/#21-radonfit","title":"2.1 Radonfit","text":"<p>This method mainly uses Radon transform and cross-correlation to fit the 2D averages with simple lines and arcs as models, obtaining mathematical models that include the membrane center, angle, curvature, etc. It's suitable for simpler biological membrane models, such as viral envelopes.</p>"},{"location":"tutorials/basic-pipeline/#211-radon-analysis-blinking","title":"2.1.1 Radon Analysis Blinking","text":"<p>Analyze each 2D average to determine the proper parameters for Radon transform, including crop rate, threshold, and the range of Radon transform angles, because being able to utilize Radon transform to get reasonable results is very crucial for Membrane Analysis. Save these parameters into a JSON file for the next step of membrane analysis.</p>"},{"location":"tutorials/basic-pipeline/#212-membrane-analysis","title":"2.1.2 Membrane Analysis","text":"<p>Analyze the 2D averages, obtaining information for each 2D average like membrane center, angle, bilayer distance, monolayer thickness (size of sigma after Gaussian fitting), and curvature. This information corresponds to the mathematical model, which can be used to obtain the averaged biological membrane and its mask.</p>"},{"location":"tutorials/basic-pipeline/#22-bezierfit","title":"2.2 Bezierfit","text":"<p>This method mainly uses Bezier curves combined with Monte Carlo and Genetic Algorithm to fit the biological membrane in the 2D averages with more complex irregular curves as models, resulting in several control points and corresponding Bezier curve expressions(mathematical models). It's suitable for more complex biological membrane models, like S-shaped, W-shaped, etc., such as mitochondrial membranes.</p>"},{"location":"tutorials/basic-pipeline/#221-randomly-generate-sampling-points-in-the-membrane-area","title":"2.2.1 Randomly Generate Sampling Points in the Membrane Area","text":"<p>For each 2D average, first use a maximum value filter to extract the rough area containing the biological membrane signal from the 2D average, then randomly generate several sampling points in this area as reference points for the initial fitting of the Bezier curve.</p>"},{"location":"tutorials/basic-pipeline/#222-preliminary-fitting-using-genetic-algorithm","title":"2.2.2 Preliminary Fitting Using Genetic Algorithm","text":"<p>Use Genetic Algorithm for a preliminary fitting of the reference points generated in the first step, obtaining several control points and the corresponding bezier curve expressions. This step allows determining the general direction and shape of the membrane based on the position information of the points from the previous step.</p>"},{"location":"tutorials/basic-pipeline/#223-adjusting-control-points-using-genetic-algorithm-to-optimize-fitting-results","title":"2.2.3 Adjusting Control Points Using Genetic Algorithm to Optimize Fitting Results","text":"<p>Further optimize the control points obtained in the preliminary fitting step using Genetic Algorithm again. By maximizing the value of cross-correlation function, adjust the positions of the control points to obtain several optimal control points that fit the shape of the membrane in the 2D average. These optimal control points correspond to a bezier curve expression describing the shape of the membrane.</p>"},{"location":"tutorials/basic-pipeline/#3-particle-membrane-subtraction","title":"3 Particle Membrane Subtraction","text":"<p>Each type of 2D average corresponds to several raw particle stacks. From the previous analysis of the 2D average, we can obtain the mathematical model of that type of biological membrane, which gives us the membrane signal information for each raw particle.</p> <p>Perform membrane subtraction on each previously extracted raw particle to obtain the corresponding membrane-subtracted particle, generating another corresponding membrane-subtracted particle stack.</p>"},{"location":"tutorials/basic-pipeline/#4-micrograph-membrane-subtraction","title":"4 Micrograph Membrane Subtraction","text":"<p>Replace the original raw particles in the micrographs with the corresponding membrane-subtracted particles to obtain new micrographs, where the membrane signals can be weakened or even removed.</p>"},{"location":"tutorials/basic-pipeline/#5-post-analysis","title":"5 Post-analysis","text":"<p>In the new membrane-subtracted micrographs, you can use membrane protein templates to re-pick particles for subsequent analysis.</p>"},{"location":"tutorials/faq/","title":"Frequently Asked Questions","text":""},{"location":"tutorials/faq/#hardware","title":"Hardware","text":"<p>1) Q: Can this software run on a CPU cluster?</p> <p>A: When I was developing the software, it turned out that the subtraction would be much faster using CUDA, so I chose to put most of the computational work on the GPUs. (Maybe it's a good idea to develop another CPU version of this software.) But for now, I don't think a CPU cluster will work. More CPUs just mean that more jobs will run in parallel and it takes more GPU memory. So I think more GPU memory would be better to accelerate this process because you can execute more jobs in the meantime.</p> <p>2) Q: Memory leakage problems like:</p> <p>BrokenPipeError: [Errno 32] Broken pipe</p> <p>multiprocessing/resource_tracker.py:216: UserWarning: resource_tracker: There appear to be 6 leaked semaphore objects to clean up at shutdown warnings.warn('resource_tracker: There appear to be %d '</p> <p>A: This problem was probably due to memory leakage. You can try to use less cpus and smaller batch size. I\u2019ve optimized the software so it should manage the GPU memory more properly. Please note that when you kill the process manually, it is possible that the BrokenPipeError may come up again but I think you can just skip that.</p>"},{"location":"tutorials/faq/#speed-and-time","title":"Speed and Time","text":"<p>1) Q: How can I know the estimated time for the membrane subtraction, just like particle subtraction process in Relion?</p> <p>A: Sorry, the estimated time is not accessible now. But you can refer to the prompts in the <code>run.out</code> file like \"x / x minibatch finished\" \"xx particle stacks took xx seconds.\"</p> <p>2) Q: How fast is the particle membrane subtraction?</p> <p>A: When the software ran on a workstation which has 24 CPUs and one RTX4090 (24GB) using the default parameters, the speed was about 10 particles per second. (In this case, 18 CPUs were being used; the graphic card was almost full of memory; Volatile GPU-util was about 100%.)</p> <p>3) Q: Will Micrograph Membrane Subtraction take a similarly long time as the Particle Membrane Subtraction?</p> <p>A: Actually the time Micrograph Membrane Subtraction takes depends on the number of micrographs. When I tested this software using my own data, it took much less time than the particle membrane subtraction.</p>"},{"location":"tutorials/faq/#membrane-subtraction","title":"Membrane Subtraction","text":"<p>1) Q: I used the default parameters in the membrane subtraction. I was wondering whether the membrane signal can be completely removed by changing some parameters.</p> <p>A: Theoretically, the membrane can be completely removed using default parameters. You can check if the results of membrane analysis are as expected, like if the shapes of the membrane masks are reasonable for the corresponding 2D averages. If you find that everything is ok but the membrane signal is still not completely removed, you can set the bias in the Particles Membrane Subtraction interface. You can try to set the bias to 0.1.</p> <p>Note</p> <p>a) if the bias is too high, the subtraction is likely to be excessive, and the gray value where the membrane signal exists may become negative.</p> <p>b) Removing the membrane completely is not best in all cases, and sometimes weakening the membrane signal would be a better option.</p> <p>2) Q: If my job fails or suddenly stops, can I continue the membrane subtraction or do I need to restart it?</p> <p>A: Yes, you can continue to do membrane subtraction if your job suddenly fails. The software will read the <code>run_data.log</code> file every time you begin to do membrane subtraction, and the finished particle stacks/micrographs in the <code>run_data.log</code> will be skipped. By the way, this software ran continuously for 6 days when I used it before and everything just went well.</p> <p>3) Q: I was faced with a problem like this: <code>ValueError: Map ID string not found - not an MRC file, or file is corrupt</code> when doing Micrograph Membrane Subtraction. I'm sure that the micrographs should be fine.</p> <p>A: It seems that it has something to do with the <code>mrcfile</code> python library when reading the micrographs. You can try to fix your micrographs by just using this command:</p> <pre><code>MemXTerminator fixmapid &lt;path_to_mrc_file&gt;\n</code></pre> <p>4) Q: When putting the membrane-subtracted particles back to micrograph, if two boxes overlap, how would it determine the value of the overlap region? That's say if there are two membranes in a particle, according to the 2D average, only one can be subtracted in the end; the other membrane may be picked in another particle.</p> <p>A: Membrane-subtracted particles are weighted before putting back to the micrographs. So it turns out that the Micrograph Membrane Subtraction will combine information from multiple particles, even though there may be overlap between them. If there are two membranes in a particle, it's true that only one can be subtracted in the end; but as long as the other membrane has been picked and subtracted in another particle, when the software combines the info in these two particles, the two membranes will be subtracted in the micrograph eventually.</p>"},{"location":"tutorials/faq/#top-view","title":"Top view?","text":"<p>Q: The membrane subtraction can only remove the membrane signal from the side view. Can it also remove the membrane signal from the top view?</p> <p>A: Good question. Actually I didn't take the top view into consideration and I have no idea how to localize and remove the membrane signal from the top view now. I think I need to find other ways out. But in practice, it seems that weakening or removing membrane signals from the side view is sufficient to reduce the effect of membrane signals on membrane proteins. We still need to try and test more.</p>"},{"location":"tutorials/faq/#ctf-estimation","title":"CTF estimation","text":"<p>Q: Can the membrane-subtracted micrographs directly do the CTF-estimation independently?</p> <p>A: Theoretically, you can just take the subtracted micrographs as the raw micrographs, because all the other things are the same except the membrane signal, so I think it's okay to do the CTF estimation on the subtracted micrographs. I think it would be better to do CTF estimation before membrane subtraction.</p>"},{"location":"tutorials/installation/","title":"Installation","text":""},{"location":"tutorials/installation/#requirements","title":"Requirements","text":"<ul> <li>NVIDIA GPU with CUDA drivers and libraries</li> <li><code>cupy</code> library</li> <li>other dependencies (e.g. <code>mrcfile</code>)</li> </ul> <p>Note</p> <p>Please note that the corresponding python libraries will be automatically installed during the installation process of this software.</p>"},{"location":"tutorials/installation/#how-to-install","title":"How to install","text":""},{"location":"tutorials/installation/#step-1-clone-repository","title":"Step 1: Clone repository","text":"<pre><code>git clone https://github.com/ZhenHuangLab/MemXTerminator.git\n</code></pre>"},{"location":"tutorials/installation/#step-2-create-a-virtual-environment","title":"Step 2: Create a virtual environment","text":"<pre><code>conda create -n mxt python=3.9\n\nconda activate mxt\n</code></pre>"},{"location":"tutorials/installation/#step-3-install-software-and-dependencies","title":"Step 3: Install software and dependencies","text":"<pre><code>cd MemXTerminator\n\npip install .\n</code></pre>"},{"location":"tutorials/installation/#how-to-update","title":"How to update","text":"<p>Please get to the source-code dictionary downloaded from the repository, for example:</p> <pre><code>cd MemXTerminator\n</code></pre> <p>Then, run the following command:</p> <pre><code>git pull\n\npip install .\n</code></pre>"},{"location":"tutorials/micrograph-membrane-subtraction/","title":"Micrograph Membrane Subtraction","text":"<p>Warning</p> <p>Currently, <code>.cs</code> files are not supported. So, in the <code>Bezierfit</code> mode, You still need to use <code>pyem</code> to convert <code>particles_selected.cs</code> to <code>particles_selected.star</code>. About how to convert <code>.cs</code> to <code>.star</code>, please refer to the Preprocessing section.</p>"},{"location":"tutorials/micrograph-membrane-subtraction/#1-basic-idea","title":"1 Basic Idea","text":"<p>After the previous step of removing membrane signals from all particles, you can put these membrane-subtracted particles back into the original micrographs to obtain new micrographs with the membrane signals removed. These micrographs can be used for subsequent processing, like re-picking the membrane proteins in them.</p> <ul> <li> <p>For each particle \\(F_{RI}(x,y)\\), we have a particle with membrane signals removed, \\(F_{SRI}(x,y)\\);</p> </li> <li> <p>Based on the positional information of particles provided by <code>cryoSPARC</code>, we can replace the original particle \\(F_{MI}(x,y)\\) in the micrograph with \\(F_{SRI}(x,y)\\) to obtain a micrograph with membrane signals removed;</p> </li> <li> <p>Of course, during the replacement process, considerations should be given to ensuring that \\(F_{SRI}(x,y)\\) is at the same scale as the original \\(F_{RI}(x,y)\\) and to how to deal with overlapping areas.</p> </li> </ul>"},{"location":"tutorials/micrograph-membrane-subtraction/#2-specific-steps","title":"2 Specific Steps","text":""},{"location":"tutorials/micrograph-membrane-subtraction/#21-open-the-interface","title":"2.1 Open the Interface","text":"<p>First, open the MemXTerminator main program, select the <code>Radonfit</code> or <code>Bezierfit</code> mode(based on which mode you have used for particle membrane subtraction), then choose <code>Micrograph Membrane Subtraction</code>, and enter the Micrograph Membrane Subtraction interface:</p> <ul> <li>For <code>Radonfit</code> mode:</li> </ul> <p> Micrograph Membrane Subtraction interface (Radonfit)</p> <ul> <li>For <code>Bezierfit</code> mode:</li> </ul> <p> Micrograph Membrane Subtraction interface (Bezierfit)</p>"},{"location":"tutorials/micrograph-membrane-subtraction/#22-set-appropriate-parameters","title":"2.2 Set Appropriate Parameters","text":"<p>The <code>Micrograph Membrane Subtraction</code> interface is as follows:</p> <p> Micrograph Membrane Subtraction main interface</p> <p>You need to enter the following file path:</p> <ul> <li><code>Particles selected starfile</code>: Choose the star file that saves all particles information, usually <code>particles_selected.star</code>;</li> </ul> <p>You can set the following parameters:</p> <ul> <li> <p><code>Cpus</code>: You can set multiple CPUs for computation. Default is 15. However, if your GPU memory is limited, it is advised not to set too many CPUs to avoid memory issues;</p> </li> <li> <p><code>Batch size</code>: You can set how many micrographs are processed in parallel. Default is 30, twice the number of CPUs. It is recommended to set it as a multiple of the CPU number. If your GPU memory is limited, it is advised not to set a large Batch size.</p> </li> </ul> <p>After setting the appropriate parameters, click <code>Launch</code> to begin the membrane signal removal from the micrograph.</p> <p>How to resume from a breakpoint</p> <p>Like particle membrane subtraction, if the job is interrupted for some reason, please don't worry. You can continue to do the micrograph membrane subtraction because every time you begin to do it, the software will read the <code>mms_run_data.log</code> file, which records the micrographs that have been processed. The software will automatically skip the processed micrographs and continue to process the remaining micrographs.</p>"},{"location":"tutorials/micrograph-membrane-subtraction/#3-results","title":"3 Results","text":"<p>You will find a <code>subtracted</code> folder next to your folder containing the original micrographs, like this:</p> <pre><code>Sxxx/\n\u251c\u2500\u2500 motioncorrected/\n\u251c\u2500\u2500 subtracted/\n</code></pre> <p>In the <code>subtracted</code> folder, you will find all the <code>.mrc</code> files of the micrographs with membrane signals removed. You can proceed with further processing using <code>cryoSPARC</code>.</p> <p>Note</p> <p>The orginal micrographs don't have to be in the <code>motioncorrected</code> folder. The software will take the second folder in the directory as the original micrographs folder. For exmaple, in the <code>particles_selected.star</code> file, the <code>rlnMicrographName</code> column contains the path like <code>Jxxx/import/xxxmicrograph.mrc</code>. Then the software will take the <code>import</code> folder as the original micrographs folder and create a <code>subtracted</code> folder next to it.</p>"},{"location":"tutorials/preprocessing/","title":"Preprocessing","text":"<p>Abstract</p> <p>These are things you need to do before doing membrane fitting and subtraction.</p>"},{"location":"tutorials/preprocessing/#convert-cs-to-star-using-pyem","title":"Convert <code>.cs</code> to <code>.star</code> using pyem","text":"<p>Use pyem <code>csparc2star.py</code> to run the following command, converting <code>particles_selected.cs</code> into <code>particles_selected.star</code>:</p> <p>For the latest version of pyem, run the following command:</p> <pre><code>csparc2star.py --relion2 --inverty particles_selected.cs Jxxx_passthrough_particles_selected.cs particles_selected.star\n</code></pre> <p>Warning</p> <p>Please DO NOT miss <code>--inverty</code>!</p> <p>If there is no <code>--relion2</code> parameter, it means that your pyem version is older, then you should run the following command:</p> <pre><code>csparc2star.py --swapxy particles_selected.cs Jxxx_passthrough_particles_selected.cs particles_selected.star\n</code></pre>"},{"location":"tutorials/preprocessing/#obtain-2d-averages-radonfit-only","title":"Obtain 2D Averages (<code>Radonfit</code> only)","text":""},{"location":"tutorials/preprocessing/#1-general-idea","title":"1 General Idea","text":"<p>Use a series of biological membranes with different curvatures, all centered in the image center, as templates to pick particles. The coordinates of the resulting particles will align with the centers of the biological membranes in the micrographs. Then, perform 2D classification on these particles to obtain 2D averages with the membrane center at the image center.</p> <p>The role of this approach is that it simplifies and increases the accuracy of subsequent membrane analysis and subtraction.</p>"},{"location":"tutorials/preprocessing/#2-specific-steps","title":"2 Specific Steps","text":""},{"location":"tutorials/preprocessing/#21-obtaining-2d-averages-in-cryosparc","title":"2.1 Obtaining 2D Averages in cryoSPARC","text":"<p>First, we need to obtain a 2D average in <code>cryoSPARC</code>, where the biological membrane signal is strong and the signal-to-noise ratio is high. As our method aims to weaken the membrane signal, it should not be difficult to find such a 2D average.</p> <p> Some typical biological membrane 2D averages, choose the first one for analysis</p> <p>For example, we choose the first 2D average in the above image for analysis. For convenience in <code>cryoSPARC</code>, when selecting 2D Classes, we only need to choose this one 2D average.</p>"},{"location":"tutorials/preprocessing/#22-using-gui-for-radon-analysis-blinking","title":"2.2 Using GUI for Radon Analysis Blinking","text":"<p>Open the main program of <code>MemXTerminator</code>, select <code>Radonfit</code> mode, and enter the <code>Radon Analysis Blinking</code> interface:</p> <p> Radon Analysis Blinking Interface</p> <ul> <li>Select the <code>.mrc</code> file of the 2D average obtained in the previous step with Select 2D Classes. The typical filename is <code>templates_selected.mrc</code> ;</li> <li>Select section 0 (or the section corresponding to your 2D average of interest, starting from 0);</li> <li>Choose an appropriate crop rate, threshold, theta_start and theta_end. You can try the default values first, and then adjust them according to the results of the Radon transform. The crop rate is the percentage of the image to be preserved, and the threshold is the threshold for the Radon transform. The theta_start and theta_end are the range of Radon transform angles. The default values are 0.6, 0.7, 0, and 180, respectively;</li> <li> <p>Click <code>START Radon Analysis!</code>. After the analysis is completed, a window will pop up showing the results of the Radon transform. If you see the location of the two red crosses is accurate (usually the same horizontal coordinate and a vertical interval equal to the distance of the biological membrane), it indicates a successful analysis, and you can close the window. If the coordinate of the two red crosses is inaccurate, please re-adjust the parameters and click <code>START Radon Analysis!</code> again until the two red crosses are properly located;</p> <p> An Example for Radon Analysis Result</p> </li> <li> <p>After analyzing this <code>.mrc</code> file, choose a path to save the JSON file with these parameters and then save them.</p> </li> </ul>"},{"location":"tutorials/preprocessing/#23-generating-a-series-of-2d-average-templates-with-the-membrane-center-at-the-image-center","title":"2.3 Generating a Series of 2D Average Templates with the Membrane Center at the Image Center","text":"<p>Open the main program of <code>MemXTerminator</code>, select <code>Radonfit</code> mode, and enter the <code>Membrane Analyzer</code> interface:      Radonfit Membrane Analyzer Interface</p> <ul> <li>Check <code>Generate kappa templates</code>;</li> <li><code>Which template?</code>: Choose which section to use as a reference to generate 2D average templates. By default, choose 0, i.e., the first particle in this stack as a reference;</li> <li><code>Kappa Num</code>: Choose how many different curvature 2D average templates you need to generate. The default is 40.</li> <li><code>Kappa start</code> and <code>Kappa end:</code> Choose the curvature range of the 2D average templates you need to generate. The default range is -0.008 to 0.008. Do not make this range too large, as the actual curvature of biological membranes is not very large.</li> <li>Fill in the file paths for other files, including <code>Templates starfile</code>, <code>Particles starfile</code>, etc.</li> <li>Click <code>Launch</code> to run the program.</li> </ul> <p>You will obtain the following 2D averages templates:</p> <p> An Example for Generated 2D Average Templates</p>"},{"location":"tutorials/preprocessing/#24-picking-particles-using-the-generated-2d-average-templates","title":"2.4 Picking Particles Using the Generated 2D Average Templates","text":"<ul> <li>In <code>cryoSPARC</code>, select Import Templates and import the <code>.mrc</code> files of the 2D average templates generated in the previous step;</li> <li>Select Template Picker, choose the 2D average templates you just imported, choose the micrographs you want to pick particles from, and run the program;</li> <li> <p>The centers of the resulting particles will align with the centers of the biological membranes in the micrographs.</p> <p> Particles picked using cryoSPARC</p> </li> <li> <p>Proceed with Inspect Picks, Extract Mics., and 2D Class in sequence to obtain several 2D averages, all of which have the membrane center at the image center.</p> <p> Obtained 2D Averages</p> </li> </ul> <p>Note</p> <p>When completing 2D Classification and selecting 2D averages in <code>cryoSPARC</code>, Do NOT choose those where the membrane signal is not dominant. This is because, on one hand, the membrane subtraction effect on these types of particles is not the best, and on the other hand, when choosing Radonfit or Bezierfit for subsequent membrane analysis, there may be some issues if the membrane signal is not very clear in the 2D averages of these types of particles.</p>"},{"location":"tutorials/preprocessing/#3-results","title":"3 Results","text":"<p>Through the above steps, we can obtain a series of 2D averages with the biological membrane center at the image center. These 2D averages can be used for subsequent membrane analysis.</p>"},{"location":"tutorials/usage/","title":"Usage","text":""},{"location":"tutorials/usage/#gui","title":"GUI","text":"<p>This software has a user-friendly GUI. To use this software:</p> <p>First enter into the conda environment you create or you have installed the <code>MemXTerminator</code>, like:</p> <pre><code>conda activate mxt\n</code></pre> <p>Then simply type:</p> <pre><code>MemXTerminator gui &amp;\n</code></pre> <p>You should see the interface now:</p> <p> MemXTerminator GUI</p>"},{"location":"tutorials/usage/#fix-map-id","title":"Fix Map ID","text":"<p>If you get the error like this during the membrane subtraction:</p> <p>ValueError: Map ID string not found - not an MRC file, or file is corrupt</p> <p>It's due to the <code>mrcfile</code> python library. </p> <p>For more details you can refer to these links:</p> <ul> <li>Handling corrupt or bad-header MRC files #544</li> <li>Permissive read mode</li> </ul> <p>You can use this command to fix the <code>.mrc</code> files:</p> <pre><code>MemXTerminator fixmapid &lt;path_to_mrc_file&gt;\n</code></pre>"},{"location":"tutorials/bezierfit-tutorials/","title":"Membrane Subtraction Workflow Using Bezierfit","text":""},{"location":"tutorials/bezierfit-tutorials/#introduction","title":"Introduction","text":"<p>This method primarily utilizes Bezier curves, integrating Monte Carlo methods and Genetic Algorithm, to fit biological membranes in 2D averages with more complex and irregular curves as models. This process results in several control points and their corresponding mathematical model. It is particularly suitable for more complex models of biological membranes, such as S-shaped or W-shaped membranes, for example, mitochondrial membranes.</p>"},{"location":"tutorials/bezierfit-tutorials/bezierfit-mem-analysis/","title":"Membrane Analysis Using Bezierfit","text":""},{"location":"tutorials/bezierfit-tutorials/bezierfit-mem-analysis/#1-basic-idea","title":"1 Basic Idea","text":"<p>This method combines Monte Carlo methods, genetic algorithms, and Bezier curves to fit the biological membranes in 2D averages with more complex and irregular curves as models. The process results in several control points and their corresponding functional expressions. It's suitable for more complex biological membrane models, such as S-shaped or W-shaped membranes, like those of mitochondria.</p> <ul> <li>For 2D averages dominated by membrane signals, a maximum value filter can extract the approximate area of the membrane;</li> <li>Using the Monte Carlo method, generate several random points \\((i, j)\\) based on grayscale values within the image;</li> <li>Employ Genetic Algorithm, using the \\((i, j)\\) as references, to fit a Bezier curve \\(L_1\\) , initially determining several control points \\((x_n, y_n)\\);</li> <li>Use Genetic Algorithm again, taking the initial control points \\((x_n, y_n)\\) as references, to adjust these points by maximizing the cross-correlation, so the fitted Bezier curve more closely aligns with the membrane signal in the 2D average;</li> <li>Obtain the optimal set of control points \\((x'_n, y'_n)\\) and the corresponding Bezier curve \\(L_2\\). This curve describes the position of the membrane signal for this particular 2D average or class of particles.</li> </ul>"},{"location":"tutorials/bezierfit-tutorials/bezierfit-mem-analysis/#2-specific-steps","title":"2 Specific Steps","text":""},{"location":"tutorials/bezierfit-tutorials/bezierfit-mem-analysis/#21-open-the-interface","title":"2.1 Open the Interface","text":"<p>First, open the <code>MemXTerminator</code> main program, select the <code>Bezierfit</code> mode, then choose <code>Membrane Analyzer</code>, and enter the <code>Membrane Analyzer</code> interface:</p> <p> Bezierfit Membrane Analyzer interface</p> <p>You need to enter the following file paths:</p> <ul> <li><code>Particle .cs file</code>: Select the <code>.cs</code> file that saves all particles information, usually <code>particles_selected.cs</code>;</li> <li><code>Template .cs file</code>: Select the <code>.cs</code> file that contains all templates information, usually <code>templates_selected.cs</code>;</li> <li><code>Output JSON file</code>: Choose the JSON file to save all results, which contains control points information for all templates, typically <code>control_points.json</code>;</li> </ul>"},{"location":"tutorials/bezierfit-tutorials/bezierfit-mem-analysis/#22-set-appropriate-parameters","title":"2.2 Set Appropriate Parameters","text":"<ul> <li><code>Bezier curve degree</code>: You can set the degree of the Bezier curve. Generally, a higher degree means a more complex curve, but it also increases the risk of overfitting. A 3<sup>rd</sup> degree Bezier curve, using 4 control points to determine the curve, is recommended;</li> <li><code>Physical membrane distance</code>: Set the physical thickness of the biological membrane in Angstroms (\u212b). This parameter will be used to calculate the thickness of the mask for membrane averaging. It should be set based on actual conditions, generally between 35-40;</li> <li><code>Coarsefit points number</code>: Set the number of points generated randomly by the Monte Carlo method. The default value of 600 should be sufficient;</li> <li><code>Coarsefit iterations</code>: Set the number of iterations for the Monte Carlo method. The default value of 300 should be enough;</li> <li><code>Coarsefit cpus</code>: As Genetic Algorithm is parallel, you can set multiple CPUs for computation. In the coarse fitting step, mainly CPU is used, so if you have more CPUs, it is advised to set a higher number to speed up computation, with a default value of 20;</li> <li><code>Curve penalty threshold</code>: Since biological membranes are generally smooth curves with rare abrupt changes in curvature, you can set a curvature threshold to improve fitting accuracy. If the absolute value of curvature at any point of the generated curve exceeds this threshold, it will be penalized, thus reducing the likelihood of extreme curvature values. The default is 0.05;</li> <li><code>Dithering range</code>: After coarse fitting, to enhance the reliability of refinement and avoid control points getting trapped in local optima, you can set a dithering range. This means slightly perturbing the coordinates of each control point based on coarse fitting, to obtain a new starting point for refinement. The default value is 50, meaning each control point's coordinates will be randomly increased or decreased by a value within 50;</li> <li><code>Refine iterations</code>: Set the number of iterations for refinement. The default value of 700;</li> <li><code>Refine cpus</code>: As Genetic Algorithm is parallel, you can set multiple CPUs for computation. The refine process will use GPU, so if you have limited GPU memory, try not to use too many CPUs in parallel. The default is 12;</li> </ul> <p>After setting the appropriate parameters, click <code>Launch</code> to start the analysis and fitting.</p> <p>Note</p> <p>The Bezierfit Membrane Analysis process will be much slower than Radonfit Membrane Analysis, as it involves more complex curve fitting and optimization, and each time can only process one 2D average.</p>"},{"location":"tutorials/bezierfit-tutorials/bezierfit-mem-analysis/#3-results","title":"3 Results","text":"<p>You will obtain a <code>JSON</code> file containing <code>control_points</code> information for all templates. This <code>JSON</code> file can be used in the next step of Particles Membrane Subtraction.</p>"},{"location":"tutorials/bezierfit-tutorials/bezierfit-mms/","title":"Micrograph Membrane Subtraction","text":""},{"location":"tutorials/bezierfit-tutorials/bezierfit-mms/#1-basic-idea","title":"1 Basic Idea","text":"<p>After the previous step of removing membrane signals from all particles, you can put these membrane-subtracted particles back into the original micrographs to obtain new micrographs with the membrane signals removed. These micrographs can be used for subsequent processing, like re-picking the membrane proteins in them.</p> <ul> <li> <p>For each particle \\(F_{RI}(x,y)\\), we have a particle with membrane signals removed, \\(F_{SRI}(x,y)\\);</p> </li> <li> <p>Based on the positional information of particles provided by <code>cryoSPARC</code>, we can replace the original particle \\(F_{MI}(x,y)\\) in the micrograph with \\(F_{SRI}(x,y)\\) to obtain a micrograph with membrane signals removed;</p> </li> <li> <p>Of course, during the replacement process, considerations should be given to ensuring that \\(F_{SRI}(x,y)\\) is at the same scale as the original \\(F_{RI}(x,y)\\) and to how to deal with overlapping areas.</p> </li> </ul>"},{"location":"tutorials/bezierfit-tutorials/bezierfit-mms/#2-specific-steps","title":"2 Specific Steps","text":""},{"location":"tutorials/bezierfit-tutorials/bezierfit-mms/#21-open-the-interface","title":"2.1 Open the Interface","text":"<p>First, open the MemXTerminator main program, select the <code>Radonfit</code> mode, then choose <code>Micrograph Membrane Subtraction</code>, and enter the Micrograph Membrane Subtraction interface:</p> <p> Micrograph Membrane Subtraction interface</p>"},{"location":"tutorials/bezierfit-tutorials/bezierfit-mms/#22-parameter-explanation","title":"2.2 Parameter Explanation","text":"<p>The Micrograph Membrane Subtraction interface is as follows:</p> <p> Micrograph Membrane Subtraction main interface</p> <p>In the interface, you need to enter the following file path:</p> <ul> <li><code>Particles selected starfile</code>: Choose the star file that saves all particles information, usually <code>particles_selected.star</code>;</li> </ul> <p>In the interface, you can set the following parameters:</p> <ul> <li> <p><code>Cpus</code>: You can set multiple CPUs for computation. Default is 15. However, if your GPU memory is limited, it is advised not to set too many CPUs to avoid memory issues;</p> </li> <li> <p><code>Batch size</code>: You can set how many micrographs are processed in parallel. Default is 30, twice the number of CPUs. It is recommended to set it as a multiple of the CPU number. If your GPU memory is limited, it is advised not to set a large Batch size.</p> </li> </ul> <p>After setting the appropriate parameters, click <code>Launch</code> to begin the membrane signal removal from the micrograph.</p> <p>How to resume from a breakpoint</p> <p>Like particle membrane subtraction, if the job is interrupted for some reason, please don't worry. You can continue to do the micrograph membrane subtraction because every time you begin to do it, the software will read the <code>run_data_mms.log</code> file, which records the micrographs that have been processed. The software will automatically skip the processed micrographs and continue to process the remaining micrographs.</p>"},{"location":"tutorials/bezierfit-tutorials/bezierfit-mms/#3-results","title":"3 Results","text":"<p>You will find a <code>subtracted</code> folder next to your folder containing the original micrographs, like this:</p> <pre><code>Sxxx/\n\u251c\u2500\u2500 motioncorrected/\n\u251c\u2500\u2500 subtracted/\n</code></pre> <p>In the <code>subtracted</code> folder, you will find all the <code>.mrc</code> files of the micrographs with membrane signals removed. You can proceed with further processing using <code>cryoSPARC</code>.</p> <p>Note</p> <p>The orginal micrographs don't have to be in the <code>motioncorrected</code> folder. The software will take the second folder in the directory as the original micrographs folder. For exmaple, in the <code>particles_selected.star</code> file, the <code>rlnMicrographName</code> column contains the path like <code>Jxxx/import/xxxmicrograph.mrc</code>. Then the software will take the <code>import</code> folder as the original micrographs folder and create a <code>subtracted</code> folder next to it.</p>"},{"location":"tutorials/bezierfit-tutorials/bezierfit-particle-mem-subtraction/","title":"Particles Membrane Subtraction Using Bezierfit","text":""},{"location":"tutorials/bezierfit-tutorials/bezierfit-particle-mem-subtraction/#1-basic-idea","title":"1 Basic Idea","text":"<p>After completing the previous step of Membrane Analysis Using Bezierfit, you have obtained <code>control_points</code> information for all 2D averages, which provides the mathematical models of the corresponding Bezier curves. In this step, you will use this information to subtract membrane signals from all particles.</p> <ul> <li>For each particle \\(F_{RawImage}(x,y)\\) (abbreviated as \\(F_{RI}(x,y)\\)), based on its corresponding template \\(f_{2DAverage}(x,y)\\), obtain its control_points information \\((x'_n, y'_n)\\);</li> <li>Using the alignment information from <code>cryoSPARC</code>, namely the <code>particles_selected.cs</code> file, determine the displacement \\((\\Delta x, \\Delta y)\\) and rotation angle \\(\\psi\\) for each particle. With this information, transform the control_points \\((x'_n, y'_n)\\) to obtain the corresponding control points \\((x''_n, y''_n)\\) and the Bezier curve \\(L_3\\) for each particle's membrane signal;</li> <li>Based on the \\(L_3\\), generate the corresponding membrane mask \\(F_{MembraneMask}(x,y)\\) (abbreviated as \\(F_{MM}(x,y)\\)) and the averaged biological membrane within the mask \\(F_{AveragedMembrane}(x,y)\\) (abbreviated as \\(F_{AM}(x,y)\\));</li> <li>For each particle, to obtain \\(F_{SubtractedRawImage}(x,y)\\) (abbreviated as \\(F_{SRI}(x,y)\\)), use the following equation:</li> </ul> \\[ F_{SRI}(x,y) = F_{RI}(x,y) - \\lambda \\times F_{AM}(x,y) \\] <p>where \\(\\lambda\\) is a constant controlling the intensity of membrane subtraction. \\(\\lambda\\) is determined by:</p> \\[ \\lambda = \\arg \\min_{\\lambda} || F_{RI}(x,y) \\times F_{MM}(x,y) - \\lambda \\times F_{AM}(x,y) ||_1 \\]"},{"location":"tutorials/bezierfit-tutorials/bezierfit-particle-mem-subtraction/#2-specific-steps","title":"2 Specific Steps","text":""},{"location":"tutorials/bezierfit-tutorials/bezierfit-particle-mem-subtraction/#21-open-the-interface","title":"2.1 Open the Interface","text":"<p>First, open the <code>MemXTerminator</code> main program, select the <code>Bezierfit</code> mode, then choose <code>Particles Membrane Subtraction</code>, and enter the Particles Membrane Subtraction interface:</p> <p> Bezierfit Particles Membrane Subtraction interface</p>"},{"location":"tutorials/bezierfit-tutorials/bezierfit-particle-mem-subtraction/#22-set-appropriate-parameters","title":"2.2 Set Appropriate Parameters","text":"<p>The Particles Membrane Subtraction interface is as follows:</p> <p> Bezierfit Particles Membrane Subtraction main interface</p> <p>You need to enter the following file paths:</p> <ul> <li><code>Particle .cs file</code>: Select the <code>.cs</code> file that saves all particles information, usually <code>particles_selected.cs</code>;</li> <li><code>Template .cs file</code>: Select the <code>.cs</code> file that contains all templates information, usually <code>templates_selected.cs</code>;</li> <li><code>Control points JSON file</code>: Choose the JSON file containing all control_points information. This file contains control_points information for all templates, typically <code>control_points.json</code>;</li> </ul> <p>You can set the following parameters:</p> <ul> <li><code>Points_step</code>: As the Bezier curve is approximated using several points, you can set the interval between these points to control the precision of the generated Bezier curve. A smaller value will result in a more refined curve but increase computational load; a larger value may affect the results of Membrane Subtraction(DO NOT set it too large to avoid any artifacts). The default is 0.001;</li> <li><code>Physical membrane distance</code>: Set the physical thickness of the biological membrane in Angstroms (\u212b). This parameter will be used to calculate the thickness of the mask for membrane averaging. It should be set based on actual conditions, generally between 35-40;</li> </ul> <p>After setting the appropriate parameters, click <code>Launch</code> to begin the membrane subtraction.</p> <p>How to resume from a breakpoint</p> <p>Like Radonfit Particle Membrane Subtraction, if the job is interrupted for some reason, you can continue to do the membrane subtraction because every time you begin the membrane subtraction, the software will read the <code>bezfit_pms_run_data.log</code> file, which records the particle stacks that have been processed. The software will automatically skip the processed particle stacks and continue to process the remaining particle stacks.</p>"},{"location":"tutorials/bezierfit-tutorials/bezierfit-particle-mem-subtraction/#3-results","title":"3 Results","text":"<p>You will find a <code>subtracted</code> folder next to the folder where you extracted the particles, like this:</p> <pre><code>Jxxx/\n\u251c\u2500\u2500 extract/\n\u251c\u2500\u2500 subtracted/\n</code></pre> <p>This folder contains all the <code>.mrc</code> files of the particles with membrane signals removed. You can proceed with further processing using <code>cryoSPARC</code> or put the particles back to the micrographs for subsequent processing.</p> <p>Warning</p> <p>Like Radonfit Particle Membrane Subtraction, please note that the software can only recognize the <code>extract</code> folder in the <code>Jxxx</code> folder, and usually in the <code>'blob/path'</code> column of the <code>particles_selected.cs</code> file.</p>"},{"location":"tutorials/radonfit-tutorials/","title":"Membrane Subtraction Workflow Using Radonfit","text":""},{"location":"tutorials/radonfit-tutorials/#introduction","title":"Introduction","text":"<p>This method primarily uses Radon transform and cross-correlation to fit 2D averages with simple lines and arcs as models, obtaining mathematical models that include information such as the membrane center, angle, and curvature. It is suitable for simpler biological membrane models, such as viral envelopes.</p>"},{"location":"tutorials/radonfit-tutorials/radonfit-mem-analysis/","title":"Membrane Analysis Using Radonfit","text":""},{"location":"tutorials/radonfit-tutorials/radonfit-mem-analysis/#1-basic-idea","title":"1 Basic Idea","text":"<ul> <li>Use Radon transform to determine the angle \\(\\theta\\) of the biological membrane and the distance \\(d\\) between the bilayers of the membrane;</li> <li>With the angle \\(\\theta\\), determine the tangential direction. In this direction, use a simulated membrane as a template to perform cross-correlation with the original 2D average, identifying the membrane's center position \\((x_c, y_c)\\) ;</li> <li>Once the precise location of the membrane center \\((x_c, y_c)\\) is determined, use cross-correlation at the center to match the optimal monolayer membrane thickness, i.e., the \\(\\sigma_1\\) and \\(\\sigma_2\\) values of the 2D Gaussian;</li> <li>Based on the previously determined angle \\(\\theta\\), center position \\((x_c, y_c)\\), \\(\\sigma_1\\), and \\(\\sigma_2\\) values, and considering a range of curvatures \\(\\kappa\\), generate a series of simulated membranes and corresponding masks. Then, calculate the cross-correlation values with the original 2D average to determine the best curvature \\(\\kappa\\) (where the cross-correlation value is the highest).</li> <li>With the derived \\(\\kappa_{cur}, x_c, y_c, \\sigma_1, \\sigma_2, d, \\theta\\), the mathematical model for that type of biological membrane can be built. For each original 2D average \\(f_{2DAverage}(x,y)\\), this allows the calculation of the corresponding averaged biological membrane \\(f_{AveragedMembrane}(x,y)\\) (abbreviated as \\(f_{AM}(x,y)\\)) and the corresponding membrane mask \\(f_{MembraneMask}(x,y)\\) ( \\(f_{MM}(x,y)\\) ).</li> </ul>"},{"location":"tutorials/radonfit-tutorials/radonfit-mem-analysis/#2-specific-steps","title":"2 Specific Steps","text":""},{"location":"tutorials/radonfit-tutorials/radonfit-mem-analysis/#21-obtaining-templates-and-corresponding-particles-information","title":"2.1 Obtaining Templates and Corresponding Particles Information","text":"<p>Since the Radonfit in this software still reads particle information in the <code>Relion</code> <code>.star</code> file format, it is necessary to convert the particles' information from <code>cryoSPARC</code> into the <code>Relion</code> <code>.star</code>file format. Future updates will consider reading <code>.cs</code> file information directly using <code>cryosparc-tools</code>.</p> <ol> <li> <p>Go to the folder corresponding to the <code>cryoSPARC</code> <code>Select 2D</code> job.</p> </li> <li> <p>Use pyem <code>csparc2star.py</code> to run the following command, converting <code>templates_selected.cs</code> into <code>templates_selected.star</code>:</p> <p>For the latest version of pyem, run the following command:</p> <pre><code>csparc2star.py --relion2 templates_selected.cs templates_selected.star\n</code></pre> <p>If there is no <code>--relion2</code> parameter, it means that your <code>pyem</code> version is older, run the following command:</p> <pre><code>csparc2star.py templates_selected.cs templates_selected.star\n</code></pre> </li> <li> <p>Use pyem <code>csparc2star.py</code> to run the following command, converting <code>particles_selected.cs</code> into <code>particles_selected.star</code>:     For the latest version of <code>pyem</code>, run the following command:</p> <pre><code>csparc2star.py --relion2 --inverty particles_selected.cs Jxxx_passthrough_particles_selected.cs particles_selected.star\n</code></pre> <p>Warning</p> <p>Please DO NOT miss <code>--inverty</code>!</p> <p>If there is no <code>--relion2</code> parameter, it means that your <code>pyem</code> version is older, run the following command:</p> <pre><code>csparc2star.py --swapxy particles_selected.cs Jxxx_passthrough_particles_selected.cs particles_selected.star\n</code></pre> </li> </ol>"},{"location":"tutorials/radonfit-tutorials/radonfit-mem-analysis/#22-radon-analysis-blinking","title":"2.2 Radon Analysis Blinking","text":"<p>1) First, open the <code>MemXTerminator</code> main program and enter the <code>Radon Analysis Blinking</code> interface:</p> <p></p> <p>Radon Analysis Blinking</p> <p>1) Select the <code>.mrc</code> file of the 2D averages you wish to analyze. Entering Section allows for previewing different sections;</p> <p>2) Fill in a suitable JSON file save path: click Browse, choose a folder, then enter a JSON file name in that folder, such as <code>radon_analysis.json</code>. This JSON file will be used to save the parameters obtained from <code>Radon Analysis Blinking</code>, which you can use in the next step of Membrane Analysis.</p> <p>Note</p> <p>Once you enter a JSON file name, the software will automatically create a corresponding JSON file and fill in default parameters: <code>crop rate</code> of 0.6, <code>threshold</code> of 0.7, <code>theta_start</code> of 0, and <code>theta_end</code> of 180.</p> <p>4) Choose an appropriate combination of these parameters, then click <code>START Radon Analysis</code> to begin the analysis;</p> <p>5) Continuously adjust the parameters until obtaining suitable Radon Analysis results. Typical Radon Analysis results usually conform to: selecting two points in the Radon Transform image, represented by red crosses, where their x-coordinates are the same or nearly the same (as generally, the bilayers in a 2D average are parallel), and their y-coordinate spacing is the same or nearly the same as the bilayer spacing. Below are two examples:</p> <p></p> <p>Radon Analysis Result 1</p> <p></p> <p>Radon Analysis Result 2</p> <p>Note</p> <p>When adjusting parameters, ideally these parameters can always be optimized to successfully analyze the results. If you find that no matter what, you can't analyze suitable results, it means that this 2D average may not be suitable for analysis using Radonfit. Exclude these types of 2D averages.</p> <p>6) Once you obtain suitable Radon Analysis results, click <code>SAVE these parameters</code> to save the parameters to the JSON file, which will be used in the next step of Membrane Analysis.</p>"},{"location":"tutorials/radonfit-tutorials/radonfit-mem-analysis/#23-membrane-analysis","title":"2.3 Membrane Analysis","text":"<p>1) Open the <code>MemXTerminator</code> main program and enter the <code>Membrane Analyzer</code> interface:</p> <p> Membrane Analyzer</p> <p>1) Click on <code>Import files</code> and sequentially input the previously obtained <code>templates_selected.star</code>, <code>particles_selected.star</code>, specify the path to save the results of the Membrane analysis parameters, and then input the JSON file of the previous Radon Analysis results. Remember not to check <code>Generate kappa templates</code>.</p> <p> Membrane Analyzer Input</p> <p>3) Click on <code>Fit membrane center</code> to set parameters related to the step of searching for the membrane center. Default parameters are generally applicable.</p> <p> Membrane Analyzer Fit membrane center</p> <p>The parameters are explained as follows:</p> <ul> <li><code>Initial sigma 1</code>: Initial value of \\(\\sigma_1\\), the Gaussian distribution sigma for one side of the lipid monolayer, denoted as \\(\\sigma_{init_1}\\);</li> <li><code>Initial sigma 2</code>: Initial value of \\(\\sigma_2\\), the Gaussian distribution sigma for the other side of the lipid monolayer, denoted as \\(\\sigma_{init_2}\\);</li> <li><code>Template Size</code>: The size of the template used for cross-correlation, usually does not need to be changed;</li> <li><code>Select range</code>: The search range for both \\(\\sigma\\) values, which can be set as a multiple \\(x\\) of \\(\\sigma_{init_1}\\) and \\(\\sigma_{init_2}\\), ranging from \\([0.1, x \\times \\sigma_{init_1})\\) and \\([0.1, x \\times \\sigma_{init_2})\\).</li> <li><code>Sigma sampling</code>: The sampling interval for \\(\\sigma\\) values, usually does not need to be changed. A smaller interval can be used for more precise matching of membrane thickness, but this increases computational load.</li> </ul> <p>4) Click on <code>Curve fitting</code> to set parameters related to the step of searching for membrane curvature. Default parameters are generally applicable.</p> <p> Membrane Analyzer Curve fitting</p> <p>The parameters are explained as follows:</p> <ul> <li><code>Kappa start</code>: The starting value for curvature search, default is -0.1, usually the default is sufficient;</li> <li><code>Kappa end</code>: The ending value for curvature search, default is 0.1, usually the default is sufficient;</li> <li><code>Kappa step</code>: The step length for curvature search, default is 0.0002, usually the default is sufficient. If increased precision is desired, the step length can be reduced, but this will increase computational load.</li> </ul> <p>5) Click on <code>Generate membrane mask</code> to set parameters related to the step of generating a membrane mask. Default parameters are generally applicable.</p> <p> Membrane Analyzer Generate membrane mask</p> <p>The parameters are explained as follows:</p> <ul> <li><code>Edge sigma</code>: The sigma value for edge blurring, default is 3, usually the default is sufficient.</li> </ul> <p>6) Click on <code>Generate averaged mem</code> to set parameters related to the step of generating an averaged membrane. Default parameters are generally applicable.</p> <p> Membrane Analyzer Generate averaged membrane</p> <p>The parameters are explained as follows:</p> <ul> <li> <p><code>Extra membrane distance</code>: Extra range added on both sides during averaging along the curve, so the actual averaging range is \\([-d_{extra}-d_{mem}, d_{mem}+d_{extra}]\\) , aimed at ensuring membrane completeness and reducing edge effects. Default is 15, usually the default is sufficient.</p> </li> <li> <p><code>Edge sigma</code>: The sigma value for edge blurring, default is 5, usually the default is sufficient.</p> </li> </ul> <p>7) After reviewing and modifying the parameters, click <code>Launch</code> to start the analysis. Upon completion, a <code>mem_analysis.star</code> file containing all analysis results will be generated in your specified save path.</p>"},{"location":"tutorials/radonfit-tutorials/radonfit-mem-analysis/#3-results","title":"3 Results","text":"<p>You will find the <code>mem_analysis.star</code> file in your specified save path, containing all the analysis results. Below is the content of a typical <code>mem_analysis.star</code> file:</p> <ol> <li><code>rln2DAverageimageName</code>: The mrc file name of the 2D average;</li> <li><code>rlnAveragedMembraneName</code>: The mrc file name of the averaged membrane of the 2D average;</li> <li><code>rlnMembraneMaskName</code>: The mrc file name of the membrane mask corresponding to the 2D average;</li> <li><code>rlnCenterX</code>: The x-coordinate of the membrane center in the 2D average;</li> <li><code>rlnCenterY</code>: The y-coordinate of the membrane center in the 2D average;</li> <li><code>rlnAngleTheta</code>: The rotation angle of the membrane;</li> <li><code>rlnMembraneDistance</code>: The distance between the lipid bilayers;</li> <li><code>rlnSigma1</code>: The \\(\\sigma_1\\) value of the Gaussian distribution of one side of the lipid monolayer;</li> <li><code>rlnSigma2</code>: The \\(\\sigma_2\\) value of the Gaussian distribution of the other side of the lipid monolayer;</li> <li><code>rlnCurveKappa</code>: The curvature of the membrane.</li> </ol>"},{"location":"tutorials/radonfit-tutorials/radonfit-mms/","title":"Micrograph Membrane Subtraction","text":""},{"location":"tutorials/radonfit-tutorials/radonfit-mms/#1-basic-idea","title":"1 Basic Idea","text":"<p>After the previous step of removing membrane signals from all particles, you can put these membrane-subtracted particles back into the original micrographs to obtain new micrographs with the membrane signals removed. These micrographs can be used for subsequent processing, like re-picking the membrane proteins in them.</p> <ul> <li> <p>For each particle \\(F_{RI}(x,y)\\), we have a particle with membrane signals removed, \\(F_{SRI}(x,y)\\);</p> </li> <li> <p>Based on the positional information of particles provided by <code>cryoSPARC</code>, we can replace the original particle \\(F_{MI}(x,y)\\) in the micrograph with \\(F_{SRI}(x,y)\\) to obtain a micrograph with membrane signals removed;</p> </li> <li> <p>Of course, during the replacement process, considerations should be given to ensuring that \\(F_{SRI}(x,y)\\) is at the same scale as the original \\(F_{RI}(x,y)\\) and to how to deal with overlapping areas.</p> </li> </ul>"},{"location":"tutorials/radonfit-tutorials/radonfit-mms/#2-specific-steps","title":"2 Specific Steps","text":""},{"location":"tutorials/radonfit-tutorials/radonfit-mms/#21-open-micrograph-membrane-subtraction-interface","title":"2.1 Open Micrograph Membrane Subtraction Interface","text":"<p>First, open the MemXTerminator main program, select the <code>Radonfit</code> mode, then choose <code>Micrograph Membrane Subtraction</code>, and enter the Micrograph Membrane Subtraction interface:</p> <p> Micrograph Membrane Subtraction interface</p>"},{"location":"tutorials/radonfit-tutorials/radonfit-mms/#22-parameter-explanation","title":"2.2 Parameter Explanation","text":"<p>The Micrograph Membrane Subtraction interface is as follows:</p> <p> Micrograph Membrane Subtraction main interface</p> <p>In the interface, you need to enter the following file path:</p> <ul> <li><code>Particles selected starfile</code>: Choose the star file that saves all particles information, usually <code>particles_selected.star</code>;</li> </ul> <p>In the interface, you can set the following parameters:</p> <ul> <li> <p><code>Cpus</code>: You can set multiple CPUs for computation. Default is 15. However, if your GPU memory is limited, it is advised not to set too many CPUs to avoid memory issues;</p> </li> <li> <p><code>Batch size</code>: You can set how many micrographs are processed in parallel. Default is 30, twice the number of CPUs. It is recommended to set it as a multiple of the CPU number. If your GPU memory is limited, it is advised not to set a large Batch size.</p> </li> </ul> <p>After setting the appropriate parameters, click <code>Launch</code> to begin the membrane signal removal from the micrograph.</p> <p>How to resume from a breakpoint</p> <p>Like particle membrane subtraction, if the job is interrupted for some reason, please don't worry. You can continue to do the micrograph membrane subtraction because every time you begin to do it, the software will read the <code>run_data_mms.log</code> file, which records the micrographs that have been processed. The software will automatically skip the processed micrographs and continue to process the remaining micrographs.</p>"},{"location":"tutorials/radonfit-tutorials/radonfit-mms/#3-results","title":"3 Results","text":"<p>You will find a <code>subtracted</code> folder next to your folder containing the original micrographs, like this:</p> <pre><code>Sxxx/\n\u251c\u2500\u2500 motioncorrected/\n\u251c\u2500\u2500 subtracted/\n</code></pre> <p>In the <code>subtracted</code> folder, you will find all the <code>.mrc</code> files of the micrographs with membrane signals removed. You can proceed with further processing using <code>cryoSPARC</code>.</p> <p>Note</p> <p>The orginal micrographs don't have to be in the <code>motioncorrected</code> folder. The software will take the second folder in the directory as the original micrographs folder. For exmaple, in the <code>particles_selected.star</code> file, the <code>rlnMicrographName</code> column contains the path like <code>Jxxx/import/xxxmicrograph.mrc</code>. Then the software will take the <code>import</code> folder as the original micrographs folder and create a <code>subtracted</code> folder next to it.</p>"},{"location":"tutorials/radonfit-tutorials/radonfit-particle-mem-subtraction/","title":"Particle Membrane Subtraction Using Radonfit","text":""},{"location":"tutorials/radonfit-tutorials/radonfit-particle-mem-subtraction/#1-basic-idea","title":"1 Basic Idea","text":"<p>After completing the previous step of Membrane Analysis Using Radonfit, you have obtained a file <code>mem_analysis.star</code> containing all analysis results, including membrane center coordinates, angles, membrane curvature, and so on. In this step, you will use this information to subtract membrane signals from all particles.</p> <ul> <li> <p>For each particle \\(F_{RawImage}(x,y)\\) (abbreviated as \\(F_{RI}(x,y)\\) ), corresponding to its template \\(f_{2DAverage}(x,y)\\), we have a membrane-averaged function \\(f_{AveragedMembrane}(x,y)\\) (abbreviated as \\(f_{AM}(x,y)\\)) and a corresponding membrane mask \\(f_{MembraneMask}(x,y)\\) (abbreviated as \\(f_{MM}(x,y)\\) );</p> </li> <li> <p>Based on alignment information from <code>cryoSPARC</code>, i.e., the previously used <code>particles_selected.star</code> file, we can determine the displacement \\((\\Delta x, \\Delta y)\\) and rotation angle \\(\\psi\\) for each particle. Using these parameters, transform \\(f_{AM}(x,y)\\) and \\(f_{MM}(x,y)\\) accordingly to match each particle's membrane signal, resulting in transformed functions \\(f_{AM}'(x,y)\\) and \\(f_{MM}'(x,y)\\);</p> </li> <li> <p>For each particle, perform trajectory averaging using \\(f_{AM}'(x,y)\\) and \\(f_{MM}'(x,y)\\), thereby obtaining each particle's corresponding membrane signal \\(F_{AM}(x,y)\\) and mask \\(F_{MM}(x,y)\\);</p> </li> <li> <p>For each particle, to obtain \\(F_{SubtractedRawImage}(x,y)\\) (abbreviated as \\(F_{SRI}(x,y)\\) ), use the following equation:</p> </li> </ul> \\[ F_{SRI}(x,y) = F_{RI}(x,y) - \\lambda \\times F_{AM}(x,y) \\] <p>where \\(\\lambda\\) is a constant controlling the intensity of membrane subtraction. \\(\\lambda\\) is determined by:</p> \\[ \\lambda = \\arg \\min_{\\lambda} || F_{RI}(x,y) \\times F_{MM}(x,y) - \\lambda \\times F_{AM}(x,y) ||_1 \\]"},{"location":"tutorials/radonfit-tutorials/radonfit-particle-mem-subtraction/#2-specific-steps","title":"2 Specific Steps","text":""},{"location":"tutorials/radonfit-tutorials/radonfit-particle-mem-subtraction/#21-open-the-interface","title":"2.1 Open the Interface","text":"<p>First, open the <code>MemXTerminator</code> main program, select the <code>Radonfit</code> mode, then choose <code>Particles Membrane Subtraction</code>, and enter the Particles Membrane Subtraction interface:</p> <p> Particles Membrane Subtraction (Radonfit) interface</p>"},{"location":"tutorials/radonfit-tutorials/radonfit-particle-mem-subtraction/#22-set-appropriate-parameters","title":"2.2 Set Appropriate Parameters","text":"<p>In the Particles Membrane Subtraction interface:</p> <p></p> <p>Particles Membrane Subtraction (Radonfit) main interface</p> <p>You need to enter the following file paths:</p> <ul> <li> <p><code>Particles selected starfile</code>: Choose the <code>.star</code> file that saves all particles information, usually <code>particles_selected.star</code>;</p> </li> <li> <p><code>Membrane analysis results</code>: Choose the <code>.star</code> file that contains all membrane analysis information, usually <code>mem_analysis.star</code>;</p> </li> </ul> <p>You can set the following parameters:</p> <ul> <li> <p><code>Bias</code>: During membrane signal subtraction, you can set a bias value to manually adjust the strength of membrane signal removal. The actual membrane subtraction intensity \\(\\lambda' = \\lambda + \\text{bias}\\). Default is 0.05;</p> </li> <li> <p><code>Extra_mem_dist</code>: When performing trajectory averaging, you can set an extra membrane distance, which adds an additional distance to the membrane to increase the stability of the subtraction effect. Default is 15;</p> </li> <li> <p><code>Scaling_factor_start</code> and <code>Scaling_factor_end</code>: The search range for the scaling factor (i.e., \\(\\lambda\\)) during trajectory averaging. Default is between 0.1 and 1;</p> </li> <li> <p><code>Scaling_factor_step</code>: The search step for the scaling factor (i.e., \\(\\lambda\\)) during trajectory averaging. Default is 0.01. A smaller step size may result in more accurate determination of the scaling factor but increases computation time;</p> </li> <li> <p><code>CPU</code>: You can set multiple CPUs for computation. Default is 10. However, if your GPU memory is limited, it is advised not to set too many CPUs to avoid memory issues;</p> </li> <li> <p><code>Batch_size</code>: You can set how many particle stacks are processed in parallel. Default is 20, twice the number of CPUs. It is recommended to set it as a multiple of the CPU number. If your GPU memory is limited, it is advised not to set a large Batch size.</p> </li> </ul> <p>After setting the appropriate parameters, click <code>Launch</code> to begin the membrane signal subtraction.</p> <p>How to resume from a breakpoint</p> <p>If the job is interrupted for some reason, please don't worry. You can continue to do the membrane subtraction because every time you begin the membrane subtraction, the software will read the <code>radfit_pms_run_data.log</code> file, which records the particle stacks that have been processed. The software will automatically skip the processed particle stacks and continue to process the remaining particle stacks.</p>"},{"location":"tutorials/radonfit-tutorials/radonfit-particle-mem-subtraction/#3-results","title":"3 Results","text":"<p>You will find a <code>subtracted</code> folder next to the folder where you extracted the particles, like this:</p> <pre><code>Jxxx/\n\u251c\u2500\u2500 extract/\n\u251c\u2500\u2500 subtracted/\n</code></pre> <p>In the <code>subtracted</code> folder, you will find all the mrc files of the particles with membrane signals removed. You can proceed with further processing using <code>cryoSPARC</code> or put the membrane-subtracted particles back to the micrographs for subsequent processing.</p> <p>Warning</p> <p>Please note that the software can only recognize the <code>extract</code> folder in the <code>Jxxx</code> folder, and usually in the <code>particles_selected.star</code> file, the <code>rlnImageName</code> column contains the path like <code>Jxxx/extract/xxx.mrc</code>. If you find that the software cannot recognize the <code>extract</code> folder, please check the <code>particles_selected.star</code> file and make sure the <code>rlnImageName</code> column is correct.</p>"},{"location":"tutorials/reference/api/","title":"API reference","text":"<p>Currently under development. More content will come soon...</p>"},{"location":"tutorials/reference/bezierfit-mem-analysis-visualizer/","title":"Visualizing Bezier Analysis (.ipynb)","text":"In\u00a0[1]: Copied! <pre>import mrcfile\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom src.pickpoints import *\nfrom src.bezierfit import *\n</pre> import mrcfile import numpy as np import matplotlib.pyplot as plt from src.pickpoints import * from src.bezierfit import * In\u00a0[2]: Copied! <pre>filename_2Daverage = './db/templates_selected_bezierfit.mrc'\nsection = 16\ninitial_data_points_num = 500\n</pre> filename_2Daverage = './db/templates_selected_bezierfit.mrc' section = 16 initial_data_points_num = 500 In\u00a0[3]: Copied! <pre>with mrcfile.open(filename_2Daverage) as f:\n        image = f.data[section]\nmax_filtered_image = max_filter(image)\n# \u751f\u6210\u6570\u636e\u70b9\ndata_points = generate_data_points(image, initial_data_points_num)\n</pre> with mrcfile.open(filename_2Daverage) as f:         image = f.data[section] max_filtered_image = max_filter(image) # \u751f\u6210\u6570\u636e\u70b9 data_points = generate_data_points(image, initial_data_points_num) <p>Show the original image, max-filteed image, and the data points</p> In\u00a0[4]: Copied! <pre>plt.figure(figsize=(10, 5))\n\nplt.subplot(1, 3, 1)\nplt.imshow(image, cmap='gray', origin='lower')\nplt.title('Original Image')\nplt.axis('off')\n\nplt.subplot(1, 3, 2)\nplt.imshow(max_filtered_image, cmap='gray', origin='lower')\nplt.title('Max Filtered Image')\nplt.axis('off')\n\nplt.subplot(1, 3, 3)\nplt.imshow(image, cmap='gray', origin='lower')\nplt.title('Data Points')\nplt.axis('off')\nplt.plot(data_points[:, 0], data_points[:, 1], 'b.')\n\nplt.tight_layout()\nplt.show()\n</pre> plt.figure(figsize=(10, 5))  plt.subplot(1, 3, 1) plt.imshow(image, cmap='gray', origin='lower') plt.title('Original Image') plt.axis('off')  plt.subplot(1, 3, 2) plt.imshow(max_filtered_image, cmap='gray', origin='lower') plt.title('Max Filtered Image') plt.axis('off')  plt.subplot(1, 3, 3) plt.imshow(image, cmap='gray', origin='lower') plt.title('Data Points') plt.axis('off') plt.plot(data_points[:, 0], data_points[:, 1], 'b.')  plt.tight_layout() plt.show() In\u00a0[5]: Copied! <pre>bezier_degree = 3\ncoarse_iteration = 700\n</pre> bezier_degree = 3 coarse_iteration = 700 In\u00a0[6]: Copied! <pre>coarsefit = Coarsefit(image=image, num_points=initial_data_points_num, degree=bezier_degree, iteration=coarse_iteration)\ninitial_control_points = coarsefit()\nprint('Initial Control Points:', initial_control_points)\n</pre> coarsefit = Coarsefit(image=image, num_points=initial_data_points_num, degree=bezier_degree, iteration=coarse_iteration) initial_control_points = coarsefit() print('Initial Control Points:', initial_control_points) <pre>gen\tnevals\tavg        \tstd        \tmin        \tmax        \n0  \t100   \t1.93298e+07\t7.45036e+06\t3.93846e+06\t3.83652e+07\n1  \t77    \t1.10273e+07\t4.44083e+06\t3.38866e+06\t2.60016e+07\n2  \t67    \t6.60018e+06\t2.38678e+06\t2.6819e+06 \t1.65696e+07\n3  \t73    \t4.40417e+06\t1.62709e+06\t1.53115e+06\t1.0306e+07 \n4  \t67    \t2.97223e+06\t940933     \t1.31142e+06\t7.97569e+06\n5  \t71    \t2.13214e+06\t530194     \t1.17533e+06\t3.58231e+06\n6  \t80    \t1.63262e+06\t480155     \t855839     \t3.43829e+06\n7  \t77    \t1.22557e+06\t270201     \t557494     \t2.1998e+06 \n8  \t71    \t955983     \t213393     \t447932     \t1.68143e+06\n9  \t63    \t770947     \t184040     \t411039     \t1.37217e+06\n10 \t66    \t608170     \t164867     \t363731     \t1.63209e+06\n11 \t76    \t471268     \t84517.5    \t335800     \t875004     \n12 \t75    \t402217     \t65320.7    \t282429     \t764520     \n13 \t72    \t364355     \t64332.5    \t249205     \t593900     \n14 \t78    \t307629     \t40947      \t249374     \t473903     \n15 \t77    \t274175     \t39973.4    \t241838     \t568967     \n16 \t69    \t257194     \t21318.6    \t225375     \t377353     \n17 \t77    \t249405     \t18557.8    \t217120     \t369865     \n18 \t80    \t237679     \t13909.3    \t207754     \t290000     \n19 \t62    \t227083     \t12381.8    \t203763     \t275653     \n20 \t68    \t216277     \t8398.24    \t203234     \t256801     \n21 \t69    \t208990     \t5482.95    \t194853     \t228478     \n22 \t72    \t203920     \t3707.32    \t191126     \t216292     \n23 \t78    \t200288     \t5395.62    \t189291     \t217650     \n24 \t66    \t194851     \t4505.88    \t184760     \t210028     \n25 \t72    \t190041     \t3696.42    \t175608     \t201486     \n26 \t69    \t185691     \t4200.33    \t174370     \t199368     \n27 \t74    \t180568     \t4039.82    \t170599     \t187977     \n28 \t74    \t176310     \t3329.89    \t169470     \t186728     \n29 \t71    \t173450     \t2645.35    \t167552     \t183546     \n30 \t73    \t170948     \t2351.78    \t166573     \t176966     \n31 \t77    \t168841     \t1920.22    \t163660     \t173963     \n32 \t65    \t167178     \t1643.46    \t162596     \t174764     \n33 \t70    \t165686     \t1702.06    \t159819     \t171237     \n34 \t76    \t163864     \t2085.02    \t157636     \t169755     \n35 \t83    \t161373     \t1939.5     \t153670     \t166597     \n36 \t68    \t159108     \t1755.73    \t153288     \t162774     \n37 \t71    \t156907     \t2050.2     \t150813     \t162282     \n38 \t74    \t154345     \t2146.01    \t149616     \t159125     \n39 \t78    \t151961     \t1356.37    \t147496     \t155552     \n40 \t76    \t150348     \t1543.68    \t144023     \t154020     \n41 \t66    \t148530     \t2311.19    \t140963     \t154154     \n42 \t77    \t145529     \t2794.44    \t138214     \t151384     \n43 \t73    \t142033     \t2174.68    \t137179     \t151633     \n44 \t74    \t139879     \t1739.68    \t136464     \t146888     \n45 \t81    \t137951     \t1158.93    \t135144     \t141423     \n46 \t72    \t136780     \t1065.08    \t134223     \t140680     \n47 \t72    \t135583     \t1058.09    \t129142     \t139174     \n48 \t82    \t134635     \t1438.91    \t128823     \t138762     \n49 \t60    \t132632     \t2278.95    \t127047     \t136828     \n50 \t77    \t129798     \t1858.74    \t125466     \t135096     \n51 \t68    \t127739     \t1603       \t123044     \t131698     \n52 \t62    \t126072     \t1387.45    \t122668     \t129465     \n53 \t71    \t124506     \t1497.42    \t119741     \t128509     \n54 \t64    \t122802     \t1916.03    \t117433     \t126666     \n55 \t61    \t120207     \t2182.29    \t113964     \t126650     \n56 \t76    \t117660     \t2370.47    \t112090     \t123520     \n57 \t73    \t114754     \t1940.27    \t111012     \t122515     \n58 \t69    \t112642     \t1190.88    \t109217     \t116409     \n59 \t78    \t111145     \t1074.21    \t108904     \t114498     \n60 \t74    \t109843     \t938.884    \t107156     \t111928     \n61 \t67    \t108823     \t1039.61    \t106055     \t111548     \n62 \t57    \t107595     \t911.344    \t105650     \t109873     \n63 \t73    \t106565     \t717.252    \t104323     \t108820     \n64 \t62    \t105981     \t891.732    \t103899     \t109912     \n65 \t73    \t105068     \t834.759    \t102613     \t107161     \n66 \t78    \t104049     \t796.307    \t102298     \t105983     \n67 \t77    \t103221     \t622.306    \t101504     \t104484     \n68 \t73    \t102443     \t794.3      \t99378.6    \t104484     \n69 \t74    \t101749     \t1155.43    \t97897.9    \t108187     \n70 \t71    \t100614     \t1188.58    \t97278.7    \t104646     \n71 \t72    \t99234.5    \t1425.43    \t95211.1    \t103105     \n72 \t69    \t97197      \t1454.65    \t94069.6    \t102040     \n73 \t68    \t95665      \t1119.02    \t92599.9    \t97950.3    \n74 \t77    \t94407.9    \t878.002    \t92131.7    \t96861.2    \n75 \t73    \t93487      \t678.177    \t92131.7    \t95604.5    \n76 \t70    \t92758.3    \t622.941    \t90809      \t94536.3    \n77 \t73    \t92008.2    \t597.618    \t90026      \t93689.8    \n78 \t63    \t91293      \t704.382    \t89147.4    \t93374.1    \n79 \t73    \t90589.3    \t623.21     \t89147.4    \t92264.6    \n80 \t80    \t89953      \t640.25     \t88761.3    \t92712.9    \n81 \t73    \t89301.6    \t440.816    \t87904.1    \t90659.8    \n82 \t78    \t88887.8    \t527.33     \t87591.1    \t90590.2    \n83 \t75    \t88306      \t560.258    \t86823      \t90620.2    \n84 \t66    \t87709.6    \t553.403    \t85709.8    \t89652.5    \n85 \t72    \t87120.5    \t631.092    \t85142.4    \t88409      \n86 \t73    \t86526.1    \t698.785    \t85072.6    \t88680.2    \n87 \t66    \t85839.1    \t570.544    \t84695.9    \t88142.9    \n88 \t72    \t85307.7    \t410.745    \t84674.7    \t86729.9    \n89 \t84    \t84980.7    \t429.339    \t83863.3    \t87034.8    \n90 \t76    \t84583.6    \t378.761    \t83430.7    \t85646.3    \n91 \t67    \t84151.6    \t377.758    \t83321.5    \t85721.9    \n92 \t82    \t83797.3    \t338.27     \t82929      \t84955.8    \n93 \t72    \t83517.6    \t298.837    \t82894.5    \t84508.1    \n94 \t73    \t83238.4    \t355.472    \t82144.2    \t84289.1    \n95 \t74    \t82941.2    \t368.185    \t81876.5    \t84481.8    \n96 \t84    \t82668.4    \t472.755    \t81423      \t84542.5    \n97 \t84    \t82205.7    \t480.11     \t81158.3    \t83573.7    \n98 \t72    \t81654.9    \t371.628    \t80876.3    \t82751.4    \n99 \t76    \t81314.4    \t284.989    \t80792.9    \t82222.2    \n100\t75    \t81087.1    \t271.145    \t80401.1    \t81941.6    \n101\t80    \t80856.4    \t260.979    \t79910.8    \t81897.6    \n102\t73    \t80605.8    \t296.911    \t79880.3    \t81622.7    \n103\t72    \t80275.7    \t312.174    \t79656.9    \t81516.6    \n104\t69    \t79985      \t209.016    \t79599.7    \t81042.3    \n105\t65    \t79843.6    \t185.629    \t79491.8    \t80803.8    \n106\t67    \t79683.2    \t138.869    \t79174.3    \t80066.3    \n107\t72    \t79548.6    \t209.701    \t78931.3    \t80455.4    \n108\t65    \t79355.1    \t247.657    \t78600.4    \t80328.4    \n109\t74    \t79134.9    \t235.616    \t78358.7    \t79874.4    \n110\t80    \t78898.1    \t258.626    \t78353      \t79952      \n111\t71    \t78693.8    \t267.205    \t78200.7    \t79940.6    \n112\t71    \t78477.1    \t224.25     \t77806.3    \t79994.1    \n113\t82    \t78300.2    \t302.094    \t77376.7    \t79363.9    \n114\t69    \t78048.6    \t363.613    \t77057.4    \t79283      \n115\t77    \t77776.3    \t334.823    \t77057.4    \t79055.7    \n116\t74    \t77475.6    \t242.687    \t77038.7    \t78366.7    \n117\t66    \t77288.8    \t190.993    \t76788.5    \t77973.1    \n118\t74    \t77139.2    \t150.006    \t76809.8    \t77556.3    \n119\t65    \t76996.5    \t152.493    \t76636.2    \t77696.2    \n120\t70    \t76875.8    \t184.349    \t76515.9    \t77612.4    \n121\t64    \t76701.6    \t147.436    \t76258.6    \t77256.3    \n122\t79    \t76586.6    \t161.884    \t76006.8    \t77074.5    \n123\t72    \t76487.9    \t194.356    \t76090      \t77170.2    \n124\t72    \t76313.4    \t192.52     \t75795.2    \t76950.3    \n125\t82    \t76157.7    \t169.537    \t75695.7    \t76903.8    \n126\t62    \t76000.1    \t199.078    \t75550.9    \t76849.5    \n127\t66    \t75810.6    \t202.931    \t75052.6    \t76422.2    \n128\t80    \t75654.7    \t215.375    \t75096.2    \t76619.6    \n129\t68    \t75478.1    \t173.679    \t74893.9    \t76119.7    \n130\t79    \t75362.7    \t219.425    \t74801      \t76429.2    \n131\t77    \t75205      \t219.06     \t74771.6    \t76286      \n132\t76    \t75058.3    \t279.466    \t74624.6    \t76656.3    \n133\t65    \t74857.9    \t166.29     \t74469.8    \t75460.9    \n134\t81    \t74764.9    \t188.31     \t74182.4    \t75473.3    \n135\t69    \t74651.2    \t285.532    \t74182.4    \t76137.3    \n136\t73    \t74489      \t234.828    \t74120      \t75674.3    \n137\t66    \t74262.4    \t159.169    \t73788.5    \t74847.5    \n138\t64    \t74150.8    \t189.427    \t73788.5    \t75066      \n139\t73    \t74011.4    \t171.374    \t73612.3    \t74491.6    \n140\t73    \t73858.1    \t217.064    \t73367.4    \t75066.3    \n141\t72    \t73716      \t190.081    \t73236.2    \t74548.1    \n142\t69    \t73519.8    \t224.442    \t73090.9    \t74305.6    \n143\t75    \t73349.5    \t204.245    \t72897.9    \t74222      \n144\t68    \t73205.4    \t137.624    \t72897.9    \t73960.5    \n145\t70    \t73127.3    \t134.154    \t72875.6    \t73798.4    \n146\t67    \t73052      \t187.043    \t72675.9    \t73944.7    \n147\t73    \t72917.9    \t173.014    \t72442.5    \t73767.7    \n148\t75    \t72813.3    \t188.49     \t72367.4    \t73512.8    \n149\t72    \t72676.1    \t173.453    \t72367.4    \t73293      \n150\t82    \t72570.6    \t155.449    \t72316.2    \t73323.1    \n151\t70    \t72451.3    \t92.5147    \t72274.3    \t72735.4    \n152\t72    \t72383.3    \t99.189     \t72157.9    \t72922.9    \n153\t70    \t72338.9    \t181.753    \t72083.2    \t73519      \n154\t80    \t72253.5    \t129.241    \t71949.7    \t72677.2    \n155\t55    \t72147.1    \t114.626    \t71946.4    \t72750.4    \n156\t71    \t72081.8    \t106.28     \t71776      \t72359.4    \n157\t75    \t71990      \t132.03     \t71728.4    \t72708.2    \n158\t66    \t71914.5    \t134.683    \t71622.2    \t72623.5    \n159\t70    \t71816.7    \t122.371    \t71622.2    \t72335.8    \n160\t73    \t71755.3    \t146.342    \t71556.6    \t72323.4    \n161\t78    \t71688.9    \t170.932    \t71531.7    \t72894.5    \n162\t69    \t71623.7    \t98.9562    \t71477.6    \t72140.1    \n163\t80    \t71605.1    \t140.025    \t71379.7    \t72096.9    \n164\t58    \t71521.2    \t120.2      \t71271.6    \t71948.5    \n165\t71    \t71455.5    \t144.596    \t71271.6    \t72456.3    \n166\t78    \t71388.8    \t116.098    \t71219.2    \t71984.1    \n167\t76    \t71332.2    \t92.2036    \t71188.1    \t71687.5    \n168\t74    \t71287.6    \t122.409    \t71172.3    \t71961.9    \n169\t72    \t71249.3    \t131.708    \t71110.3    \t72038.7    \n170\t73    \t71205.3    \t103.642    \t71097.8    \t71647.4    \n171\t68    \t71154.8    \t66.6753    \t71065.3    \t71480.5    \n172\t71    \t71125.4    \t57.9064    \t71047      \t71392.2    \n173\t63    \t71106      \t84.4234    \t71004.1    \t71674.8    \n174\t77    \t71099.1    \t98.8177    \t70988.2    \t71691.4    \n175\t63    \t71066.6    \t100.781    \t70982.3    \t71501.9    \n176\t73    \t71038.3    \t75.1214    \t70927.1    \t71364      \n177\t76    \t71001.8    \t64.062     \t70898.1    \t71302.5    \n178\t69    \t70982.6    \t73.3536    \t70886.5    \t71364.4    \n179\t73    \t70983.7    \t148.255    \t70880.6    \t72075.5    \n180\t68    \t70959.2    \t184.416    \t70866.2    \t72628.8    \n181\t75    \t70932.3    \t103.697    \t70840.1    \t71521.9    \n182\t74    \t70905.6    \t95.5782    \t70816.1    \t71557.8    \n183\t72    \t70876.5    \t73.4116    \t70776.7    \t71224.3    \n184\t77    \t70866.4    \t107.68     \t70764.6    \t71630.4    \n185\t74    \t70835.2    \t104.662    \t70723.5    \t71490.2    \n186\t75    \t70802.2    \t78.905     \t70695.5    \t71182.1    \n187\t78    \t70784.4    \t72.8487    \t70680.5    \t71125.9    \n188\t71    \t70753.6    \t81.3207    \t70640.3    \t71210.4    \n189\t68    \t70732.1    \t73.0191    \t70639.7    \t71092.3    \n190\t76    \t70706.6    \t82.2918    \t70593.7    \t71063      \n191\t72    \t70672.3    \t56.0005    \t70583.1    \t70859.4    \n192\t72    \t70663.5    \t75.6656    \t70562.3    \t70996.7    \n193\t79    \t70649.9    \t124.451    \t70541.2    \t71344.2    \n194\t76    \t70613.4    \t74.9445    \t70530.6    \t70993.8    \n195\t64    \t70578.1    \t43.1494    \t70519.3    \t70784.5    \n196\t74    \t70580.3    \t108.2      \t70491.9    \t71175.5    \n197\t71    \t70566.2    \t90.0578    \t70481      \t70971.4    \n198\t72    \t70549.4    \t91.5063    \t70481      \t70972.6    \n199\t65    \t70529.9    \t95.0373    \t70479.2    \t71083.6    \n200\t71    \t70507.1    \t68.998     \t70462.6    \t71053.5    \n201\t63    \t70502.8    \t62.0261    \t70458.3    \t70804.5    \n202\t64    \t70481.5    \t59.8537    \t70448.6    \t71015.1    \n203\t68    \t70492.3    \t78.1776    \t70431.7    \t70953.2    \n204\t67    \t70506.1    \t135.181    \t70421      \t71212.4    \n205\t74    \t70495.1    \t141.103    \t70405.4    \t71257.6    \n206\t67    \t70463      \t93.4677    \t70372.2    \t70978.4    \n207\t71    \t70478.7    \t148.901    \t70358.9    \t71294.5    \n208\t63    \t70435.9    \t88.4804    \t70358.9    \t70876.3    \n209\t72    \t70453.6    \t176.644    \t70344.1    \t71378.4    \n210\t81    \t70402.3    \t61.9158    \t70335.7    \t70722.2    \n211\t78    \t70406.8    \t96.9284    \t70326.8    \t71038      \n212\t64    \t70371.5    \t51.5666    \t70326.8    \t70621.3    \n213\t82    \t70372.5    \t102.967    \t70319.7    \t71094.3    \n214\t85    \t70358.2    \t79.2217    \t70314.8    \t70757.1    \n215\t80    \t70357.8    \t90.3797    \t70290.3    \t71017.2    \n216\t75    \t70345.4    \t69.2047    \t70278.1    \t70835.6    \n217\t67    \t70328.2    \t71.1097    \t70278.1    \t70756.2    \n218\t56    \t70321.4    \t87.5809    \t70275.6    \t70783.5    \n219\t59    \t70297.2    \t40.1293    \t70265.8    \t70480.1    \n220\t66    \t70316      \t116.568    \t70261.3    \t70912.1    \n221\t73    \t70306.1    \t122.749    \t70261.3    \t71417.2    \n222\t75    \t70311.6    \t117.059    \t70259.6    \t71204.7    \n223\t69    \t70292.4    \t91.1066    \t70256.3    \t71007.4    \n224\t76    \t70307.2    \t94.4793    \t70233.6    \t70676.5    \n225\t80    \t70285.7    \t72.6069    \t70233.6    \t70657.6    \n226\t59    \t70285.8    \t88.9897    \t70228.3    \t70844.1    \n227\t71    \t70259.3    \t41.1383    \t70228.3    \t70492.9    \n228\t76    \t70266.4    \t85.3976    \t70225.7    \t70772.1    \n229\t69    \t70258.3    \t70.1542    \t70220.5    \t70667.6    \n230\t65    \t70252.5    \t72.5794    \t70217.5    \t70760.1    \n231\t79    \t70262.8    \t111.637    \t70214.4    \t71016.7    \n232\t67    \t70245.5    \t84.9601    \t70214.4    \t70809.4    \n233\t74    \t70242.8    \t75.7363    \t70206.8    \t70740.1    \n234\t73    \t70237.4    \t71.9866    \t70206.6    \t70626.5    \n235\t75    \t70220.7    \t28.0785    \t70201.7    \t70381.2    \n236\t78    \t70248.4    \t100.9      \t70201      \t70749.8    \n237\t75    \t70232.4    \t62.4606    \t70198.7    \t70542.8    \n238\t76    \t70239.7    \t111.486    \t70193.7    \t70947.8    \n239\t62    \t70229.2    \t87.7483    \t70193.7    \t70750.6    \n240\t81    \t70227.7    \t67.7814    \t70191.6    \t70620      \n241\t68    \t70215.2    \t63.3902    \t70190.6    \t70606.7    \n242\t77    \t70232.2    \t125.661    \t70186.3    \t71068.9    \n243\t80    \t70209.3    \t60.1309    \t70184.5    \t70614.1    \n244\t67    \t70233      \t116.073    \t70183.3    \t70815      \n245\t78    \t70216.4    \t88.1889    \t70180      \t70717.9    \n246\t68    \t70217.7    \t87.4873    \t70180      \t70664.7    \n247\t64    \t70207.7    \t80.2926    \t70179.7    \t70738.9    \n248\t73    \t70211.3    \t76.279     \t70177.4    \t70691.8    \n249\t69    \t70209.9    \t80.6683    \t70173.1    \t70578.8    \n250\t69    \t70201.7    \t64.395     \t70172.4    \t70573      \n251\t80    \t70218.7    \t106.731    \t70172.4    \t70922.1    \n252\t75    \t70200.4    \t59.7435    \t70172.4    \t70451.7    \n253\t57    \t70193.5    \t48.3375    \t70172.4    \t70404.7    \n254\t63    \t70210.8    \t112.838    \t70170.6    \t71026      \n255\t72    \t70198.4    \t65.7852    \t70170.6    \t70554      \n256\t66    \t70208.9    \t102.264    \t70169      \t70825.1    \n257\t72    \t70197.2    \t64.227     \t70166.2    \t70593      \n258\t70    \t70204.4    \t81.8356    \t70161.8    \t70588.5    \n259\t74    \t70200.5    \t77.8624    \t70160.2    \t70626.8    \n260\t77    \t70185.5    \t48.1584    \t70159.8    \t70432.8    \n261\t68    \t70177.4    \t53.3886    \t70159.8    \t70608.4    \n262\t66    \t70185      \t53.543     \t70158.4    \t70417.3    \n263\t73    \t70193.6    \t77.5774    \t70157.8    \t70507.5    \n264\t71    \t70186.5    \t73.4263    \t70156.4    \t70576.2    \n265\t76    \t70183.9    \t77.1089    \t70154.8    \t70711      \n266\t63    \t70190      \t85.8046    \t70154.8    \t70680.5    \n267\t70    \t70179      \t66.7107    \t70153      \t70505.2    \n268\t72    \t70180.2    \t77.6124    \t70152.5    \t70726.4    \n269\t71    \t70176      \t63.3907    \t70152.5    \t70578      \n270\t66    \t70186.9    \t76.3367    \t70152.5    \t70535.8    \n271\t75    \t70178.8    \t65.465     \t70152      \t70576.9    \n272\t73    \t70182.2    \t77.5626    \t70152      \t70584.8    \n273\t79    \t70180.7    \t100.419    \t70151.8    \t70876.8    \n274\t79    \t70186      \t91.7746    \t70151.7    \t70814.3    \n275\t82    \t70179.5    \t79.6825    \t70151.2    \t70774.6    \n276\t71    \t70177.4    \t78.8808    \t70151.2    \t70735.7    \n277\t64    \t70189.2    \t104.864    \t70150.9    \t70815.5    \n278\t70    \t70170.2    \t53.2298    \t70150.8    \t70462.6    \n279\t75    \t70184.1    \t78.2798    \t70150.4    \t70551.3    \n280\t74    \t70182      \t87.0134    \t70150.3    \t70749.7    \n281\t64    \t70165.3    \t39.8781    \t70150.1    \t70372.3    \n282\t71    \t70189.8    \t100.093    \t70150      \t70873.1    \n283\t70    \t70172.8    \t68.9089    \t70149.7    \t70603.7    \n284\t77    \t70179.9    \t75.0207    \t70149.2    \t70588.6    \n285\t63    \t70179      \t70.9523    \t70149.1    \t70546.6    \n286\t69    \t70160.4    \t42.3938    \t70148.4    \t70505.7    \n287\t72    \t70191.6    \t114.214    \t70148.3    \t70843.9    \n288\t64    \t70185.9    \t94.4247    \t70148.2    \t70713.1    \n289\t76    \t70171.1    \t49.4649    \t70148      \t70404.1    \n290\t77    \t70174.2    \t81.209     \t70147.8    \t70740.3    \n291\t67    \t70162.5    \t52.1755    \t70147.6    \t70504.2    \n292\t77    \t70181.8    \t90.3273    \t70147.6    \t70703      \n293\t66    \t70175.8    \t71.7222    \t70147.5    \t70623.3    \n294\t76    \t70172.7    \t83.8332    \t70147.5    \t70809.9    \n295\t66    \t70163.7    \t62.6232    \t70147.4    \t70631.7    \n296\t65    \t70170.8    \t70.717     \t70147.4    \t70603.7    \n297\t71    \t70182.8    \t109.816    \t70147.3    \t70914.2    \n298\t69    \t70182      \t74.2484    \t70147.3    \t70557.2    \n299\t62    \t70177.8    \t102.13     \t70147.3    \t70833.6    \n300\t71    \t70169.9    \t63.4763    \t70147      \t70611      \n301\t78    \t70175.2    \t81.5195    \t70146.9    \t70664.4    \n302\t67    \t70167.7    \t55.7338    \t70146.8    \t70400.9    \n303\t70    \t70171.1    \t73.1817    \t70146.7    \t70501.6    \n304\t80    \t70165.4    \t55.1772    \t70146.7    \t70469.6    \n305\t73    \t70182.1    \t96.2128    \t70146.6    \t70857      \n306\t79    \t70180.3    \t97.5704    \t70146.6    \t70770.3    \n307\t78    \t70177.5    \t81.3719    \t70146.1    \t70727      \n308\t69    \t70179.5    \t88.1878    \t70145.8    \t70655.1    \n309\t69    \t70173.1    \t78.1677    \t70145.8    \t70643.7    \n310\t77    \t70173.4    \t87.4665    \t70145.8    \t70692.8    \n311\t74    \t70180.8    \t102.723    \t70145.6    \t70892.7    \n312\t74    \t70160.5    \t55.3707    \t70145.6    \t70589.8    \n313\t68    \t70169.9    \t55.1585    \t70145.5    \t70435      \n314\t70    \t70173.2    \t83.9731    \t70145.4    \t70641.2    \n315\t75    \t70193.4    \t115.977    \t70145.3    \t70722.4    \n316\t76    \t70164.8    \t70.7144    \t70145.3    \t70625.5    \n317\t72    \t70158.5    \t39.2913    \t70145.2    \t70375.3    \n318\t79    \t70184.6    \t99.7582    \t70144.5    \t70700.2    \n319\t68    \t70172.4    \t65.3169    \t70144.5    \t70519.6    \n320\t75    \t70165.2    \t44.2132    \t70144.5    \t70374.8    \n321\t66    \t70167.5    \t78.8841    \t70144.5    \t70726.1    \n322\t70    \t70174.6    \t109.226    \t70144.4    \t71086.7    \n323\t69    \t70168.8    \t59.9534    \t70144.4    \t70530.5    \n324\t70    \t70175.6    \t123.278    \t70144.4    \t71219.4    \n325\t76    \t70182.1    \t101.507    \t70144.4    \t70711.4    \n326\t79    \t70171.4    \t59.0811    \t70144.3    \t70444.6    \n327\t80    \t70178.9    \t90.5959    \t70144.3    \t70601.9    \n328\t72    \t70172.7    \t81.3126    \t70143.6    \t70621.8    \n329\t69    \t70174.5    \t77.6646    \t70143.8    \t70580      \n330\t66    \t70168.7    \t75.1296    \t70143.8    \t70783      \n331\t79    \t70164.7    \t55.3305    \t70143.5    \t70399.9    \n332\t72    \t70164.3    \t59.4877    \t70143.4    \t70514      \n333\t79    \t70176.8    \t104.497    \t70143.4    \t70782.9    \n334\t61    \t70161.3    \t53.7778    \t70143.4    \t70495.6    \n335\t74    \t70164.5    \t59.2257    \t70143.3    \t70535      \n336\t69    \t70165.8    \t65.9298    \t70142.9    \t70569      \n337\t70    \t70172.1    \t90.4292    \t70142.4    \t70745.4    \n338\t57    \t70179.7    \t105.077    \t70142.3    \t70729      \n339\t65    \t70169      \t92.1286    \t70142.3    \t70874.2    \n340\t67    \t70183.3    \t81.7284    \t70142.3    \t70519.9    \n341\t66    \t70169.1    \t84.7801    \t70142.3    \t70779      \n342\t71    \t70161.3    \t61.8475    \t70141.3    \t70618.4    \n343\t76    \t70180.5    \t138.229    \t70141.3    \t71353.7    \n344\t69    \t70179.6    \t115.269    \t70141.3    \t71097.1    \n345\t73    \t70160.4    \t49.8964    \t70141.2    \t70454.5    \n346\t63    \t70167.5    \t90.8644    \t70141.1    \t70853.2    \n347\t71    \t70165.8    \t68.8576    \t70141.1    \t70569.9    \n348\t75    \t70185.1    \t107.069    \t70141      \t70760.1    \n349\t73    \t70170.7    \t88.4331    \t70141      \t70667.8    \n350\t73    \t70164.4    \t65.4151    \t70140.8    \t70553.3    \n351\t81    \t70170.4    \t76.1254    \t70140.8    \t70690.2    \n352\t65    \t70160.2    \t51.3828    \t70140.8    \t70463.3    \n353\t73    \t70159.8    \t53.5856    \t70140.8    \t70447.1    \n354\t71    \t70176.2    \t133.248    \t70140.8    \t71228.9    \n355\t73    \t70173      \t101.976    \t70140.7    \t70716.3    \n356\t78    \t70174.4    \t108.879    \t70140.7    \t70899.7    \n357\t61    \t70160.8    \t60.047     \t70140.7    \t70633.5    \n358\t71    \t70174.9    \t79.4858    \t70140.7    \t70613.6    \n359\t70    \t70184.6    \t104.751    \t70140.7    \t70863.2    \n360\t64    \t70163.3    \t73.5177    \t70140.7    \t70555      \n361\t78    \t70172.9    \t91.9752    \t70140.7    \t70816.3    \n362\t61    \t70158.7    \t51.6952    \t70140.7    \t70414.9    \n363\t77    \t70179.1    \t99.4498    \t70140.7    \t70658.9    \n364\t68    \t70163.2    \t69.8087    \t70140.7    \t70558.5    \n365\t74    \t70164.6    \t72.6055    \t70140.7    \t70532.9    \n366\t72    \t70172.5    \t104.073    \t70140.5    \t70988.8    \n367\t79    \t70182.7    \t117.922    \t70140.4    \t70732.1    \n368\t68    \t70171.8    \t102.916    \t70140.4    \t70820.1    \n369\t68    \t70168.3    \t78.9463    \t70140.4    \t70723.3    \n370\t70    \t70159      \t47.8688    \t70140.4    \t70360.6    \n371\t65    \t70165.2    \t83.3526    \t70140.3    \t70636.1    \n372\t73    \t70177.6    \t108.901    \t70140.3    \t70923.3    \n373\t70    \t70180.9    \t121.652    \t70140.3    \t70963.3    \n374\t74    \t70160.5    \t88.0695    \t70140.3    \t70875.2    \n375\t72    \t70159.9    \t57.4204    \t70140.3    \t70528.5    \n376\t69    \t70171.9    \t89.6398    \t70140.3    \t70822.2    \n377\t73    \t70174.7    \t102.043    \t70140.3    \t70852.2    \n378\t82    \t70154.2    \t39.1806    \t70140.3    \t70371      \n379\t66    \t70172.7    \t96.397     \t70140.3    \t70742.4    \n380\t70    \t70158.6    \t44.0683    \t70140.3    \t70369.2    \n381\t71    \t70150.9    \t35.4356    \t70140.3    \t70335.2    \n382\t73    \t70170.9    \t84.7181    \t70140.3    \t70592.6    \n383\t70    \t70165.5    \t67.9163    \t70140.3    \t70543.7    \n384\t67    \t70162.8    \t62.2117    \t70140.3    \t70528.6    \n385\t66    \t70155      \t55.4458    \t70140.3    \t70532.6    \n386\t74    \t70153.7    \t41.1611    \t70140.3    \t70430.2    \n387\t71    \t70192      \t193.471    \t70140.2    \t71884.7    \n388\t71    \t70163.2    \t86.4693    \t70140.2    \t70862.4    \n389\t76    \t70177.3    \t104.086    \t70139.8    \t70909.2    \n390\t63    \t70158.9    \t66.4424    \t70139.8    \t70708.6    \n391\t74    \t70165.2    \t58.4125    \t70139.8    \t70463.7    \n392\t71    \t70166.6    \t72.6105    \t70139.7    \t70578.1    \n393\t77    \t70165.2    \t70.5379    \t70139.7    \t70605.2    \n394\t71    \t70154.5    \t65.5804    \t70139.7    \t70620.5    \n395\t67    \t70157.2    \t58.8287    \t70139.7    \t70526.3    \n396\t78    \t70170.5    \t92.2738    \t70139.7    \t70720.5    \n397\t76    \t70160.5    \t55.6704    \t70139.7    \t70474.6    \n398\t70    \t70159.7    \t59.5535    \t70139.7    \t70476      \n399\t67    \t70176      \t97.318     \t70139.7    \t70742.1    \n400\t74    \t70171.8    \t100.138    \t70139.7    \t70750.5    \n401\t76    \t70170.7    \t95.6087    \t70139.7    \t70921.9    \n402\t75    \t70172.1    \t91.1559    \t70139.7    \t70663.7    \n403\t73    \t70163.6    \t73.5009    \t70139.7    \t70536.5    \n404\t75    \t70167.6    \t71.5575    \t70139.7    \t70610.2    \n405\t77    \t70162.1    \t70.0827    \t70139.4    \t70660.3    \n406\t64    \t70167.5    \t74.8699    \t70139.4    \t70616.1    \n407\t64    \t70162.5    \t68.2297    \t70139.4    \t70690.2    \n408\t73    \t70167.6    \t73.8299    \t70139.3    \t70525.2    \n409\t82    \t70163.9    \t77.6862    \t70139.3    \t70675      \n410\t79    \t70165.7    \t69.2492    \t70139.3    \t70529.6    \n411\t72    \t70161.5    \t81.8093    \t70139.3    \t70828.1    \n412\t67    \t70167.3    \t83.9043    \t70139.3    \t70677.2    \n413\t64    \t70171      \t120.126    \t70139.3    \t71196.5    \n414\t69    \t70162.6    \t62.9534    \t70139.3    \t70439.9    \n415\t72    \t70168.4    \t75.7922    \t70139.3    \t70587.2    \n416\t74    \t70158.1    \t57.8689    \t70139.3    \t70498.6    \n417\t76    \t70162.2    \t61.3149    \t70139.3    \t70548.2    \n418\t74    \t70158.4    \t54.1552    \t70139.2    \t70420      \n419\t76    \t70161.6    \t60.9598    \t70139.2    \t70539.2    \n420\t69    \t70178.8    \t101.035    \t70139.2    \t70717.7    \n421\t72    \t70159.2    \t58.652     \t70139.2    \t70486.6    \n422\t82    \t70169.6    \t75.3349    \t70139.2    \t70506.5    \n423\t69    \t70156.9    \t47.8082    \t70139.1    \t70405.4    \n424\t72    \t70169.2    \t82.9178    \t70139.1    \t70671      \n425\t79    \t70164.6    \t70.9574    \t70139.1    \t70571.8    \n426\t75    \t70170.1    \t84.3139    \t70139.1    \t70566      \n427\t68    \t70164.4    \t76.8647    \t70139.1    \t70711.1    \n428\t66    \t70166.9    \t68.5605    \t70139.1    \t70461.6    \n429\t77    \t70171.8    \t100.954    \t70139.1    \t70995.8    \n430\t70    \t70170.1    \t114.175    \t70139.1    \t71104.4    \n431\t79    \t70156.6    \t56.1303    \t70139.1    \t70507.2    \n432\t80    \t70168.3    \t71.1203    \t70139.1    \t70530.9    \n433\t72    \t70161.7    \t51.8344    \t70139.1    \t70379.1    \n434\t74    \t70162.7    \t63.2119    \t70139.1    \t70529.2    \n435\t72    \t70170.2    \t79.2474    \t70139.1    \t70550.9    \n436\t57    \t70170      \t117.051    \t70139.1    \t70894.2    \n437\t77    \t70178.6    \t106.206    \t70139.1    \t70692.5    \n438\t68    \t70166.3    \t62.5192    \t70139.1    \t70381.6    \n439\t71    \t70169.4    \t95.6304    \t70139.1    \t70748.6    \n440\t75    \t70160.8    \t66.1806    \t70139      \t70491.7    \n441\t73    \t70167.7    \t76.0811    \t70139      \t70615.8    \n442\t59    \t70152.4    \t39.3667    \t70139      \t70325.2    \n443\t66    \t70163.6    \t71.5049    \t70139      \t70592.2    \n444\t63    \t70161.6    \t55.1092    \t70139      \t70461.5    \n445\t69    \t70152.8    \t51.5603    \t70139      \t70479.5    \n446\t76    \t70152.9    \t50.242     \t70139      \t70423.7    \n447\t60    \t70164.3    \t66.2144    \t70139      \t70533.9    \n448\t66    \t70162.5    \t67.7063    \t70138.9    \t70506.5    \n449\t69    \t70157.1    \t54.0561    \t70138.9    \t70506.4    \n450\t71    \t70167.8    \t82.8506    \t70138.9    \t70615.1    \n451\t66    \t70164.1    \t75.0728    \t70138.9    \t70605.9    \n452\t77    \t70173.8    \t80.84      \t70138.9    \t70478.3    \n453\t69    \t70163.9    \t78.3589    \t70138.8    \t70768.7    \n454\t71    \t70161.1    \t57.8966    \t70138.8    \t70444.1    \n455\t65    \t70163.9    \t74.8285    \t70138.8    \t70563.1    \n456\t68    \t70171.1    \t99.3456    \t70138.7    \t70895.7    \n457\t70    \t70164.7    \t59.543     \t70138.6    \t70435.6    \n458\t66    \t70168.4    \t71.1733    \t70138.6    \t70485.5    \n459\t85    \t70177.3    \t107.878    \t70138.5    \t70766.7    \n460\t80    \t70175.1    \t82.5823    \t70138.5    \t70527.8    \n461\t79    \t70167.9    \t73.2038    \t70138.5    \t70529.9    \n462\t65    \t70165      \t76.2297    \t70138.5    \t70595.5    \n463\t67    \t70161.8    \t69.0007    \t70138.5    \t70612.1    \n464\t78    \t70169      \t74.4983    \t70138.5    \t70612.4    \n465\t78    \t70174      \t85.96      \t70138.4    \t70622.3    \n466\t76    \t70168.1    \t73.5738    \t70138.4    \t70585.2    \n467\t78    \t70161.5    \t66.1374    \t70138.3    \t70514.1    \n468\t69    \t70174      \t101.059    \t70138.3    \t70812.8    \n469\t63    \t70164.7    \t77.2192    \t70138.3    \t70660.4    \n470\t68    \t70165.6    \t73.6991    \t70138.3    \t70543.8    \n471\t70    \t70156      \t54.896     \t70138.3    \t70527.5    \n472\t75    \t70154.9    \t53.6431    \t70138.3    \t70502.5    \n473\t76    \t70159.3    \t52.6088    \t70138.3    \t70402.6    \n474\t69    \t70162.7    \t70.681     \t70138.3    \t70543.8    \n475\t70    \t70160      \t54.3368    \t70138.2    \t70403.1    \n476\t70    \t70167.9    \t100.083    \t70138.2    \t70840      \n477\t78    \t70167.9    \t77.7815    \t70138.2    \t70560.9    \n478\t69    \t70175.3    \t113.13     \t70138.2    \t70839.7    \n479\t72    \t70154.8    \t49.6274    \t70138.2    \t70452.2    \n480\t64    \t70170.9    \t124.539    \t70138.2    \t71173.1    \n481\t58    \t70178.5    \t103.23     \t70138.2    \t70680.4    \n482\t73    \t70183.3    \t111.95     \t70138.1    \t70851.6    \n483\t67    \t70158.1    \t62.0517    \t70138.1    \t70556      \n484\t67    \t70163.4    \t78.74      \t70138.1    \t70761.8    \n485\t66    \t70167.1    \t65.9573    \t70138.1    \t70406      \n486\t68    \t70158.1    \t54.1677    \t70138.1    \t70404.1    \n487\t69    \t70159.6    \t58.593     \t70138.1    \t70473.9    \n488\t62    \t70168.6    \t84.0944    \t70138.1    \t70581.4    \n489\t66    \t70153.8    \t47.2283    \t70138.1    \t70445.5    \n490\t71    \t70162.7    \t61.4336    \t70138.1    \t70496.2    \n491\t73    \t70154.1    \t51.0064    \t70138      \t70470.5    \n492\t85    \t70179      \t104.541    \t70138.1    \t70682.7    \n493\t77    \t70163.2    \t75.2092    \t70138      \t70577.2    \n494\t65    \t70165.2    \t64.8869    \t70138      \t70472      \n495\t81    \t70174.4    \t92.7472    \t70138      \t70793.5    \n496\t76    \t70160      \t57.9795    \t70138      \t70432.5    \n497\t82    \t70159.3    \t62.8622    \t70138      \t70493.6    \n498\t64    \t70161.4    \t56.9193    \t70138      \t70410.8    \n499\t74    \t70171      \t81.091     \t70138      \t70624.7    \n500\t71    \t70147.5    \t30.5645    \t70138      \t70337.3    \n501\t69    \t70181.6    \t91.4833    \t70138      \t70510.8    \n502\t67    \t70160.9    \t69.7878    \t70137.9    \t70671.8    \n503\t73    \t70160.4    \t61.6774    \t70137.9    \t70494.3    \n504\t77    \t70167.7    \t68.7897    \t70137.9    \t70548.5    \n505\t80    \t70161.1    \t55.353     \t70137.9    \t70525.6    \n506\t73    \t70162.3    \t58.8107    \t70137.9    \t70480.7    \n507\t73    \t70153.4    \t56.174     \t70137.9    \t70527.7    \n508\t75    \t70160.7    \t65.2258    \t70137.9    \t70497.5    \n509\t67    \t70164.9    \t79.6173    \t70137.9    \t70653.9    \n510\t72    \t70155.3    \t45.985     \t70137.9    \t70380      \n511\t60    \t70159.9    \t64.4995    \t70137.9    \t70431.5    \n512\t80    \t70168.8    \t89.3191    \t70137.9    \t70726.3    \n513\t69    \t70153.1    \t52.9749    \t70137.9    \t70549.1    \n514\t76    \t70158      \t55.3327    \t70137.9    \t70421.8    \n515\t75    \t70174.8    \t81.9963    \t70137.9    \t70504.2    \n516\t72    \t70165.4    \t70.5034    \t70137.8    \t70644.9    \n517\t70    \t70162.7    \t105.336    \t70137.8    \t71070.8    \n518\t75    \t70174.2    \t123.294    \t70137.8    \t71005.2    \n519\t77    \t70175      \t90.6284    \t70137.8    \t70647.2    \n520\t71    \t70173.4    \t105.694    \t70137.8    \t70924      \n521\t66    \t70157.8    \t62.1638    \t70137.8    \t70500.7    \n522\t66    \t70173.2    \t79.6981    \t70137.8    \t70521      \n523\t70    \t70154.5    \t55.7756    \t70137.8    \t70499.8    \n524\t76    \t70173.7    \t148.339    \t70137.8    \t71499.2    \n525\t83    \t70165.5    \t71.1112    \t70137.7    \t70602      \n526\t78    \t70169.9    \t88.1529    \t70137.7    \t70624.8    \n527\t75    \t70170.1    \t111.268    \t70137.7    \t70993.8    \n528\t77    \t70163.9    \t66.0686    \t70137.7    \t70527.8    \n529\t67    \t70161      \t79.8608    \t70137.6    \t70794.6    \n530\t80    \t70162.2    \t80.2539    \t70137.6    \t70700.7    \n531\t53    \t70155.6    \t62.3289    \t70137.6    \t70522.3    \n532\t77    \t70158.8    \t54.6457    \t70137.6    \t70415      \n533\t77    \t70177.4    \t97.731     \t70137.5    \t70842.5    \n534\t69    \t70165.5    \t68.1788    \t70137.5    \t70523.1    \n535\t72    \t70172.5    \t91.5547    \t70137.5    \t70632.3    \n536\t77    \t70179.1    \t99.1261    \t70137.5    \t70807.8    \n537\t81    \t70186.3    \t118.671    \t70137.5    \t70866.8    \n538\t80    \t70177.5    \t89.9349    \t70137.5    \t70609.4    \n539\t74    \t70159.3    \t62.6763    \t70137.5    \t70544      \n540\t82    \t70174.3    \t82.0334    \t70137.4    \t70584.6    \n541\t74    \t70162.9    \t68.0124    \t70137.4    \t70606.9    \n542\t72    \t70172.3    \t104.3      \t70137.4    \t70732.6    \n543\t70    \t70162.8    \t78.7445    \t70137.4    \t70622.2    \n544\t76    \t70154.7    \t38.3628    \t70137.4    \t70322.2    \n545\t78    \t70165.5    \t68.1223    \t70137.4    \t70509.9    \n546\t70    \t70159.8    \t60.0244    \t70137.4    \t70536      \n547\t65    \t70164.8    \t89.169     \t70137.4    \t70774.7    \n548\t82    \t70158.2    \t51.5465    \t70137.4    \t70372.3    \n549\t74    \t70158.3    \t72.9944    \t70137.4    \t70716.2    \n550\t69    \t70157.2    \t61.2997    \t70137.4    \t70582.4    \n551\t76    \t70166.8    \t81.4973    \t70137.4    \t70612.1    \n552\t73    \t70190.2    \t123.798    \t70137.4    \t70859.4    \n553\t68    \t70149.4    \t41.7843    \t70137.4    \t70431.7    \n554\t83    \t70172.5    \t83.294     \t70137.4    \t70546.3    \n555\t78    \t70183.4    \t142.003    \t70137.4    \t71252.5    \n556\t68    \t70161.1    \t77.5149    \t70137.3    \t70743.2    \n557\t74    \t70170.3    \t92.5275    \t70137.3    \t70757.6    \n558\t74    \t70159.6    \t59.6096    \t70137.3    \t70494.6    \n559\t76    \t70157.2    \t49.9222    \t70137.3    \t70396.8    \n560\t76    \t70159.3    \t81.1824    \t70137.3    \t70747      \n561\t70    \t70149.4    \t45.9094    \t70137.3    \t70455.6    \n562\t71    \t70172.9    \t84.6141    \t70137.3    \t70615.7    \n563\t66    \t70181.4    \t163.188    \t70137.3    \t71586.9    \n564\t67    \t70160.3    \t72.9573    \t70137.2    \t70619.9    \n565\t77    \t70178.9    \t102.906    \t70137.2    \t70704.7    \n566\t76    \t70160.4    \t66.0117    \t70137.2    \t70534.3    \n567\t74    \t70166.1    \t85.5509    \t70137.2    \t70746.7    \n568\t69    \t70172.3    \t85.5886    \t70137.2    \t70706.7    \n569\t75    \t70154.2    \t56.3759    \t70137.2    \t70474.2    \n570\t79    \t70176.1    \t101.626    \t70137.2    \t70618.7    \n571\t75    \t70170.9    \t81.4996    \t70137.2    \t70621.2    \n572\t66    \t70157.6    \t61.2941    \t70137.2    \t70416.1    \n573\t61    \t70153.7    \t53.1772    \t70137.2    \t70439.9    \n574\t73    \t70166.1    \t69.5667    \t70137.1    \t70553.4    \n575\t74    \t70165.4    \t94.298     \t70137.1    \t70805      \n576\t70    \t70172.7    \t121.495    \t70137.1    \t71169.1    \n577\t77    \t70157.4    \t60.8174    \t70137.1    \t70449.5    \n578\t72    \t70179.5    \t90.7561    \t70137.1    \t70581.2    \n579\t70    \t70155.6    \t64.2027    \t70137.1    \t70660.7    \n580\t63    \t70190.3    \t126.599    \t70137.1    \t70823.8    \n581\t76    \t70167      \t64.8967    \t70137.1    \t70494.5    \n582\t64    \t70161.8    \t80.2849    \t70137.1    \t70656.6    \n583\t78    \t70164.7    \t72.4289    \t70137.1    \t70613.9    \n584\t74    \t70166      \t96.7491    \t70137.1    \t70977      \n585\t71    \t70167.6    \t83.6529    \t70137.1    \t70645.8    \n586\t77    \t70161.4    \t57.9884    \t70137.1    \t70470.4    \n587\t70    \t70164.3    \t77.8791    \t70137.1    \t70536.2    \n588\t70    \t70164.1    \t62.8292    \t70137.1    \t70404.5    \n589\t67    \t70152.8    \t66.3735    \t70137.1    \t70729.1    \n590\t77    \t70162.9    \t62.3333    \t70137.1    \t70469.2    \n591\t73    \t70170.5    \t79.7733    \t70137.1    \t70573.3    \n592\t68    \t70160.4    \t65.0277    \t70137.1    \t70497.6    \n593\t69    \t70159.6    \t65.2639    \t70137.1    \t70581.2    \n594\t67    \t70163.6    \t67.189     \t70137.1    \t70498.7    \n595\t68    \t70160      \t58.9842    \t70137.1    \t70435.6    \n596\t70    \t70153.8    \t45.5843    \t70137.1    \t70385.4    \n597\t80    \t70177.3    \t95.0123    \t70137.1    \t70702.6    \n598\t80    \t70155.6    \t43.7745    \t70137.1    \t70344      \n599\t63    \t70172.2    \t98.1005    \t70137.1    \t70604.6    \n600\t74    \t70171.2    \t76.9045    \t70137.1    \t70533.7    \n601\t67    \t70153.9    \t49.3591    \t70137.1    \t70476.2    \n602\t73    \t70164      \t72.3833    \t70137.1    \t70594      \n603\t70    \t70171.5    \t97.4033    \t70137      \t70764.2    \n604\t67    \t70168.5    \t89.2462    \t70137      \t70702.4    \n605\t76    \t70171.4    \t92.7616    \t70137      \t70689.8    \n606\t75    \t70168.5    \t72.6218    \t70137      \t70496      \n607\t71    \t70164.9    \t79.5708    \t70137      \t70587.4    \n608\t62    \t70173.7    \t128.041    \t70137      \t70953.9    \n609\t71    \t70170      \t94.2697    \t70137      \t70715.2    \n610\t66    \t70154.3    \t80.026     \t70137      \t70783.7    \n611\t78    \t70156.2    \t46.9764    \t70137      \t70366.7    \n612\t75    \t70169.5    \t92.3331    \t70137      \t70780      \n613\t66    \t70157.3    \t81.7952    \t70137      \t70768.1    \n614\t73    \t70171.1    \t78.9997    \t70137      \t70621.7    \n615\t66    \t70166.6    \t97.2714    \t70137      \t70945.8    \n616\t71    \t70173.4    \t96.8556    \t70137      \t70678.3    \n617\t67    \t70172.2    \t78.8178    \t70137      \t70531      \n618\t74    \t70170.8    \t93.8532    \t70137      \t70782.3    \n619\t73    \t70161.2    \t69.662     \t70137      \t70560.3    \n620\t70    \t70150.9    \t41.2179    \t70137      \t70416.9    \n621\t76    \t70163.9    \t71.8269    \t70137      \t70484.9    \n622\t77    \t70173.1    \t83.3165    \t70137      \t70543.3    \n623\t78    \t70161.5    \t78.9345    \t70137      \t70774.4    \n624\t72    \t70157.4    \t60.976     \t70137      \t70585      \n625\t76    \t70172.2    \t83.2434    \t70137      \t70587.8    \n626\t75    \t70169.4    \t87.5514    \t70137      \t70805      \n627\t70    \t70157      \t57.9351    \t70137      \t70426.6    \n628\t76    \t70153.9    \t47.9487    \t70137      \t70441.3    \n629\t64    \t70174.7    \t99.6321    \t70137      \t70755.3    \n630\t66    \t70166.2    \t119.641    \t70137      \t71217.9    \n631\t59    \t70160.2    \t63.9956    \t70137      \t70456.3    \n632\t84    \t70167.9    \t86.7756    \t70137      \t70674.3    \n633\t62    \t70163.7    \t82.3981    \t70137      \t70739      \n634\t61    \t70165.5    \t84.7712    \t70137      \t70648.7    \n635\t77    \t70163      \t71.856     \t70136.9    \t70635.9    \n636\t71    \t70164.7    \t86.3632    \t70136.9    \t70686.5    \n637\t75    \t70171.8    \t107.958    \t70136.9    \t70786.4    \n638\t71    \t70165.2    \t95.3845    \t70136.9    \t70941.2    \n639\t82    \t70162      \t77.3401    \t70136.9    \t70602.6    \n640\t73    \t70169.5    \t95.7018    \t70136.9    \t70869.6    \n641\t67    \t70163.9    \t72.1967    \t70136.9    \t70617.3    \n642\t67    \t70159.8    \t76.9098    \t70136.9    \t70742.3    \n643\t80    \t70174.3    \t90.3211    \t70136.9    \t70646      \n644\t75    \t70157.4    \t69.4626    \t70136.9    \t70554.7    \n645\t71    \t70169.5    \t90.1247    \t70136.9    \t70736      \n646\t70    \t70169.7    \t104.93     \t70136.9    \t70861.5    \n647\t76    \t70172.7    \t92.9982    \t70136.9    \t70698.5    \n648\t74    \t70153.5    \t42.3523    \t70136.9    \t70332.5    \n649\t67    \t70157.6    \t63.0184    \t70136.9    \t70583.2    \n650\t79    \t70170.2    \t98.5144    \t70136.9    \t70795      \n651\t72    \t70170.7    \t80.6287    \t70136.9    \t70594.6    \n652\t67    \t70160.6    \t71.7557    \t70136.9    \t70668.3    \n653\t69    \t70156.8    \t52.5452    \t70136.9    \t70435.3    \n654\t70    \t70156.8    \t55.6613    \t70136.9    \t70465.7    \n655\t79    \t70183.1    \t113.046    \t70136.9    \t70701.7    \n656\t81    \t70165.7    \t64.4007    \t70136.9    \t70406.5    \n657\t78    \t70178.6    \t116.684    \t70136.9    \t71048.3    \n658\t73    \t70157.4    \t66.3146    \t70136.9    \t70568.1    \n659\t71    \t70187.3    \t122.195    \t70136.8    \t71051.1    \n660\t71    \t70163.3    \t85.1603    \t70136.8    \t70747      \n661\t72    \t70168.7    \t108.262    \t70136.8    \t70902.5    \n662\t71    \t70159.6    \t65.2315    \t70136.8    \t70543.7    \n663\t74    \t70165.4    \t77.5646    \t70136.8    \t70536.8    \n664\t76    \t70163.2    \t78.2632    \t70136.8    \t70551.5    \n665\t73    \t70191.4    \t127.288    \t70136.8    \t70797.3    \n666\t70    \t70174.6    \t97.9403    \t70136.8    \t70688      \n667\t74    \t70159.9    \t70.4017    \t70136.7    \t70698.4    \n668\t78    \t70160.4    \t62.5995    \t70136.7    \t70463.2    \n669\t72    \t70168.5    \t89.5142    \t70136.7    \t70644.8    \n670\t73    \t70170.1    \t75.6184    \t70136.7    \t70495.6    \n671\t85    \t70178.3    \t111.323    \t70136.7    \t70918.5    \n672\t75    \t70165      \t76.8132    \t70136.7    \t70612.7    \n673\t71    \t70155.9    \t55.7982    \t70136.7    \t70448.6    \n674\t69    \t70163.6    \t97.2091    \t70136.7    \t70970.7    \n675\t63    \t70166      \t90.2744    \t70136.7    \t70646      \n676\t72    \t70157.4    \t51.5447    \t70136.7    \t70408      \n677\t71    \t70152.9    \t43.4944    \t70136.7    \t70356.1    \n678\t72    \t70159.3    \t61.1652    \t70136.7    \t70475.2    \n679\t76    \t70182.9    \t109.385    \t70136.7    \t70658.4    \n680\t74    \t70160.1    \t56.9964    \t70136.7    \t70440.9    \n681\t76    \t70185.6    \t100.239    \t70136.7    \t70533.9    \n682\t72    \t70164.3    \t69.3518    \t70136.6    \t70532.7    \n683\t65    \t70156.3    \t76.6309    \t70136.6    \t70783.9    \n684\t64    \t70149.1    \t42.6181    \t70136.6    \t70469.4    \n685\t77    \t70157.6    \t67.4755    \t70136.6    \t70544.7    \n686\t74    \t70183.5    \t140.68     \t70136.6    \t71071.4    \n687\t75    \t70170.9    \t95.6097    \t70136.6    \t70811.5    \n688\t80    \t70165.8    \t112.034    \t70136.6    \t70898.5    \n689\t62    \t70163.3    \t83.5683    \t70136.6    \t70708.1    \n690\t78    \t70163.2    \t72.7427    \t70136.6    \t70580      \n691\t66    \t70157.6    \t62.9074    \t70136.6    \t70579.4    \n692\t70    \t70155.6    \t62.7523    \t70136.6    \t70598.9    \n693\t69    \t70158.6    \t64.298     \t70136.6    \t70509.3    \n694\t82    \t70181      \t113.585    \t70136.6    \t70924      \n695\t77    \t70167.3    \t78.6337    \t70136.5    \t70589.9    \n696\t65    \t70182.4    \t122.777    \t70136.5    \t70962.1    \n697\t73    \t70174.5    \t94.5763    \t70136.5    \t70808.9    \n698\t73    \t70157.2    \t71.1066    \t70136.5    \t70687.3    \n699\t76    \t70158.8    \t56.6713    \t70136.5    \t70497.9    \n700\t69    \t70165.3    \t71.9741    \t70136.5    \t70593.9    \nInitial Control Points: [[ 31.08594556  97.07734616]\n [151.35331041 128.65688751]\n [104.42517432 119.65593613]\n [225.76573489 138.73866387]]\n</pre> In\u00a0[7]: Copied! <pre>initial_fitted_curve_points, initial_t_values = generate_curve_within_boundaries(initial_control_points, image.shape, 0.01)\n\nplt.figure(figsize=(10, 5))\n\nplt.subplot(1, 3, 1)\nplt.plot(data_points[:, 0], data_points[:, 1], 'b.')\nplt.title('Data Points')\nplt.imshow(image, cmap='gray', alpha=0, origin='lower')\n\n\nplt.subplot(1, 3, 2)\nplt.plot(data_points[:, 0], data_points[:, 1], 'b.')\nplt.plot(initial_fitted_curve_points[:, 0], initial_fitted_curve_points[:, 1], 'r-')\nplt.plot(initial_control_points[:, 0], initial_control_points[:, 1], 'g.')\nplt.title('Initial Fitted Curve')\nplt.imshow(image, cmap='gray', alpha=0, origin='lower')\n\n\nplt.subplot(1, 3, 3)\nplt.imshow(image, cmap='gray', origin='lower')\nplt.plot(initial_fitted_curve_points[:, 0], initial_fitted_curve_points[:, 1], 'r-')\nplt.plot(initial_control_points[:, 0], initial_control_points[:, 1], 'g.')\nplt.title('Initial Fitted Curve on Image')\nplt.axis('off')\n\nplt.tight_layout()\nplt.show()\n</pre> initial_fitted_curve_points, initial_t_values = generate_curve_within_boundaries(initial_control_points, image.shape, 0.01)  plt.figure(figsize=(10, 5))  plt.subplot(1, 3, 1) plt.plot(data_points[:, 0], data_points[:, 1], 'b.') plt.title('Data Points') plt.imshow(image, cmap='gray', alpha=0, origin='lower')   plt.subplot(1, 3, 2) plt.plot(data_points[:, 0], data_points[:, 1], 'b.') plt.plot(initial_fitted_curve_points[:, 0], initial_fitted_curve_points[:, 1], 'r-') plt.plot(initial_control_points[:, 0], initial_control_points[:, 1], 'g.') plt.title('Initial Fitted Curve') plt.imshow(image, cmap='gray', alpha=0, origin='lower')   plt.subplot(1, 3, 3) plt.imshow(image, cmap='gray', origin='lower') plt.plot(initial_fitted_curve_points[:, 0], initial_fitted_curve_points[:, 1], 'r-') plt.plot(initial_control_points[:, 0], initial_control_points[:, 1], 'g.') plt.title('Initial Fitted Curve on Image') plt.axis('off')  plt.tight_layout() plt.show() In\u00a0[8]: Copied! <pre>pixel_size = 2.170\npenalty_threshold = 0.05\ndither_range = 70\niterations = 700\n</pre> pixel_size = 2.170 penalty_threshold = 0.05 dither_range = 70 iterations = 700 In\u00a0[9]: Copied! <pre>ga_refine = GA_Refine(image, pixel_size=pixel_size, penalty_threshold=penalty_threshold, dithering_range=dither_range, iterations=iterations)\nrefined_control_points = ga_refine(initial_control_points, image)\nrefined_control_points = np.array(refined_control_points)\nprint(f'Control points: {refined_control_points}')\n</pre> ga_refine = GA_Refine(image, pixel_size=pixel_size, penalty_threshold=penalty_threshold, dithering_range=dither_range, iterations=iterations) refined_control_points = ga_refine(initial_control_points, image) refined_control_points = np.array(refined_control_points) print(f'Control points: {refined_control_points}') <pre>/Users/zhenhuang/opt/anaconda3/envs/cryoem/lib/python3.9/site-packages/deap/creator.py:185: RuntimeWarning: A class named 'Individual' has already been created and it will be overwritten. Consider deleting previous creation of that class or rename it.\n  warnings.warn(\"A class named '{0}' has already been created and it \"\n</pre> <pre>gen\tnevals\tavg         \tstd        \tmin         \tmax    \n0  \t31    \t-2.19361e+11\t6.37697e+11\t-3.19596e+12\t2268.36\n1  \t20    \t1807.92     \t553.378    \t666.08      \t2268.36\n2  \t26    \t2253.73     \t21.2737    \t2196.9      \t2285.43\n3  \t26    \t2271.17     \t14.0597    \t2230.47     \t2303.17\n4  \t22    \t2286.59     \t21.6743    \t2227.5      \t2327.79\n5  \t26    \t2311.58     \t17.6472    \t2247.04     \t2330.3 \n6  \t22    \t2326.56     \t2.99077    \t2316.32     \t2330.36\n7  \t28    \t2328.49     \t2.05926    \t2321.55     \t2331.87\n8  \t28    \t2330.2      \t2.04154    \t2322.19     \t2333.5 \n9  \t26    \t2330.65     \t2.82643    \t2320.42     \t2333.5 \n10 \t21    \t2332.66     \t1.96151    \t2327.78     \t2339.26\n11 \t22    \t2334.27     \t2.51638    \t2326.51     \t2340.58\n12 \t23    \t2336.4      \t3.57707    \t2326.09     \t2340.58\n13 \t24    \t2338.03     \t3.76101    \t2325.24     \t2341.43\n14 \t22    \t2339.96     \t2.04535    \t2331.77     \t2341.43\n15 \t22    \t2340.57     \t1.30779    \t2336.45     \t2341.62\n16 \t25    \t2340.98     \t1.22573    \t2336.78     \t2342.17\n17 \t24    \t2341.68     \t0.236803   \t2341.17     \t2342.17\n18 \t25    \t2341.51     \t0.918996   \t2338.22     \t2342.17\n19 \t22    \t2341.83     \t0.807699   \t2337.95     \t2342.17\n20 \t20    \t2341.86     \t1.07593    \t2336.86     \t2342.51\n21 \t19    \t2341.96     \t0.834305   \t2338.39     \t2342.54\n22 \t20    \t2342.18     \t0.65352    \t2339.58     \t2342.54\n23 \t23    \t2342.35     \t0.682342   \t2338.68     \t2342.56\n24 \t27    \t2342.02     \t1.54013    \t2334.68     \t2342.59\n25 \t22    \t2341.33     \t3.57911    \t2324.25     \t2342.68\n26 \t23    \t2341.4      \t2.44796    \t2334.03     \t2342.86\n27 \t26    \t2342.25     \t1.30374    \t2335.86     \t2342.96\n28 \t24    \t2341.7      \t3.08845    \t2327.03     \t2343.05\n29 \t24    \t2342.2      \t1.93555    \t2332.4      \t2343.5 \n30 \t23    \t2342.49     \t1.33994    \t2336.91     \t2343.5 \n31 \t25    \t2342.52     \t2.12565    \t2333.02     \t2343.67\n32 \t22    \t2342.51     \t2.44694    \t2331.66     \t2343.91\n33 \t26    \t2342.97     \t1.39644    \t2338.92     \t2344.23\n34 \t23    \t2343.72     \t0.570253   \t2341.75     \t2344.51\n35 \t23    \t2344.05     \t0.467681   \t2342.75     \t2344.75\n36 \t21    \t2342.88     \t4.17304    \t2324.21     \t2344.75\n37 \t23    \t2344.13     \t1.15838    \t2339.8      \t2344.75\n38 \t23    \t2344.17     \t1.3303     \t2338.75     \t2344.77\n39 \t24    \t2344.16     \t1.91597    \t2335.47     \t2344.77\n40 \t24    \t2344.05     \t2.61882    \t2330.3      \t2344.8 \n41 \t23    \t2344.01     \t2.20027    \t2334        \t2344.86\n42 \t25    \t2344.12     \t1.56191    \t2337.61     \t2344.86\n43 \t21    \t2344.38     \t1.28652    \t2337.92     \t2344.92\n44 \t23    \t2344.34     \t1.26586    \t2339.02     \t2345.24\n45 \t26    \t2344.48     \t1.19441    \t2338.64     \t2345.32\n46 \t22    \t2344.58     \t1.07059    \t2341.51     \t2345.32\n47 \t20    \t2344.27     \t2.71701    \t2335.23     \t2345.32\n48 \t24    \t2344.37     \t2.74581    \t2332.03     \t2345.37\n49 \t22    \t2344.98     \t1.22507    \t2338.48     \t2345.39\n50 \t25    \t2344.21     \t3.20105    \t2328.02     \t2345.46\n51 \t24    \t2344.62     \t1.30323    \t2341.61     \t2345.46\n52 \t24    \t2345.11     \t0.740261   \t2342.37     \t2345.49\n53 \t20    \t2344.78     \t1.37462    \t2339.73     \t2345.71\n54 \t24    \t2345.21     \t0.693663   \t2342.41     \t2345.71\n55 \t21    \t2345.27     \t0.823774   \t2342.66     \t2345.71\n56 \t21    \t2345.25     \t0.976412   \t2342.31     \t2345.78\n57 \t26    \t2345.14     \t1.66991    \t2337.19     \t2345.78\n58 \t20    \t2345.54     \t0.869234   \t2340.89     \t2345.94\n59 \t21    \t2345.09     \t1.78127    \t2338.27     \t2346.16\n60 \t25    \t2344.43     \t6.36313    \t2309.98     \t2346.16\n61 \t27    \t2345.62     \t1.01332    \t2341.41     \t2346.16\n62 \t23    \t2345.83     \t0.646896   \t2343.29     \t2346.26\n63 \t17    \t2345.62     \t1.82049    \t2337.85     \t2346.26\n64 \t23    \t2345.78     \t1.5271     \t2337.66     \t2346.37\n65 \t18    \t2346        \t0.653186   \t2343.7      \t2346.37\n66 \t27    \t2344.82     \t2.37379    \t2337.34     \t2346.49\n67 \t27    \t2346.08     \t1.03714    \t2340.64     \t2346.61\n68 \t24    \t2345.85     \t1.72215    \t2337.28     \t2346.64\n69 \t24    \t2346.05     \t1.88719    \t2336.15     \t2346.87\n70 \t23    \t2346.34     \t0.84763    \t2343.59     \t2346.87\n71 \t25    \t2346.56     \t0.729116   \t2343.66     \t2346.9 \n72 \t24    \t2346.53     \t0.914584   \t2342.32     \t2346.9 \n73 \t24    \t2346.74     \t0.58324    \t2343.77     \t2347.02\n74 \t22    \t2346.67     \t0.637278   \t2344.03     \t2347.02\n75 \t28    \t2346.82     \t0.367388   \t2345.07     \t2347.08\n76 \t22    \t2346.7      \t0.618555   \t2344.71     \t2347.16\n77 \t27    \t2346.09     \t2.04481    \t2338.89     \t2347.33\n78 \t23    \t2346.41     \t1.58224    \t2340.61     \t2347.4 \n79 \t25    \t2346.18     \t2.48222    \t2336.92     \t2347.41\n80 \t24    \t2346.79     \t0.924359   \t2344.19     \t2347.46\n81 \t25    \t2346.84     \t1.72536    \t2339.43     \t2347.43\n82 \t23    \t2346.67     \t1.4363     \t2342.07     \t2347.46\n83 \t27    \t2347.1      \t1.09479    \t2341.91     \t2347.69\n84 \t24    \t2346.48     \t1.85259    \t2341.53     \t2347.69\n85 \t23    \t2347.45     \t0.425707   \t2345.74     \t2348.24\n86 \t22    \t2346.95     \t2.07363    \t2340.03     \t2348.77\n87 \t24    \t2347.81     \t0.578239   \t2346.09     \t2348.77\n88 \t21    \t2348.19     \t0.600388   \t2345.76     \t2348.9 \n89 \t23    \t2348.31     \t0.978953   \t2344.18     \t2348.9 \n90 \t24    \t2348.02     \t1.73059    \t2341.03     \t2348.96\n91 \t27    \t2348.29     \t2.08712    \t2337.08     \t2348.98\n92 \t23    \t2348.42     \t1.99271    \t2337.72     \t2349.14\n93 \t23    \t2348.4      \t1.52927    \t2342.27     \t2349.27\n94 \t18    \t2348.54     \t1.62455    \t2340.38     \t2349.2 \n95 \t19    \t2348.71     \t0.899674   \t2345.04     \t2349.26\n96 \t25    \t2348.91     \t0.909627   \t2345.14     \t2349.44\n97 \t26    \t2348.94     \t0.90263    \t2345.23     \t2349.6 \n98 \t18    \t2349.34     \t0.288851   \t2348.31     \t2349.6 \n99 \t28    \t2348.85     \t1.85424    \t2339.98     \t2349.6 \n100\t25    \t2349.16     \t1.39092    \t2342.1      \t2349.75\n101\t21    \t2349.35     \t0.723362   \t2346.51     \t2349.81\n102\t25    \t2349.29     \t1.23939    \t2344.58     \t2349.83\n103\t24    \t2349.11     \t2.03808    \t2339.94     \t2349.96\n104\t20    \t2349.53     \t0.696406   \t2347.26     \t2350.01\n105\t21    \t2349.31     \t1.94314    \t2340.48     \t2350.09\n106\t23    \t2349.6      \t1.38158    \t2342.56     \t2350.34\n107\t24    \t2348.69     \t5.42149    \t2322.31     \t2350.35\n108\t29    \t2349.4      \t1.69555    \t2344.02     \t2350.44\n109\t23    \t2349        \t3.16637    \t2338.03     \t2350.67\n110\t20    \t2349.61     \t3.29694    \t2332.42     \t2350.67\n111\t23    \t2349.71     \t2.15072    \t2339.53     \t2350.73\n112\t27    \t2350.24     \t1.22348    \t2344.25     \t2350.8 \n113\t23    \t2350.3      \t1.01242    \t2347.23     \t2350.95\n114\t23    \t2350.45     \t1.14609    \t2345.44     \t2350.95\n115\t24    \t2350.08     \t1.92183    \t2342.32     \t2350.99\n116\t25    \t2349.97     \t2.58454    \t2340.64     \t2351.17\n117\t22    \t2350.47     \t1.51112    \t2343.29     \t2351.17\n118\t23    \t2350.42     \t1.93679    \t2340.15     \t2351.14\n119\t18    \t2350.95     \t0.402603   \t2349.05     \t2351.14\n120\t28    \t2350.73     \t0.977932   \t2346.99     \t2351.27\n121\t22    \t2350.11     \t3.0736     \t2336.08     \t2351.27\n122\t19    \t2350.75     \t0.826592   \t2348.33     \t2351.29\n123\t27    \t2350.37     \t1.70712    \t2343.86     \t2351.35\n124\t26    \t2350.12     \t3.79407    \t2330.1      \t2351.38\n125\t21    \t2350.9      \t1.42446    \t2343.65     \t2351.38\n126\t23    \t2351.01     \t0.883519   \t2347.71     \t2351.38\n127\t26    \t2350.97     \t0.913061   \t2347.12     \t2351.43\n128\t21    \t2350.57     \t1.93939    \t2341.92     \t2351.47\n129\t25    \t2350.61     \t1.32524    \t2346.13     \t2351.47\n130\t19    \t2351.22     \t0.550225   \t2349.14     \t2351.5 \n131\t22    \t2351.08     \t1.72998    \t2341.71     \t2351.54\n132\t21    \t2350.62     \t1.80806    \t2342.93     \t2351.65\n133\t25    \t2350.11     \t4.81842    \t2327.29     \t2351.67\n134\t22    \t2351.15     \t0.938377   \t2347.13     \t2351.67\n135\t24    \t2351.05     \t1.65222    \t2343.79     \t2351.79\n136\t19    \t2351.09     \t1.59101    \t2343.92     \t2351.83\n137\t24    \t2351.04     \t1.77843    \t2343.32     \t2352.26\n138\t22    \t2351.64     \t0.522271   \t2349.49     \t2352.29\n139\t27    \t2350.73     \t4.5204     \t2326.87     \t2352.29\n140\t27    \t2351.33     \t2.75636    \t2337.12     \t2352.42\n141\t26    \t2351.84     \t1.22212    \t2345.6      \t2352.3 \n142\t22    \t2351.66     \t1.14215    \t2347.49     \t2352.3 \n143\t23    \t2351.49     \t1.92837    \t2343.13     \t2352.4 \n144\t23    \t2352.03     \t0.743291   \t2348.49     \t2352.4 \n145\t22    \t2351.09     \t4.70626    \t2326.08     \t2352.4 \n146\t21    \t2352.32     \t0.336056   \t2350.49     \t2352.48\n147\t24    \t2351.95     \t1.83798    \t2342.48     \t2352.49\n148\t26    \t2351.9      \t1.3392     \t2346.14     \t2352.5 \n149\t21    \t2352.07     \t1.54985    \t2343.85     \t2352.52\n150\t19    \t2351.77     \t1.84518    \t2342.98     \t2352.76\n151\t27    \t2351.39     \t3.85921    \t2335.2      \t2352.54\n152\t21    \t2352.35     \t0.474929   \t2350.26     \t2352.56\n153\t21    \t2352.27     \t0.879779   \t2347.7      \t2352.56\n154\t20    \t2352.41     \t0.458361   \t2350.21     \t2352.65\n155\t22    \t2351.95     \t1.45031    \t2346.91     \t2352.65\n156\t18    \t2352.19     \t1.60552    \t2343.77     \t2352.7 \n157\t28    \t2351.9      \t1.70374    \t2346.38     \t2352.73\n158\t26    \t2352.42     \t0.941341   \t2348.29     \t2352.98\n159\t18    \t2352.04     \t2.34972    \t2340.14     \t2352.98\n160\t26    \t2352.38     \t1.73602    \t2343.34     \t2353.36\n161\t23    \t2352.08     \t2.85988    \t2341.72     \t2353.36\n162\t24    \t2351.99     \t2.95927    \t2342.18     \t2353.36\n163\t24    \t2352        \t3.449      \t2336.36     \t2353.44\n164\t26    \t2352.59     \t2.03448    \t2342.8      \t2353.43\n165\t23    \t2352.92     \t1.47636    \t2346.18     \t2353.51\n166\t24    \t2353.12     \t0.792561   \t2350.17     \t2353.56\n167\t24    \t2352.77     \t2.29677    \t2341.53     \t2353.56\n168\t23    \t2353.4      \t0.324405   \t2351.8      \t2353.59\n169\t24    \t2353.05     \t1.37975    \t2346.75     \t2353.91\n170\t28    \t2352.53     \t2.33472    \t2343.46     \t2353.92\n171\t27    \t2353.2      \t1.29429    \t2348.35     \t2353.92\n172\t19    \t2353.06     \t2.02003    \t2344.43     \t2353.92\n173\t23    \t2353.1      \t1.72035    \t2347.23     \t2354.02\n174\t23    \t2353.75     \t0.587538   \t2350.84     \t2354.02\n175\t19    \t2352.57     \t3.69566    \t2336.5      \t2354.02\n176\t18    \t2353.85     \t0.387261   \t2352.26     \t2354.03\n177\t23    \t2353.52     \t2.00383    \t2342.7      \t2354.03\n178\t25    \t2352.55     \t5.84633    \t2321.56     \t2354.21\n179\t18    \t2353.88     \t0.533175   \t2351.67     \t2354.21\n180\t25    \t2353.72     \t0.737473   \t2350.74     \t2354.3 \n181\t25    \t2353.09     \t2.19061    \t2343.12     \t2354.3 \n182\t21    \t2353.96     \t0.8613     \t2350.6      \t2354.3 \n183\t18    \t2353.78     \t0.979832   \t2350.64     \t2354.34\n184\t23    \t2353.8      \t1.67971    \t2345.34     \t2354.35\n185\t28    \t2353.62     \t1.84441    \t2344.07     \t2354.59\n186\t28    \t2353.29     \t3.38665    \t2335.4      \t2354.59\n187\t25    \t2354.19     \t0.769999   \t2350.23     \t2354.59\n188\t28    \t2353.71     \t3.37142    \t2335.58     \t2354.7 \n189\t18    \t2354.13     \t1.29605    \t2347.7      \t2354.75\n190\t27    \t2354.01     \t1.91619    \t2346.27     \t2354.77\n191\t27    \t2354.34     \t0.898417   \t2350.55     \t2354.79\n192\t20    \t2353.57     \t3.34831    \t2341.01     \t2354.81\n193\t22    \t2353.44     \t4.28453    \t2336.85     \t2354.97\n194\t19    \t2354.69     \t0.448941   \t2352.42     \t2354.97\n195\t25    \t2354.08     \t2.29195    \t2346.77     \t2355.31\n196\t20    \t2354.58     \t1.58677    \t2346.21     \t2355.31\n197\t21    \t2354.92     \t0.629982   \t2351.77     \t2355.6 \n198\t22    \t2355.16     \t0.754817   \t2351.27     \t2355.6 \n199\t23    \t2354.47     \t2.35243    \t2343.38     \t2355.96\n200\t24    \t2354.64     \t2.009      \t2346.23     \t2356.14\n201\t16    \t2355.81     \t0.350557   \t2354.2      \t2356.14\n202\t23    \t2355.65     \t0.932627   \t2352.84     \t2356.14\n203\t27    \t2355.08     \t2.2461     \t2345.18     \t2356.29\n204\t22    \t2355.67     \t0.858154   \t2353.43     \t2356.29\n205\t23    \t2355.92     \t0.6859     \t2353.82     \t2356.29\n206\t23    \t2355.79     \t1.63804    \t2347.31     \t2356.47\n207\t17    \t2356.09     \t0.897211   \t2351.63     \t2356.47\n208\t22    \t2356.32     \t0.324151   \t2354.77     \t2356.51\n209\t23    \t2356.38     \t0.388148   \t2354.63     \t2356.61\n210\t23    \t2356.17     \t1.3004     \t2349.62     \t2356.61\n211\t21    \t2355.9      \t2.84562    \t2340.55     \t2356.63\n212\t23    \t2355.8      \t3.17191    \t2338.79     \t2356.63\n213\t22    \t2356.22     \t1.10633    \t2351.32     \t2356.63\n214\t21    \t2356.27     \t0.867002   \t2353.3      \t2356.8 \n215\t25    \t2356.39     \t0.913014   \t2352.2      \t2357.05\n216\t21    \t2356.44     \t0.771046   \t2353.77     \t2357.22\n217\t27    \t2356.03     \t2.1043     \t2345.81     \t2357.09\n218\t28    \t2356.61     \t0.946014   \t2352.06     \t2357.09\n219\t23    \t2356.54     \t0.947815   \t2354        \t2357.24\n220\t22    \t2356.44     \t1.26678    \t2352.75     \t2357.24\n221\t25    \t2356.8      \t0.956379   \t2351.97     \t2357.31\n222\t26    \t2356.47     \t1.80673    \t2348.86     \t2357.36\n223\t20    \t2356.96     \t0.958404   \t2352.72     \t2357.74\n224\t27    \t2357.04     \t1.56964    \t2348.55     \t2357.74\n225\t24    \t2357.17     \t0.854546   \t2353.46     \t2357.91\n226\t24    \t2356.29     \t5.25253    \t2328.4      \t2357.97\n227\t19    \t2356.68     \t3.33593    \t2340.97     \t2358.04\n228\t20    \t2357.18     \t2.21888    \t2345.73     \t2358.06\n229\t23    \t2357.05     \t2.67136    \t2345.09     \t2358.06\n230\t25    \t2357.01     \t2.96339    \t2342.24     \t2358.29\n231\t24    \t2357.75     \t1.69786    \t2348.92     \t2358.57\n232\t19    \t2358.07     \t0.737747   \t2354.91     \t2358.57\n233\t23    \t2358.27     \t0.588425   \t2356.03     \t2358.6 \n234\t23    \t2358.25     \t0.725806   \t2355.88     \t2358.98\n235\t18    \t2358.01     \t2.05874    \t2348.56     \t2358.98\n236\t22    \t2358.32     \t0.870523   \t2354.63     \t2359.01\n237\t27    \t2358.27     \t1.48802    \t2351.29     \t2359.11\n238\t23    \t2358.58     \t1.47135    \t2351.08     \t2359.15\n239\t24    \t2357.16     \t3.96455    \t2345.86     \t2359.21\n240\t25    \t2358.97     \t0.666878   \t2355.52     \t2359.43\n241\t26    \t2358.65     \t1.63274    \t2351.16     \t2359.43\n242\t22    \t2359.05     \t0.535297   \t2356.34     \t2359.28\n243\t22    \t2358.64     \t1.93264    \t2349.8      \t2359.76\n244\t22    \t2358.75     \t1.58771    \t2352.46     \t2359.78\n245\t21    \t2358.66     \t2.38393    \t2346.99     \t2359.78\n246\t17    \t2359.31     \t1.16683    \t2354.19     \t2359.84\n247\t26    \t2358.75     \t2.33518    \t2350.04     \t2359.84\n248\t23    \t2359.02     \t3.81047    \t2338.2      \t2359.84\n249\t23    \t2359.69     \t0.428475   \t2358.04     \t2360.05\n250\t27    \t2357.93     \t3.46758    \t2347.87     \t2360.05\n251\t25    \t2359.33     \t1.65877    \t2352.6      \t2360.05\n252\t22    \t2359.59     \t0.803414   \t2355.79     \t2360.14\n253\t23    \t2359.07     \t3.90766    \t2338.17     \t2360.44\n254\t20    \t2358.62     \t4.25333    \t2339.02     \t2360.44\n255\t26    \t2359.43     \t1.29274    \t2354.92     \t2360.55\n256\t25    \t2359.69     \t2.01309    \t2351.32     \t2361.3 \n257\t27    \t2360.02     \t1.87631    \t2351.88     \t2361.67\n258\t22    \t2360.86     \t0.679494   \t2358.56     \t2361.67\n259\t20    \t2360.49     \t4.04474    \t2338.69     \t2361.84\n260\t24    \t2360.82     \t2.34551    \t2350.2      \t2361.84\n261\t22    \t2361.51     \t0.731675   \t2357.83     \t2361.98\n262\t24    \t2361.26     \t2.06404    \t2350.53     \t2361.99\n263\t22    \t2361.73     \t0.600404   \t2358.68     \t2361.99\n264\t27    \t2360.15     \t5.26231    \t2334.64     \t2362.03\n265\t19    \t2361.6      \t1.41355    \t2356.01     \t2362.04\n266\t25    \t2361.37     \t1.75791    \t2354.2      \t2362.04\n267\t21    \t2361.71     \t0.801087   \t2358.08     \t2362.05\n268\t24    \t2361.05     \t2.96139    \t2347.44     \t2362.73\n269\t27    \t2361.15     \t2.9927     \t2346.17     \t2362.73\n270\t20    \t2362.11     \t0.57206    \t2359.7      \t2362.73\n271\t27    \t2361.69     \t2.56143    \t2351.63     \t2362.89\n272\t23    \t2360.54     \t9.34858    \t2309.7      \t2362.89\n273\t24    \t2362.2      \t1.49778    \t2355.53     \t2363.06\n274\t22    \t2362.62     \t0.97312    \t2357.68     \t2363.29\n275\t23    \t2362.61     \t0.998282   \t2357.88     \t2363.29\n276\t25    \t2362.88     \t0.815393   \t2359.68     \t2363.68\n277\t21    \t2362.45     \t2.57794    \t2349.79     \t2363.68\n278\t24    \t2362.37     \t2.52927    \t2352.71     \t2363.73\n279\t24    \t2363.25     \t0.880535   \t2359.73     \t2363.73\n280\t21    \t2362.8      \t2.29814    \t2354.31     \t2363.73\n281\t21    \t2363.31     \t1.15327    \t2358.45     \t2364.09\n282\t24    \t2363.22     \t2.14342    \t2352.24     \t2364.09\n283\t28    \t2362.51     \t2.47248    \t2353.96     \t2364.1 \n284\t25    \t2363.12     \t2.83356    \t2348.8      \t2364.26\n285\t30    \t2362.88     \t2.85983    \t2351.74     \t2364.33\n286\t21    \t2363.98     \t0.630375   \t2361.64     \t2364.9 \n287\t26    \t2364.23     \t0.750658   \t2360.71     \t2365.2 \n288\t27    \t2363.95     \t1.7869     \t2357.1      \t2365.22\n289\t26    \t2364.49     \t1.49869    \t2358.08     \t2365.43\n290\t27    \t2364.04     \t2.87363    \t2351.65     \t2365.62\n291\t25    \t2364.9      \t1.24408    \t2359.02     \t2365.76\n292\t23    \t2365.27     \t0.633756   \t2363.18     \t2365.76\n293\t17    \t2365.13     \t1.67937    \t2356.51     \t2365.76\n294\t25    \t2365.1      \t1.36068    \t2358.41     \t2365.76\n295\t25    \t2364.83     \t2.92276    \t2350.12     \t2365.83\n296\t19    \t2364.68     \t3.87238    \t2344.22     \t2365.83\n297\t24    \t2364.43     \t5.09476    \t2341.65     \t2366   \n298\t22    \t2365.51     \t0.923915   \t2361.62     \t2366   \n299\t25    \t2365.39     \t2.51882    \t2351.63     \t2366.04\n300\t29    \t2365.32     \t2.19857    \t2355.92     \t2366.3 \n301\t23    \t2365.72     \t0.767842   \t2363.02     \t2366.31\n302\t28    \t2364.91     \t4.65057    \t2340.23     \t2366.46\n303\t29    \t2365.45     \t2.68121    \t2354.91     \t2367.37\n304\t27    \t2365.67     \t2.50324    \t2356.48     \t2367.44\n305\t20    \t2366.58     \t1.33849    \t2361.64     \t2367.72\n306\t27    \t2366.52     \t2.08566    \t2358.34     \t2367.73\n307\t26    \t2366.77     \t1.7302     \t2360.36     \t2367.84\n308\t27    \t2367.33     \t0.777778   \t2363.95     \t2367.99\n309\t22    \t2367.39     \t1.54601    \t2359.7      \t2368.8 \n310\t23    \t2367.29     \t2.73863    \t2353.34     \t2368.8 \n311\t22    \t2367.59     \t2.55826    \t2355.71     \t2368.81\n312\t24    \t2367.53     \t3.87914    \t2347.26     \t2368.9 \n313\t22    \t2368.3      \t1.32131    \t2363.07     \t2368.9 \n314\t23    \t2368.28     \t1.50034    \t2360.83     \t2368.96\n315\t20    \t2368.46     \t1.09434    \t2363.99     \t2368.97\n316\t24    \t2367.9      \t3.87969    \t2347.75     \t2369.07\n317\t23    \t2368.44     \t1.67129    \t2360.31     \t2369.11\n318\t23    \t2368.98     \t0.325      \t2367.72     \t2369.28\n319\t26    \t2368.72     \t1.04081    \t2364.37     \t2369.35\n320\t24    \t2368.73     \t1.14218    \t2363.72     \t2369.35\n321\t27    \t2367.43     \t5.13636    \t2342.14     \t2369.56\n322\t19    \t2369.16     \t0.73377    \t2365.61     \t2369.69\n323\t22    \t2367.95     \t4.7256     \t2346.17     \t2369.69\n324\t24    \t2368.43     \t2.46984    \t2358.87     \t2369.72\n325\t24    \t2369.17     \t1.65834    \t2360.28     \t2369.72\n326\t25    \t2369.41     \t0.658804   \t2367.32     \t2369.72\n327\t27    \t2368.9      \t1.94107    \t2361.36     \t2370.15\n328\t26    \t2368.73     \t2.32529    \t2359.35     \t2370.15\n329\t25    \t2369.42     \t1.56773    \t2361.2      \t2370.15\n330\t23    \t2369.36     \t1.62707    \t2361.83     \t2370.15\n331\t22    \t2367.53     \t9.68226    \t2319.96     \t2370.29\n332\t23    \t2369.7      \t1.42649    \t2363.74     \t2370.48\n333\t21    \t2369.57     \t1.57945    \t2364.57     \t2370.48\n334\t22    \t2370.01     \t0.770532   \t2366.42     \t2370.48\n335\t23    \t2369.75     \t1.8044     \t2362.19     \t2370.48\n336\t27    \t2369.53     \t1.93696    \t2363.12     \t2370.48\n337\t26    \t2369.9      \t1.85263    \t2360.55     \t2371.24\n338\t22    \t2369.12     \t5.12624    \t2341.62     \t2371.24\n339\t24    \t2370.23     \t1.7348     \t2362.41     \t2371.36\n340\t18    \t2370.26     \t2.5595     \t2357.8      \t2371.36\n341\t23    \t2371.06     \t0.501816   \t2369.46     \t2371.54\n342\t26    \t2370.69     \t1.90719    \t2362.89     \t2371.79\n343\t26    \t2371.26     \t0.772797   \t2368.28     \t2372.09\n344\t26    \t2370.19     \t3.40561    \t2360.37     \t2372.45\n345\t25    \t2371.17     \t4.02829    \t2349.37     \t2372.61\n346\t23    \t2370.77     \t4.52826    \t2350.85     \t2372.8 \n347\t26    \t2371.04     \t4.68541    \t2353.19     \t2372.8 \n348\t19    \t2372.56     \t0.45573    \t2370.99     \t2372.88\n349\t21    \t2372.23     \t1.65813    \t2365.14     \t2372.89\n350\t26    \t2372.57     \t0.723529   \t2369.46     \t2373.09\n351\t22    \t2372.44     \t1.24482    \t2367.29     \t2373.2 \n352\t22    \t2372.72     \t0.913307   \t2368.2      \t2373.31\n353\t23    \t2372.06     \t2.37549    \t2364.15     \t2373.62\n354\t27    \t2372.53     \t2.27523    \t2362.18     \t2373.76\n355\t30    \t2372.78     \t1.93963    \t2363.25     \t2373.97\n356\t21    \t2373.4      \t1.04308    \t2368.82     \t2374.22\n357\t23    \t2373.56     \t0.916165   \t2370.33     \t2374.22\n358\t25    \t2373.39     \t1.58204    \t2366.66     \t2374.24\n359\t22    \t2373.29     \t2.43058    \t2363.06     \t2374.23\n360\t28    \t2373.7      \t1.64857    \t2366.46     \t2374.75\n361\t24    \t2374.06     \t0.79299    \t2370.69     \t2374.75\n362\t25    \t2373.81     \t1.44037    \t2368.59     \t2374.84\n363\t25    \t2374.19     \t1.42067    \t2368.03     \t2374.84\n364\t25    \t2373.59     \t3.5744     \t2357.99     \t2374.99\n365\t24    \t2374.27     \t2.43869    \t2361.22     \t2375.04\n366\t28    \t2374.06     \t2.59681    \t2363.85     \t2375.1 \n367\t19    \t2374.73     \t1.3483     \t2367.43     \t2375.13\n368\t21    \t2374.55     \t1.64652    \t2366.12     \t2375.68\n369\t23    \t2374.79     \t1.7283     \t2366.79     \t2375.83\n370\t18    \t2375.01     \t1.73109    \t2366.79     \t2376.27\n371\t19    \t2375.08     \t2.36017    \t2363.61     \t2376.27\n372\t21    \t2375.86     \t0.670142   \t2373.73     \t2376.5 \n373\t25    \t2375.47     \t3.05026    \t2359.3      \t2376.71\n374\t19    \t2375.51     \t3.80844    \t2355.17     \t2376.9 \n375\t22    \t2375.35     \t3.24968    \t2361.23     \t2376.91\n376\t21    \t2376.14     \t1.52832    \t2369.71     \t2377.11\n377\t24    \t2376.38     \t2.11474    \t2364.87     \t2377.24\n378\t23    \t2376.15     \t2.20204    \t2367.53     \t2377.42\n379\t24    \t2376.89     \t0.871082   \t2373.43     \t2377.61\n380\t27    \t2376.79     \t1.89767    \t2366.81     \t2377.68\n381\t21    \t2375.66     \t4.78973    \t2355.01     \t2377.75\n382\t22    \t2376.93     \t2.04089    \t2368.11     \t2377.75\n383\t22    \t2377.65     \t0.232459   \t2376.61     \t2377.82\n384\t23    \t2376.37     \t5.02832    \t2350.13     \t2377.82\n385\t24    \t2377.06     \t2.82064    \t2361.83     \t2377.82\n386\t19    \t2377.31     \t1.38416    \t2370.69     \t2378.03\n387\t21    \t2377.38     \t1.66381    \t2368.85     \t2378.44\n388\t20    \t2376.78     \t3.3902     \t2364.06     \t2378.75\n389\t26    \t2377.14     \t2.48883    \t2368.03     \t2378.75\n390\t21    \t2378.2      \t0.866992   \t2374.78     \t2379.01\n391\t23    \t2377.76     \t2.83913    \t2366.57     \t2379.23\n392\t23    \t2378.49     \t1.11568    \t2374.13     \t2379.73\n393\t28    \t2378.39     \t1.78229    \t2372.09     \t2379.86\n394\t26    \t2378.98     \t1.52716    \t2374.21     \t2380.2 \n395\t26    \t2377.66     \t7.84818    \t2337.54     \t2380.65\n396\t19    \t2378.63     \t6.35402    \t2345.78     \t2380.65\n397\t29    \t2379.94     \t1.22154    \t2375.7      \t2381.37\n398\t20    \t2380.06     \t1.39126    \t2375.87     \t2381.53\n399\t23    \t2380.02     \t2.39516    \t2370.28     \t2381.62\n400\t23    \t2380.96     \t1.06554    \t2377.08     \t2381.92\n401\t29    \t2381.06     \t1.28531    \t2377.67     \t2381.96\n402\t20    \t2380.93     \t2.46289    \t2372.05     \t2382.22\n403\t24    \t2381.75     \t0.759266   \t2378.91     \t2382.44\n404\t27    \t2380.95     \t4.65119    \t2356.26     \t2382.43\n405\t25    \t2382.04     \t0.691915   \t2379.56     \t2382.6 \n406\t25    \t2381.49     \t3.96093    \t2360.19     \t2382.67\n407\t28    \t2380.68     \t4.30432    \t2367.63     \t2383.16\n408\t23    \t2381.88     \t3.01103    \t2366.21     \t2383.16\n409\t26    \t2382.13     \t1.74648    \t2376.58     \t2383.44\n410\t20    \t2382.69     \t1.71611    \t2376.06     \t2383.78\n411\t26    \t2382.91     \t1.80825    \t2375.66     \t2384.49\n412\t18    \t2383.61     \t0.80759    \t2381.38     \t2385.31\n413\t24    \t2383.47     \t2.32518    \t2376.48     \t2385.38\n414\t21    \t2383.83     \t3.70525    \t2364.5      \t2385.89\n415\t22    \t2384.74     \t1.34764    \t2379.15     \t2385.89\n416\t23    \t2385.22     \t1.06984    \t2380.37     \t2386.22\n417\t23    \t2385.1      \t1.93081    \t2378.89     \t2386.76\n418\t24    \t2383.69     \t8.5751     \t2338.89     \t2386.76\n419\t22    \t2385.55     \t1.76607    \t2379.04     \t2386.76\n420\t20    \t2385.72     \t3.30549    \t2367.82     \t2386.92\n421\t19    \t2386.63     \t0.574262   \t2383.77     \t2387   \n422\t25    \t2386.38     \t1.29744    \t2381.54     \t2387.26\n423\t25    \t2386.97     \t0.325994   \t2385.54     \t2387.66\n424\t24    \t2386.93     \t1.01729    \t2383.59     \t2388.03\n425\t22    \t2387.14     \t1.45773    \t2381.71     \t2388.24\n426\t26    \t2370.94     \t90.0697    \t1877.66     \t2388.52\n427\t24    \t2387.61     \t1.45393    \t2381.19     \t2388.78\n428\t25    \t2372        \t88.4542    \t1887.53     \t2389.52\n429\t20    \t2354.05     \t127.307    \t1867.5      \t2389.52\n430\t20    \t2372.46     \t89.7863    \t1880.69     \t2389.52\n431\t28    \t2389.01     \t1.45371    \t2381.42     \t2389.61\n432\t24    \t2352.86     \t133.112    \t1813.85     \t2390   \n433\t22    \t2389.27     \t1.27361    \t2383.65     \t2390.13\n434\t22    \t2373.35     \t88.5541    \t1888.34     \t2390.89\n435\t24    \t2353.86     \t137.269    \t1821.04     \t2390.9 \n436\t28    \t2389.93     \t1.66872    \t2382.42     \t2391.1 \n437\t27    \t2354.5      \t132.559    \t1848.34     \t2391.47\n438\t23    \t2357.08     \t128.511    \t1865.94     \t2391.71\n439\t21    \t2340.74     \t152.717    \t1868.96     \t2391.71\n440\t23    \t2357.22     \t127.971    \t1859.06     \t2391.81\n441\t26    \t2357.93     \t125.25     \t1876.92     \t2391.84\n442\t24    \t2306.66     \t193.275    \t1830.44     \t2391.89\n443\t24    \t2358.73     \t124.169    \t1883.61     \t2392.25\n444\t23    \t2375.58     \t88.8156    \t1889.13     \t2392.25\n445\t20    \t2325.29     \t172.169    \t1871.77     \t2392.46\n446\t28    \t2290.82     \t206.523    \t1827.42     \t2392.46\n447\t23    \t2375.15     \t93.7702    \t1861.55     \t2392.47\n448\t27    \t2289.58     \t209.262    \t1842.23     \t2392.82\n449\t23    \t2309.7      \t187.458    \t1879.73     \t2392.82\n450\t22    \t2325.28     \t171.462    \t1875.77     \t2393.23\n451\t26    \t2358.27     \t130.613    \t1852        \t2393.23\n452\t27    \t2324.98     \t175.314    \t1814.08     \t2393.24\n453\t27    \t2274.8      \t218.831    \t1835.16     \t2393.26\n454\t20    \t2292.12     \t205.39     \t1856.22     \t2393.67\n455\t24    \t2340.82     \t159.346    \t1818.92     \t2393.76\n456\t23    \t2292.21     \t206.391    \t1852.53     \t2393.76\n457\t27    \t2309.92     \t190.204    \t1867.51     \t2394.31\n458\t20    \t2326.9      \t172.544    \t1862.12     \t2394.81\n459\t23    \t2324.78     \t178.325    \t1827.5      \t2394.81\n460\t21    \t2377.36     \t92.2337    \t1872.21     \t2394.85\n461\t20    \t2325.17     \t178.608    \t1830.12     \t2394.85\n462\t23    \t2360.23     \t130.317    \t1843.01     \t2395.3 \n463\t25    \t2309.71     \t193.515    \t1842.31     \t2396.44\n464\t22    \t2327.03     \t175.566    \t1849.5      \t2396.44\n465\t20    \t2326.79     \t176.24     \t1841.81     \t2396.44\n466\t19    \t2377.57     \t95.2159    \t1857.85     \t2396.5 \n467\t25    \t2328.19     \t173.095    \t1864.24     \t2396.5 \n468\t21    \t2380.06     \t89.6814    \t1888.86     \t2397.29\n469\t22    \t2328.63     \t175.755    \t1840.82     \t2397.34\n470\t18    \t2330.23     \t172.316    \t1870.46     \t2397.43\n471\t25    \t2293.54     \t209.788    \t1801.55     \t2397.48\n472\t23    \t2364.61     \t124.146    \t1891.79     \t2397.72\n473\t24    \t2294.55     \t205.868    \t1838.47     \t2397.85\n474\t25    \t2348.01     \t151.048    \t1880.41     \t2398.02\n475\t23    \t2232.19     \t239.819    \t1852.95     \t2398.46\n476\t26    \t2315.49     \t187.826    \t1872.12     \t2398.52\n477\t20    \t2347.77     \t152.997    \t1859.91     \t2399.03\n478\t20    \t2280.36     \t217.778    \t1833.33     \t2399.03\n479\t20    \t2298.96     \t202.283    \t1874.56     \t2399.03\n480\t20    \t2315.57     \t190.403    \t1854.73     \t2399.67\n481\t16    \t2346.61     \t158.896    \t1836.62     \t2399.67\n482\t19    \t2349.89     \t150.197    \t1879.73     \t2399.67\n483\t20    \t2282.37     \t216.453    \t1850.21     \t2399.67\n484\t19    \t2330.28     \t179.865    \t1828.78     \t2399.67\n485\t21    \t2314.82     \t191.408    \t1862.46     \t2399.67\n486\t20    \t2281.75     \t217.632    \t1841.98     \t2399.75\n487\t28    \t2265.89     \t224.043    \t1855.57     \t2399.78\n488\t26    \t2281.82     \t217.176    \t1843.8      \t2399.75\n489\t27    \t2348.93     \t148.672    \t1894.55     \t2399.75\n490\t24    \t2313.87     \t190.806    \t1859.24     \t2399.9 \n491\t23    \t2332.2      \t175.222    \t1851.72     \t2400.13\n492\t21    \t2245.52     \t238.245    \t1829.3      \t2400.13\n493\t26    \t2268.24     \t222.281    \t1876.91     \t2400.13\n494\t22    \t2348.89     \t156.293    \t1821.2      \t2400.13\n495\t23    \t2349.4      \t153.328    \t1873.29     \t2400.13\n496\t27    \t2243.98     \t244.633    \t1796.99     \t2400.13\n497\t24    \t2348.42     \t156.404    \t1863.81     \t2400.17\n498\t30    \t2331.33     \t174.454    \t1869.62     \t2400.17\n499\t18    \t2283.47     \t215.642    \t1868.71     \t2400.17\n500\t19    \t2350.13     \t152.655    \t1878.71     \t2400.17\n501\t16    \t2350.04     \t152.307    \t1876.56     \t2400.17\n502\t22    \t2267.07     \t225.015    \t1868.13     \t2400.17\n503\t22    \t2347.47     \t159.837    \t1836.59     \t2400.17\n504\t23    \t2300.39     \t203.01     \t1863.07     \t2400.17\n505\t24    \t2282.01     \t217.462    \t1827.49     \t2400.17\n506\t28    \t2283.48     \t214.938    \t1871.06     \t2400.19\n507\t25    \t2351.25     \t148.576    \t1892.78     \t2400.19\n508\t24    \t2315.24     \t192.927    \t1828.45     \t2400.19\n509\t20    \t2349.41     \t154.623    \t1864.37     \t2400.19\n510\t22    \t2332.78     \t172.719    \t1877.48     \t2400.19\n511\t25    \t2301.07     \t201.698    \t1876.35     \t2400.19\n512\t25    \t2333.8      \t170.796    \t1885.27     \t2400.2 \n513\t23    \t2284.79     \t212.831    \t1878.52     \t2400.2 \n514\t17    \t2235.27     \t238.936    \t1874.99     \t2400.2 \n515\t26    \t2283.05     \t215.987    \t1834.82     \t2400.2 \n516\t25    \t2298.76     \t203.133    \t1869.79     \t2400.2 \n517\t23    \t2363.66     \t137.838    \t1824.81     \t2400.2 \n518\t28    \t2316.93     \t189.845    \t1860.73     \t2400.2 \n519\t27    \t2382.27     \t92.2912    \t1876.99     \t2400.2 \n520\t20    \t2317.43     \t188.222    \t1869.74     \t2400.2 \n521\t27    \t2383.35     \t88.9428    \t1896.26     \t2400.2 \n522\t25    \t2315.78     \t191.894    \t1839.6      \t2400.2 \n523\t20    \t2281.35     \t218.29     \t1849.64     \t2400.2 \n524\t26    \t2250.94     \t233.083    \t1868.93     \t2400.2 \n525\t21    \t2299.96     \t203.318    \t1872.82     \t2400.2 \n526\t27    \t2283.36     \t216.406    \t1861.46     \t2400.2 \n527\t24    \t2267.45     \t224.197    \t1848.74     \t2400.2 \n528\t25    \t2316.02     \t190.809    \t1850.77     \t2400.2 \n529\t24    \t2316.02     \t191.8      \t1860.65     \t2400.2 \n530\t25    \t2332.43     \t176.016    \t1822.68     \t2400.2 \n531\t20    \t2316.05     \t190.294    \t1843.61     \t2400.24\n532\t21    \t2333.23     \t173.762    \t1858.07     \t2400.24\n533\t21    \t2333.07     \t171.214    \t1879.74     \t2400.32\n534\t23    \t2250.34     \t234.39     \t1856.91     \t2400.41\n535\t25    \t2316.28     \t191.187    \t1867.35     \t2400.41\n536\t22    \t2333.1      \t173.617    \t1871.47     \t2400.41\n537\t20    \t2316.23     \t190.495    \t1850.52     \t2400.41\n538\t26    \t2346.8      \t157.513    \t1833.44     \t2400.43\n539\t27    \t2298        \t206.307    \t1838.43     \t2400.43\n540\t19    \t2382.79     \t93.8737    \t1868.69     \t2400.43\n541\t17    \t2296.72     \t211.643    \t1826.74     \t2400.58\n542\t24    \t2299.16     \t206.84     \t1847.14     \t2400.98\n543\t26    \t2299.32     \t205.833    \t1840.67     \t2400.98\n544\t18    \t2351.14     \t150.366    \t1885.77     \t2401.07\n545\t24    \t2301.28     \t201.157    \t1876.31     \t2401.07\n546\t26    \t2318.1      \t186.992    \t1870.5      \t2401.07\n547\t17    \t2351.7      \t150.371    \t1888.77     \t2401.07\n548\t17    \t2298.84     \t208.568    \t1818.89     \t2401.07\n549\t26    \t2351.58     \t149.918    \t1883.46     \t2401.12\n550\t24    \t2332.5      \t177.185    \t1827.85     \t2401.13\n551\t21    \t2383.51     \t95.3786    \t1861.11     \t2401.2 \n552\t23    \t2335.3      \t170.431    \t1878.31     \t2401.2 \n553\t25    \t2215.04     \t250.737    \t1826.78     \t2401.2 \n554\t24    \t2367.67     \t125.599    \t1881.5      \t2401.2 \n555\t20    \t2349.95     \t155.767    \t1863.16     \t2401.2 \n556\t27    \t2318.48     \t188.169    \t1871.64     \t2401.22\n557\t26    \t2317.66     \t188.705    \t1854.43     \t2401.73\n558\t21    \t2299.28     \t208.205    \t1830.3      \t2401.73\n559\t24    \t2368.46     \t124.353    \t1893.54     \t2401.73\n560\t25    \t2351.82     \t151.59     \t1869.43     \t2401.85\n561\t19    \t2334.84     \t173.57     \t1861.47     \t2401.95\n562\t26    \t2334.15     \t174.193    \t1838.18     \t2402.35\n563\t21    \t2268.53     \t224.854    \t1855.11     \t2402.25\n564\t24    \t2334.8      \t170.002    \t1881.4      \t2402.25\n565\t25    \t2369.08     \t124.71     \t1894.21     \t2402.25\n566\t26    \t2285.72     \t214.265    \t1862.07     \t2402.6 \n567\t23    \t2367.35     \t130.671    \t1855        \t2402.47\n568\t26    \t2264.4      \t232.929    \t1841.96     \t2402.26\n569\t21    \t2335.89     \t171.292    \t1861.69     \t2402.38\n570\t28    \t2315.25     \t198.005    \t1853.97     \t2402.38\n571\t19    \t2334.52     \t175.355    \t1850.37     \t2402.69\n572\t27    \t2333.21     \t176.872    \t1860.51     \t2402.69\n573\t26    \t2283.54     \t219.962    \t1857.85     \t2402.87\n574\t18    \t2367.79     \t128.747    \t1872.41     \t2402.87\n575\t28    \t2385.74     \t92.7628    \t1877.66     \t2403.04\n576\t26    \t2336.65     \t170.278    \t1872.6      \t2403.04\n577\t23    \t2302.63     \t202.291    \t1863.3      \t2403.18\n578\t26    \t2321.14     \t185.597    \t1890.03     \t2403.18\n579\t25    \t2354.08     \t147.986    \t1901.56     \t2403.29\n580\t17    \t2353.14     \t151.426    \t1877.57     \t2403.56\n581\t27    \t2335.3      \t176.164    \t1845.67     \t2403.56\n582\t26    \t2337.22     \t171.178    \t1886.7      \t2404.4 \n583\t20    \t2302.24     \t207.071    \t1829.76     \t2404.86\n584\t24    \t2317.41     \t194.7      \t1861.84     \t2404.86\n585\t24    \t2336.94     \t172.473    \t1877.78     \t2404.93\n586\t21    \t2352.19     \t155.293    \t1858.97     \t2404.86\n587\t17    \t2387.77     \t90.6382    \t1891.33     \t2404.86\n588\t18    \t2322.26     \t186.689    \t1885.22     \t2404.89\n589\t25    \t2334.91     \t180.283    \t1834.92     \t2404.89\n590\t26    \t2270.03     \t227.688    \t1842.29     \t2404.89\n591\t25    \t2337.84     \t174.022    \t1854.15     \t2404.95\n592\t22    \t2337.49     \t174.479    \t1871.63     \t2404.96\n593\t24    \t2335.11     \t179.622    \t1853.89     \t2404.96\n594\t25    \t2336.72     \t176.933    \t1845.5      \t2404.97\n595\t24    \t2371.68     \t125.257    \t1888.59     \t2404.97\n596\t26    \t2304.69     \t204.169    \t1855.98     \t2404.97\n597\t22    \t2338.12     \t173.517    \t1878.54     \t2404.97\n598\t22    \t2355.88     \t149.831    \t1892.32     \t2404.97\n599\t16    \t2306.1      \t201.124    \t1886.41     \t2405.38\n600\t22    \t2354.84     \t150.191    \t1890.76     \t2405.38\n601\t23    \t2339.89     \t168.796    \t1898.87     \t2405.38\n602\t18    \t2355.81     \t149.808    \t1890.81     \t2405.38\n603\t24    \t2370.92     \t130.101    \t1850.71     \t2405.43\n604\t25    \t2388.96     \t88.5125    \t1904.18     \t2405.43\n605\t25    \t2387.6      \t90.6746    \t1891.81     \t2405.45\n606\t20    \t2354.43     \t151.717    \t1887.09     \t2405.51\n607\t27    \t2320.37     \t190.841    \t1850.15     \t2405.58\n608\t24    \t2322.07     \t189.534    \t1877.69     \t2405.84\n609\t22    \t2172.08     \t257.244    \t1873.84     \t2405.84\n610\t26    \t2305.61     \t201.55     \t1879.27     \t2405.92\n611\t22    \t2354.79     \t152.042    \t1879.84     \t2405.92\n612\t25    \t2339.26     \t172.323    \t1878.9      \t2405.97\n613\t22    \t2323.33     \t188.222    \t1887.98     \t2405.98\n614\t20    \t2354.73     \t151.495    \t1887.98     \t2406.13\n615\t16    \t2373.12     \t124.645    \t1894.98     \t2406.13\n616\t26    \t2304.88     \t203.888    \t1864.84     \t2406.13\n617\t22    \t2356.24     \t150.423    \t1892.35     \t2406.16\n618\t21    \t2339.8      \t170.506    \t1888.31     \t2406.16\n619\t24    \t2354.79     \t156.861    \t1849.37     \t2406.17\n620\t15    \t2355.73     \t153.285    \t1886.04     \t2406.17\n621\t27    \t2274.59     \t222.98     \t1891.12     \t2406.17\n622\t18    \t2354.62     \t153.312    \t1859.12     \t2406.18\n623\t21    \t2355.07     \t154.374    \t1878.05     \t2406.18\n624\t25    \t2340.73     \t169.625    \t1893.75     \t2406.19\n625\t15    \t2370.83     \t132.86     \t1861.74     \t2406.19\n626\t24    \t2356.54     \t150.781    \t1886.27     \t2406.19\n627\t26    \t2303.1      \t209.449    \t1841.82     \t2406.46\n628\t19    \t2323.59     \t187.514    \t1892.63     \t2406.47\n629\t22    \t2324.24     \t186.485    \t1885.12     \t2406.47\n630\t23    \t2307.91     \t201.152    \t1884.48     \t2406.47\n631\t23    \t2355.1      \t155.647    \t1836.03     \t2406.47\n632\t16    \t2340.08     \t172.463    \t1866.85     \t2406.47\n633\t23    \t2389.91     \t88.6538    \t1904.42     \t2406.47\n634\t25    \t2405.91     \t1.15662    \t2401.25     \t2406.47\n635\t20    \t2340.17     \t171.879    \t1867.94     \t2406.47\n636\t27    \t2270.61     \t229.396    \t1823.5      \t2406.47\n637\t25    \t2306.44     \t203.636    \t1835.58     \t2406.47\n638\t25    \t2221.61     \t249.207    \t1850.95     \t2406.47\n639\t20    \t2355.8      \t152.924    \t1877.76     \t2406.47\n640\t21    \t2354.95     \t153.382    \t1870.12     \t2406.73\n641\t25    \t2338.63     \t175.03     \t1867.78     \t2407.16\n642\t19    \t2357.77     \t149.213    \t1895.22     \t2407.16\n643\t26    \t2338.39     \t175.954    \t1814.6      \t2407.39\n644\t22    \t2341.06     \t171.035    \t1881.49     \t2407.39\n645\t21    \t2273.89     \t225.787    \t1876.92     \t2407.39\n646\t25    \t2322.75     \t192.166    \t1821.15     \t2407.39\n647\t24    \t2324.9      \t187.84     \t1872.93     \t2407.63\n648\t19    \t2274.84     \t224.571    \t1874.9      \t2407.63\n649\t23    \t2324.91     \t187.301    \t1878.85     \t2407.63\n650\t26    \t2307.39     \t201.977    \t1866.65     \t2407.63\n651\t27    \t2390.32     \t90.5919    \t1894.4      \t2407.63\n652\t24    \t2357.32     \t153.222    \t1886.93     \t2407.67\n653\t24    \t2291.43     \t215.085    \t1878.04     \t2407.67\n654\t24    \t2372.62     \t132.027    \t1865.08     \t2407.67\n655\t21    \t2374.48     \t123.511    \t1902.46     \t2407.92\n656\t22    \t2273.74     \t226.901    \t1868.55     \t2407.92\n657\t26    \t2340.65     \t170.454    \t1884.48     \t2407.92\n658\t25    \t2357.05     \t151.574    \t1879.47     \t2407.92\n659\t24    \t2407.43     \t2.43342    \t2394.14     \t2408.14\n660\t20    \t2357.86     \t151.788    \t1878.01     \t2408.14\n661\t18    \t2372.02     \t135.47     \t1855.56     \t2408.18\n662\t25    \t2256.97     \t235.325    \t1871.63     \t2408.19\n663\t24    \t2308.06     \t203.247    \t1865.57     \t2408.19\n664\t29    \t2225.94     \t245.573    \t1867.12     \t2408.19\n665\t26    \t2259.23     \t231.871    \t1873        \t2408.19\n666\t21    \t2391.59     \t89.3743    \t1902.09     \t2408.46\n667\t25    \t2375.21     \t123.387    \t1903.33     \t2408.46\n668\t28    \t2374.8      \t124.776    \t1896.22     \t2408.61\n669\t24    \t2390.73     \t92.1097    \t1886.4      \t2408.61\n670\t20    \t2325.34     \t189.228    \t1875.74     \t2408.61\n671\t24    \t2340.84     \t171.893    \t1877.5      \t2408.62\n672\t22    \t2274.77     \t226.663    \t1868.23     \t2408.62\n673\t14    \t2374.99     \t126.91     \t1883.31     \t2408.64\n674\t25    \t2275.13     \t226.19     \t1865.81     \t2408.64\n675\t28    \t2241.21     \t241.476    \t1848.93     \t2408.64\n676\t24    \t2242.92     \t239.763    \t1854.53     \t2408.64\n677\t28    \t2375.08     \t125.923    \t1886.01     \t2408.78\n678\t21    \t2340.86     \t174.63     \t1856.05     \t2408.78\n679\t26    \t2325.7      \t188.7      \t1861.91     \t2408.78\n680\t23    \t2307.62     \t206.658    \t1828.58     \t2408.78\n681\t24    \t2310.43     \t200.009    \t1897.49     \t2408.78\n682\t25    \t2340.84     \t175.54     \t1877.27     \t2408.78\n683\t21    \t2341.21     \t175.03     \t1858.99     \t2408.78\n684\t22    \t2309.35     \t201.44     \t1873.94     \t2408.78\n685\t27    \t2322.7      \t195.393    \t1840.23     \t2408.78\n686\t26    \t2276.2      \t223.623    \t1883.06     \t2408.78\n687\t22    \t2341.83     \t171.566    \t1885.13     \t2408.78\n688\t20    \t2340.83     \t175.086    \t1876.73     \t2408.78\n689\t23    \t2324.55     \t188.959    \t1870.79     \t2408.78\n690\t22    \t2392.01     \t88.9493    \t1904.86     \t2408.78\n691\t21    \t2358.23     \t153.751    \t1865.7      \t2408.78\n692\t25    \t2342.45     \t172.234    \t1872.68     \t2408.84\n693\t25    \t2291.3      \t216.621    \t1870.04     \t2408.84\n694\t23    \t2342.03     \t172.675    \t1879.57     \t2408.88\n695\t21    \t2326.56     \t187.011    \t1887.74     \t2408.9 \n696\t23    \t2308.39     \t204.859    \t1871.42     \t2408.9 \n697\t25    \t2323.79     \t190.338    \t1873.79     \t2408.9 \n698\t21    \t2323.31     \t194.977    \t1829.1      \t2408.92\n699\t20    \t2358.46     \t153.271    \t1864.66     \t2408.92\n700\t25    \t2340.6      \t175.656    \t1871.43     \t2409   \nControl points: [[ 29.98404996  91.88591948]\n [226.49665573 154.72143214]\n [153.818419   105.18835249]\n [216.16069477 136.30931099]]\n</pre> In\u00a0[10]: Copied! <pre>fitted_curve_points, t_values = generate_curve_within_boundaries(refined_control_points, image.shape, 0.01)\nplt.figure(figsize=(10, 5))\n\nplt.subplot(1, 2, 1)\nplt.imshow(image, cmap='gray', origin='lower')\nplt.plot(initial_fitted_curve_points[:, 0], initial_fitted_curve_points[:, 1], 'r-')\nplt.plot(initial_control_points[:, 0], initial_control_points[:, 1], 'g.')\nplt.title('Initial Fitted Curve on Image')\nplt.axis('off')\n\nplt.subplot(1, 2, 2)\nplt.imshow(image, cmap='gray', origin='lower')\nplt.plot(fitted_curve_points[:, 0], fitted_curve_points[:, 1], 'r-')\nplt.plot(refined_control_points[:, 0], refined_control_points[:, 1], 'g.')\nplt.title('Refined Fitted Curve on Image')\nplt.axis('off')\n\nplt.tight_layout()\nplt.show()\n</pre> fitted_curve_points, t_values = generate_curve_within_boundaries(refined_control_points, image.shape, 0.01) plt.figure(figsize=(10, 5))  plt.subplot(1, 2, 1) plt.imshow(image, cmap='gray', origin='lower') plt.plot(initial_fitted_curve_points[:, 0], initial_fitted_curve_points[:, 1], 'r-') plt.plot(initial_control_points[:, 0], initial_control_points[:, 1], 'g.') plt.title('Initial Fitted Curve on Image') plt.axis('off')  plt.subplot(1, 2, 2) plt.imshow(image, cmap='gray', origin='lower') plt.plot(fitted_curve_points[:, 0], fitted_curve_points[:, 1], 'r-') plt.plot(refined_control_points[:, 0], refined_control_points[:, 1], 'g.') plt.title('Refined Fitted Curve on Image') plt.axis('off')  plt.tight_layout() plt.show() In\u00a0[11]: Copied! <pre>membrane_averaging = MemAverage(image=image, control_points=refined_control_points, pixel_size=2.170)\nmembrane_mask, averaged_2d = membrane_averaging.mem_average()\n</pre> membrane_averaging = MemAverage(image=image, control_points=refined_control_points, pixel_size=2.170) membrane_mask, averaged_2d = membrane_averaging.mem_average() In\u00a0[12]: Copied! <pre>fitted_curve_points, t_values = generate_curve_within_boundaries(refined_control_points, image.shape, 0.01)\nplt.figure(figsize=(10, 5))\n\nplt.subplot(1, 3, 1)\nplt.imshow(image, cmap='gray', origin='lower')\nplt.plot(fitted_curve_points[:, 0], fitted_curve_points[:, 1], 'r-')\nplt.plot(refined_control_points[:, 0], refined_control_points[:, 1], 'g.')\nplt.title('Refined Fitted Curve on Image')\nplt.axis('off')\n\nplt.subplot(1, 3, 2)\nplt.imshow(membrane_mask, cmap='gray', origin='lower')\nplt.title('Membrane Mask')\nplt.axis('off')\n\nplt.subplot(1, 3, 3)\nplt.imshow(averaged_2d*membrane_mask, cmap='gray', origin='lower')\nplt.title('Averaged 2D')\nplt.axis('off')\n\n\nplt.tight_layout()\nplt.show()\n</pre> fitted_curve_points, t_values = generate_curve_within_boundaries(refined_control_points, image.shape, 0.01) plt.figure(figsize=(10, 5))  plt.subplot(1, 3, 1) plt.imshow(image, cmap='gray', origin='lower') plt.plot(fitted_curve_points[:, 0], fitted_curve_points[:, 1], 'r-') plt.plot(refined_control_points[:, 0], refined_control_points[:, 1], 'g.') plt.title('Refined Fitted Curve on Image') plt.axis('off')  plt.subplot(1, 3, 2) plt.imshow(membrane_mask, cmap='gray', origin='lower') plt.title('Membrane Mask') plt.axis('off')  plt.subplot(1, 3, 3) plt.imshow(averaged_2d*membrane_mask, cmap='gray', origin='lower') plt.title('Averaged 2D') plt.axis('off')   plt.tight_layout() plt.show()"},{"location":"tutorials/reference/bezierfit-mem-analysis-visualizer/#visualizing-bezier-analysis-ipynb","title":"Visualizing Bezier Analysis (<code>.ipynb</code>)\u00b6","text":""},{"location":"tutorials/reference/bezierfit-mem-analysis-visualizer/#coarse-fit","title":"Coarse fit\u00b6","text":""},{"location":"tutorials/reference/bezierfit-mem-analysis-visualizer/#import-necessary-libraries","title":"Import necessary libraries\u00b6","text":""},{"location":"tutorials/reference/bezierfit-mem-analysis-visualizer/#set-the-paramters","title":"Set the paramters\u00b6","text":""},{"location":"tutorials/reference/bezierfit-mem-analysis-visualizer/#generate-the-data-points","title":"Generate the data points\u00b6","text":""},{"location":"tutorials/reference/bezierfit-mem-analysis-visualizer/#coarse-fit-generate-intial-control-points","title":"Coarse fit: generate intial control points\u00b6","text":""},{"location":"tutorials/reference/bezierfit-mem-analysis-visualizer/#ga-refinement","title":"GA Refinement\u00b6","text":""},{"location":"tutorials/reference/bezierfit-mem-analysis-visualizer/#set-the-parameters","title":"Set the parameters\u00b6","text":""},{"location":"tutorials/reference/bezierfit-mem-analysis-visualizer/#membrane-average","title":"Membrane Average\u00b6","text":""},{"location":"tutorials/reference/conventions/","title":"Conventions","text":"<p>Currently under development. More content will come soon...</p>"},{"location":"tutorials/reference/radonfit-mem-analysis-visualizer/","title":"Visualizing Radon Analysis (.ipynb)","text":"In\u00a0[1]: Copied! <pre>from src.radon_analyser import RadonAnalyzer\nimport mrcfile\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> from src.radon_analyser import RadonAnalyzer import mrcfile import numpy as np import matplotlib.pyplot as plt In\u00a0[2]: Copied! <pre>templates_selected_mrcfile = './db/templates_selected.mrc'\nsection = 2\ncrop_rate = 0.7\nthreshold = 0.6\ntheta_start = 0\ntheta_end = 180\n</pre> templates_selected_mrcfile = './db/templates_selected.mrc' section = 2 crop_rate = 0.7 threshold = 0.6 theta_start = 0 theta_end = 180 In\u00a0[3]: Copied! <pre>with mrcfile.open(templates_selected_mrcfile) as mrc:\n    average2D = mrc.data[section]\n\nplt.imshow(average2D, cmap='gray', origin='lower')\n</pre> with mrcfile.open(templates_selected_mrcfile) as mrc:     average2D = mrc.data[section]  plt.imshow(average2D, cmap='gray', origin='lower') Out[3]: <pre>&lt;matplotlib.image.AxesImage at 0x127dde9a0&gt;</pre> In\u00a0[4]: Copied! <pre>analyzer = RadonAnalyzer(average2D, crop_rate = crop_rate, thr = threshold, theta_start = theta_start, theta_end = theta_end)\nanalyzer.visualize_analyze()\nrlnAngleTheta, rlnMembraneDistance = analyzer.return_results()\n</pre> analyzer = RadonAnalyzer(average2D, crop_rate = crop_rate, thr = threshold, theta_start = theta_start, theta_end = theta_end) analyzer.visualize_analyze() rlnAngleTheta, rlnMembraneDistance = analyzer.return_results() <pre>peaks: (array([53, 65]), array([24, 24]))\npoint1: 53, 24; point2: 65, 24\naverage_theta: 24.0\nmembrane_distance: 12.0\nb: 0.40673664307580015\n</pre> <pre>====Radon Analysis Results====\naverage_theta: 24.0\nmembrane_distance: 12.0\n</pre> In\u00a0[5]: Copied! <pre>from src.template_centerfitting import *\nfrom src.generate_gaussian_template import *\nfrom src.calculate_curve import *\nfrom src.generate_membrane_mask import *\nfrom src.mem_average import *\n</pre> from src.template_centerfitting import * from src.generate_gaussian_template import * from src.calculate_curve import * from src.generate_membrane_mask import * from src.mem_average import * In\u00a0[6]: Copied! <pre># Fit membrane center\ntemplate_size = 32\ntheta = rlnAngleTheta\nmembrane_distance = rlnMembraneDistance\ninitial_sigma1 = 3\ninitial_sigma2 = 3\nsigma_range = 3\nsigma_step = 0.5\n# Curve fitting\nkappa_start = -0.01\nkappa_end = 0.01\nkappa_step = 0.001\n# Generate membrane mask\nedge_sigma_mask = 3\n# Generate Membrane Average\nextra_mem_dist = 15\nedge_sigma = 5\n</pre> # Fit membrane center template_size = 32 theta = rlnAngleTheta membrane_distance = rlnMembraneDistance initial_sigma1 = 3 initial_sigma2 = 3 sigma_range = 3 sigma_step = 0.5 # Curve fitting kappa_start = -0.01 kappa_end = 0.01 kappa_step = 0.001 # Generate membrane mask edge_sigma_mask = 3 # Generate Membrane Average extra_mem_dist = 15 edge_sigma = 5 In\u00a0[7]: Copied! <pre>template_center_fitter = Template_centerfitting(sigma1 = initial_sigma1, sigma2 = initial_sigma2, image = average2D, crop_rate = crop_rate, thr = threshold, theta_start = theta_start, theta_end = theta_end, template_size = template_size, sigma_range = sigma_range, sigma_step = sigma_step)\nrlnCenterX, rlnCenterY = template_center_fitter.centerfinder()\ntemplate_center_fitter.visualize_center()\n</pre> template_center_fitter = Template_centerfitting(sigma1 = initial_sigma1, sigma2 = initial_sigma2, image = average2D, crop_rate = crop_rate, thr = threshold, theta_start = theta_start, theta_end = theta_end, template_size = template_size, sigma_range = sigma_range, sigma_step = sigma_step) rlnCenterX, rlnCenterY = template_center_fitter.centerfinder() template_center_fitter.visualize_center() <pre>====Center fitting results====\nmembrane center y: 61.7459764590515\nmembrane center x: 69.06261976221613\n</pre> In\u00a0[8]: Copied! <pre>rlnSigma1, rlnSigma2 = template_center_fitter.fit_sigma()\ntemplate_center_fitter.fit_sigma_visualize()\n</pre> rlnSigma1, rlnSigma2 = template_center_fitter.fit_sigma() template_center_fitter.fit_sigma_visualize() <pre>====Sigma fitting results====\nbest sigma1: 3.2411764705882358\nbest sigma2: 4.811764705882353\n</pre> In\u00a0[9]: Copied! <pre>test_kappa = 0.005\n\ncurve_fitting = Curvefitting(image=average2D, kappa_start=kappa_start, kappa_end=kappa_end, kappa_step=kappa_step, \n                             rlnCenterX=rlnCenterX, rlnCenterY=rlnCenterY, rlnAngleTheta=rlnAngleTheta, \n                             rlnMembraneDistance=rlnMembraneDistance, rlnSigma1=rlnSigma1, rlnSigma2=rlnSigma2)\n\nsimulated_membrane_example = curve_fitting.generate_membrane(test_kappa)\n\nfig, axes = plt.subplots(1, 2, figsize=(10, 5))\naxes[0].imshow(average2D, cmap='gray', origin='lower')\naxes[0].set_title('Original Image')\naxes[1].imshow(simulated_membrane_example, cmap='gray', origin='lower')\naxes[1].set_title(f'Simulated Membrane(kappa={test_kappa})')\n</pre> test_kappa = 0.005  curve_fitting = Curvefitting(image=average2D, kappa_start=kappa_start, kappa_end=kappa_end, kappa_step=kappa_step,                               rlnCenterX=rlnCenterX, rlnCenterY=rlnCenterY, rlnAngleTheta=rlnAngleTheta,                               rlnMembraneDistance=rlnMembraneDistance, rlnSigma1=rlnSigma1, rlnSigma2=rlnSigma2)  simulated_membrane_example = curve_fitting.generate_membrane(test_kappa)  fig, axes = plt.subplots(1, 2, figsize=(10, 5)) axes[0].imshow(average2D, cmap='gray', origin='lower') axes[0].set_title('Original Image') axes[1].imshow(simulated_membrane_example, cmap='gray', origin='lower') axes[1].set_title(f'Simulated Membrane(kappa={test_kappa})') Out[9]: <pre>Text(0.5, 1.0, 'Simulated Membrane(kappa=0.005)')</pre> In\u00a0[10]: Copied! <pre>rlnCurveKappa = curve_fitting.fit_curve()\ncurve_fitting.fit_curve_visualize()\n</pre> rlnCurveKappa = curve_fitting.fit_curve() curve_fitting.fit_curve_visualize() <pre>Start curve fitting...\niter0 finished, kappa: -0.01, corr_score: 9479.32776779441\niter1 finished, kappa: -0.009000000000000001, corr_score: 9731.191886362822\niter2 finished, kappa: -0.008, corr_score: 9968.630910241023\niter3 finished, kappa: -0.007, corr_score: 10240.63445077838\niter4 finished, kappa: -0.006, corr_score: 10514.981483520773\niter5 finished, kappa: -0.005, corr_score: 10688.19001565214\niter6 finished, kappa: -0.004, corr_score: 10771.952027747464\niter7 finished, kappa: -0.003, corr_score: 10752.109321767228\niter8 finished, kappa: -0.002, corr_score: 10649.384406524576\niter9 finished, kappa: -0.0009999999999999992, corr_score: 10481.668865448042\niter10 finished, kappa: 0.0, corr_score: 10252.573673363295\niter11 finished, kappa: 0.0009999999999999992, corr_score: 9977.881574248659\niter12 finished, kappa: 0.002, corr_score: 9675.908790190737\niter13 finished, kappa: 0.003000000000000001, corr_score: 9337.255998829844\niter14 finished, kappa: 0.004, corr_score: 8996.650078983597\niter15 finished, kappa: 0.004999999999999999, corr_score: 8641.172289222979\niter16 finished, kappa: 0.006, corr_score: 8308.634876431253\niter17 finished, kappa: 0.007000000000000001, corr_score: 7980.288879363302\niter18 finished, kappa: 0.008000000000000002, corr_score: 7648.453744231485\niter19 finished, kappa: 0.009, corr_score: 7364.730556215427\niter20 finished, kappa: 0.01, corr_score: 7121.794592524499\nBest kappa: -0.004\n</pre> In\u00a0[11]: Copied! <pre>mem_mask_generator = mem_mask(image=average2D, rlnCenterX=rlnCenterX, rlnCenterY=rlnCenterY, rlnAngleTheta=rlnAngleTheta, \n                              rlnMembraneDistance=rlnMembraneDistance, rlnSigma1=rlnSigma1, rlnSigma2=rlnSigma2, \n                              rlnCurveKappa=rlnCurveKappa, edge_sigma=edge_sigma_mask)\nmem_mask = mem_mask_generator.generate_mem_mask()\n\nfig, axes = plt.subplots(2, 2, figsize=(10, 10))\naxes[0, 0].imshow(average2D, cmap='gray', origin='lower')\naxes[0, 0].set_title('Original Image')\naxes[0, 1].imshow(curve_fitting.generate_membrane(rlnCurveKappa), cmap='gray', origin='lower')\naxes[0, 1].set_title('Simulated Membrane')\naxes[1, 0].imshow(mem_mask, cmap='gray', origin='lower')\naxes[1, 0].set_title('Generated Membrane Mask')\naxes[1, 1].imshow(average2D*mem_mask, cmap='gray', origin='lower')\naxes[1, 1].set_title('Membrane Masked Image')\n</pre> mem_mask_generator = mem_mask(image=average2D, rlnCenterX=rlnCenterX, rlnCenterY=rlnCenterY, rlnAngleTheta=rlnAngleTheta,                                rlnMembraneDistance=rlnMembraneDistance, rlnSigma1=rlnSigma1, rlnSigma2=rlnSigma2,                                rlnCurveKappa=rlnCurveKappa, edge_sigma=edge_sigma_mask) mem_mask = mem_mask_generator.generate_mem_mask()  fig, axes = plt.subplots(2, 2, figsize=(10, 10)) axes[0, 0].imshow(average2D, cmap='gray', origin='lower') axes[0, 0].set_title('Original Image') axes[0, 1].imshow(curve_fitting.generate_membrane(rlnCurveKappa), cmap='gray', origin='lower') axes[0, 1].set_title('Simulated Membrane') axes[1, 0].imshow(mem_mask, cmap='gray', origin='lower') axes[1, 0].set_title('Generated Membrane Mask') axes[1, 1].imshow(average2D*mem_mask, cmap='gray', origin='lower') axes[1, 1].set_title('Membrane Masked Image')  Out[11]: <pre>Text(0.5, 1.0, 'Membrane Masked Image')</pre> In\u00a0[12]: Copied! <pre>averaged_mem_generator = average_membrane(image=average2D, extra_mem_dist=extra_mem_dist, edge_sigma=edge_sigma, rlnCenterX=rlnCenterX, rlnCenterY=rlnCenterY, rlnAngleTheta=rlnAngleTheta, rlnMembraneDistance=rlnMembraneDistance, rlnSigma1=rlnSigma1, rlnSigma2=rlnSigma2, rlnCurveKappa=rlnCurveKappa)\naveraged_mem_generator.calculate_membrane_average()\naveraged_membrane = averaged_mem_generator.generate_2d_average_mem()\naveraged_mem_generator.visualize_membrane_average()\n</pre> averaged_mem_generator = average_membrane(image=average2D, extra_mem_dist=extra_mem_dist, edge_sigma=edge_sigma, rlnCenterX=rlnCenterX, rlnCenterY=rlnCenterY, rlnAngleTheta=rlnAngleTheta, rlnMembraneDistance=rlnMembraneDistance, rlnSigma1=rlnSigma1, rlnSigma2=rlnSigma2, rlnCurveKappa=rlnCurveKappa) averaged_mem_generator.calculate_membrane_average() averaged_membrane = averaged_mem_generator.generate_2d_average_mem() averaged_mem_generator.visualize_membrane_average()"},{"location":"tutorials/reference/radonfit-mem-analysis-visualizer/#visualizing-radon-analysis-ipynb","title":"Visualizing Radon Analysis (<code>.ipynb</code>)\u00b6","text":""},{"location":"tutorials/reference/radonfit-mem-analysis-visualizer/#radon-analysis-blinking","title":"Radon Analysis Blinking\u00b6","text":""},{"location":"tutorials/reference/radonfit-mem-analysis-visualizer/#import-necessary-libraries","title":"Import necessary libraries\u00b6","text":""},{"location":"tutorials/reference/radonfit-mem-analysis-visualizer/#set-the-paramters","title":"Set the paramters\u00b6","text":""},{"location":"tutorials/reference/radonfit-mem-analysis-visualizer/#show-the-2d-average-to-be-processed","title":"Show the 2D average to be processed\u00b6","text":""},{"location":"tutorials/reference/radonfit-mem-analysis-visualizer/#radon-analysis","title":"Radon Analysis\u00b6","text":""},{"location":"tutorials/reference/radonfit-mem-analysis-visualizer/#membrane-analysis","title":"Membrane Analysis\u00b6","text":""},{"location":"tutorials/reference/radonfit-mem-analysis-visualizer/#import-necessary-libraries","title":"Import necessary libraries\u00b6","text":""},{"location":"tutorials/reference/radonfit-mem-analysis-visualizer/#set-the-paramters","title":"Set the paramters\u00b6","text":""},{"location":"tutorials/reference/radonfit-mem-analysis-visualizer/#generate-the-membrane-template-and-search-for-the-center","title":"Generate the membrane template and search for the center\u00b6","text":""},{"location":"tutorials/reference/radonfit-mem-analysis-visualizer/#search-for-the-best-sigma-values","title":"Search for the best sigma values\u00b6","text":""},{"location":"tutorials/reference/radonfit-mem-analysis-visualizer/#generate-simulated-membrane","title":"Generate simulated membrane\u00b6","text":""},{"location":"tutorials/reference/radonfit-mem-analysis-visualizer/#fit-the-curvaturefind-the-best-kappa-value","title":"Fit the curvature(Find the best kappa value)\u00b6","text":""},{"location":"tutorials/reference/radonfit-mem-analysis-visualizer/#generate-membrane-mask","title":"Generate Membrane Mask\u00b6","text":""},{"location":"tutorials/reference/radonfit-mem-analysis-visualizer/#generate-averaged-membrane","title":"Generate averaged membrane\u00b6","text":""},{"location":"tutorials/reference/src/__init__/","title":"init","text":""},{"location":"tutorials/reference/src/_utils/","title":"utils","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\n</pre> import numpy as np In\u00a0[\u00a0]: Copied! <pre>def distance(x1, y1, x2, y2):\n    return np.sqrt((x1-x2)**2 + (y1-y2)**2)\n</pre> def distance(x1, y1, x2, y2):     return np.sqrt((x1-x2)**2 + (y1-y2)**2) In\u00a0[\u00a0]: Copied! <pre>def create_gaussian_low_pass_filter(image, cutoff_freq):\n    shape = image.shape\n    rows, cols = shape\n    crow, ccol = rows // 2, cols // 2\n    y, x = np.ogrid[-crow:rows-crow, -ccol:cols-ccol]\n    distance = np.sqrt(x*x + y*y)\n    mask = np.exp(-(distance**2) / (2*cutoff_freq**2))\n    f = np.fft.fft2(image)\n    fshift = np.fft.fftshift(f)\n    fshift_filtered = fshift * mask\n    f_ishift = np.fft.ifftshift(fshift_filtered)\n    img_back = np.fft.ifft2(f_ishift)\n    img_back = np.real(img_back)\n    return img_back\n</pre> def create_gaussian_low_pass_filter(image, cutoff_freq):     shape = image.shape     rows, cols = shape     crow, ccol = rows // 2, cols // 2     y, x = np.ogrid[-crow:rows-crow, -ccol:cols-ccol]     distance = np.sqrt(x*x + y*y)     mask = np.exp(-(distance**2) / (2*cutoff_freq**2))     f = np.fft.fft2(image)     fshift = np.fft.fftshift(f)     fshift_filtered = fshift * mask     f_ishift = np.fft.ifftshift(fshift_filtered)     img_back = np.fft.ifft2(f_ishift)     img_back = np.real(img_back)     return img_back In\u00a0[\u00a0]: Copied! <pre>def gaussian_kernel(size, sigma=1.0):\n    size = int(size) // 2\n    x, y = np.mgrid[-size:size+1, -size:size+1]\n    normal = 1 / (2.0 * np.pi * sigma**2)\n    g =  np.exp(-((x**2 + y**2) / (2.0*sigma**2))) * normal\n    return g\n</pre> def gaussian_kernel(size, sigma=1.0):     size = int(size) // 2     x, y = np.mgrid[-size:size+1, -size:size+1]     normal = 1 / (2.0 * np.pi * sigma**2)     g =  np.exp(-((x**2 + y**2) / (2.0*sigma**2))) * normal     return g"},{"location":"tutorials/reference/src/bezierfit/","title":"Bezierfit","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nfrom deap import base, creator, tools, algorithms\nfrom scipy.interpolate import griddata\nfrom scipy.interpolate import interp1d\nfrom scipy.spatial.distance import cdist\nfrom scipy.special import comb\nfrom .pickpoints import generate_data_points\nfrom scipy.signal import correlate2d\nimport random\n</pre> import numpy as np from deap import base, creator, tools, algorithms from scipy.interpolate import griddata from scipy.interpolate import interp1d from scipy.spatial.distance import cdist from scipy.special import comb from .pickpoints import generate_data_points from scipy.signal import correlate2d import random In\u00a0[\u00a0]: Copied! <pre>def bezier_curve(control_points, t):\n    n = len(control_points) - 1\n    B = np.zeros_like(control_points[0], dtype=float)\n    for i, point in enumerate(control_points):\n        B += comb(n, i) * (1 - t) ** (n - i) * t ** i * point\n    return B\n</pre> def bezier_curve(control_points, t):     n = len(control_points) - 1     B = np.zeros_like(control_points[0], dtype=float)     for i, point in enumerate(control_points):         B += comb(n, i) * (1 - t) ** (n - i) * t ** i * point     return B In\u00a0[\u00a0]: Copied! <pre>def bezier_curve_derivative(control_points, t):\n    n = len(control_points) - 1\n    B_prime = np.zeros(2)\n    for i in range(n):\n        coef = n * comb(n-1, i) * t**i * (1-t)**(n-1-i)\n        B_prime += coef * (control_points[i+1] - control_points[i])\n    return B_prime\n</pre> def bezier_curve_derivative(control_points, t):     n = len(control_points) - 1     B_prime = np.zeros(2)     for i in range(n):         coef = n * comb(n-1, i) * t**i * (1-t)**(n-1-i)         B_prime += coef * (control_points[i+1] - control_points[i])     return B_prime In\u00a0[\u00a0]: Copied! <pre>def bezier_curvature(control_points, t, threshold=1e-6, high_curvature_value=1e6):\n    n = len(control_points) - 1\n    \n    dB = np.zeros(2)\n    ddB = np.zeros(2)\n    \n    for i in range(n):\n        coef = n * comb(n-1, i) * t**i * (1-t)**(n-1-i)\n        dB += coef * (control_points[i+1] - control_points[i])\n        \n    for i in range(n-1):\n        coef = n * (n-1) * comb(n-2, i) * t**i * (1-t)**(n-2-i)\n        ddB += coef * (control_points[i+2] - 2*control_points[i+1] + control_points[i])\n\n    dx, dy = dB\n    ddx, ddy = ddB\n    \n    magnitude_squared = dx * dx + dy * dy\n    \n    # \u89c4\u907f\u9664\u6570\u63a5\u8fd1\u96f6\u7684\u95ee\u9898\n    if magnitude_squared &lt; threshold:\n        return high_curvature_value\n\n    curvature = abs(dx * ddy - dy * ddx) / magnitude_squared ** 1.5\n    return curvature\n</pre> def bezier_curvature(control_points, t, threshold=1e-6, high_curvature_value=1e6):     n = len(control_points) - 1          dB = np.zeros(2)     ddB = np.zeros(2)          for i in range(n):         coef = n * comb(n-1, i) * t**i * (1-t)**(n-1-i)         dB += coef * (control_points[i+1] - control_points[i])              for i in range(n-1):         coef = n * (n-1) * comb(n-2, i) * t**i * (1-t)**(n-2-i)         ddB += coef * (control_points[i+2] - 2*control_points[i+1] + control_points[i])      dx, dy = dB     ddx, ddy = ddB          magnitude_squared = dx * dx + dy * dy          # \u89c4\u907f\u9664\u6570\u63a5\u8fd1\u96f6\u7684\u95ee\u9898     if magnitude_squared &lt; threshold:         return high_curvature_value      curvature = abs(dx * ddy - dy * ddx) / magnitude_squared ** 1.5     return curvature In\u00a0[\u00a0]: Copied! <pre>def gaussian_pdf(x, mean, std):\n    coefficient = 1.0 / (std * np.sqrt(2 * np.pi))\n    exponential = np.exp(- (x - mean) ** 2 / (2 * std ** 2))\n    return coefficient * exponential\n</pre> def gaussian_pdf(x, mean, std):     coefficient = 1.0 / (std * np.sqrt(2 * np.pi))     exponential = np.exp(- (x - mean) ** 2 / (2 * std ** 2))     return coefficient * exponential In\u00a0[\u00a0]: Copied! <pre>def gaussian2(x, membrane_dist, std1, std2):\n    mean1 = - membrane_dist / 2\n    mean2 = membrane_dist / 2\n    gaussian1 = gaussian_pdf(x, mean1, std1)\n    gaussian2 = gaussian_pdf(x, mean2, std2)\n    g = gaussian1 + gaussian2\n    g = g / np.max(g)\n    return g\n</pre> def gaussian2(x, membrane_dist, std1, std2):     mean1 = - membrane_dist / 2     mean2 = membrane_dist / 2     gaussian1 = gaussian_pdf(x, mean1, std1)     gaussian2 = gaussian_pdf(x, mean2, std2)     g = gaussian1 + gaussian2     g = g / np.max(g)     return g In\u00a0[\u00a0]: Copied! <pre>def bilinear_interpolation(image, x, y):\n    # Define the coordinates of the image\n    x_coords = np.arange(image.shape[1])\n    y_coords = np.arange(image.shape[0])\n    x_mesh, y_mesh = np.meshgrid(x_coords, y_coords)   \n    # Flatten the image and meshgrids\n    points = np.array([x_mesh.flatten(), y_mesh.flatten()]).T\n    values = image.flatten()\n    # Use griddata for interpolation\n    interpolated_values = griddata(points, values, (x, y), method='linear')\n    return interpolated_values\n</pre> def bilinear_interpolation(image, x, y):     # Define the coordinates of the image     x_coords = np.arange(image.shape[1])     y_coords = np.arange(image.shape[0])     x_mesh, y_mesh = np.meshgrid(x_coords, y_coords)        # Flatten the image and meshgrids     points = np.array([x_mesh.flatten(), y_mesh.flatten()]).T     values = image.flatten()     # Use griddata for interpolation     interpolated_values = griddata(points, values, (x, y), method='linear')     return interpolated_values In\u00a0[\u00a0]: Copied! <pre>def points_along_normal(control_points, t_values):\n    derivatives = np.array([bezier_curve_derivative(control_points, t) for t in t_values])\n    # Normalize the derivatives to get the unit tangent vectors\n    tangents = derivatives / np.linalg.norm(derivatives, axis=-1)[:, np.newaxis]\n    # Compute the normals from the tangents\n    normals = np.zeros_like(tangents)\n    normals[:, 0] = -tangents[:, 1]\n    normals[:, 1] = tangents[:, 0]\n    return normals\n</pre> def points_along_normal(control_points, t_values):     derivatives = np.array([bezier_curve_derivative(control_points, t) for t in t_values])     # Normalize the derivatives to get the unit tangent vectors     tangents = derivatives / np.linalg.norm(derivatives, axis=-1)[:, np.newaxis]     # Compute the normals from the tangents     normals = np.zeros_like(tangents)     normals[:, 0] = -tangents[:, 1]     normals[:, 1] = tangents[:, 0]     return normals In\u00a0[\u00a0]: Copied! <pre>def coarsefit_evaluate_individual(ind, obj, data_points):\n    return (obj.loss_function(np.array(ind), data_points),)\n</pre> def coarsefit_evaluate_individual(ind, obj, data_points):     return (obj.loss_function(np.array(ind), data_points),) In\u00a0[\u00a0]: Copied! <pre>def evaluate_individual(ind, obj, base_image):\n    # assert len(ind) == 8, f\"Unexpected length of individual: {len(ind)}\"\n    return (obj.cross_correlation_fitness(np.array(ind).reshape(obj.degree+1, 2), base_image, obj.penalty_threshold),)\n</pre> def evaluate_individual(ind, obj, base_image):     # assert len(ind) == 8, f\"Unexpected length of individual: {len(ind)}\"     return (obj.cross_correlation_fitness(np.array(ind).reshape(obj.degree+1, 2), base_image, obj.penalty_threshold),) In\u00a0[\u00a0]: Copied! <pre>def generate_curve_within_boundaries(control_points, image_shape, step):\n    t_values = []\n    t = 0\n\n    # Find the first t value within the image boundaries\n    while t &lt; 2:  # Limit to avoid infinite loop\n        point = bezier_curve(control_points, t)\n        if 0 &lt;= point[0] &lt; image_shape[0] and 0 &lt;= point[1] &lt; image_shape[1]:\n            t_values.append(t)\n            break\n        t += step\n\n    # Generate curve points moving forward\n    while True:\n        t += step\n        point = bezier_curve(control_points, t)\n        if 0 &lt;= point[0] &lt; image_shape[0] and 0 &lt;= point[1] &lt; image_shape[1]:\n            t_values.append(t)\n        else:\n            break\n\n    # Reset t to the initial point and generate curve points moving backward\n    t = t_values[0] - step\n    while t &gt; -2:  # Limit to avoid infinite loop\n        point = bezier_curve(control_points, t)\n        if 0 &lt;= point[0] &lt; image_shape[0] and 0 &lt;= point[1] &lt; image_shape[1]:\n            t_values.insert(0, t)  # Insert at the beginning\n            t -= step\n        else:\n            break\n    fitted_curve_points = np.array([bezier_curve(control_points, t_val) for t_val in t_values])\n    return np.array(fitted_curve_points), np.array(t_values)\n</pre> def generate_curve_within_boundaries(control_points, image_shape, step):     t_values = []     t = 0      # Find the first t value within the image boundaries     while t &lt; 2:  # Limit to avoid infinite loop         point = bezier_curve(control_points, t)         if 0 &lt;= point[0] &lt; image_shape[0] and 0 &lt;= point[1] &lt; image_shape[1]:             t_values.append(t)             break         t += step      # Generate curve points moving forward     while True:         t += step         point = bezier_curve(control_points, t)         if 0 &lt;= point[0] &lt; image_shape[0] and 0 &lt;= point[1] &lt; image_shape[1]:             t_values.append(t)         else:             break      # Reset t to the initial point and generate curve points moving backward     t = t_values[0] - step     while t &gt; -2:  # Limit to avoid infinite loop         point = bezier_curve(control_points, t)         if 0 &lt;= point[0] &lt; image_shape[0] and 0 &lt;= point[1] &lt; image_shape[1]:             t_values.insert(0, t)  # Insert at the beginning             t -= step         else:             break     fitted_curve_points = np.array([bezier_curve(control_points, t_val) for t_val in t_values])     return np.array(fitted_curve_points), np.array(t_values) In\u00a0[\u00a0]: Copied! <pre>class Coarsefit:\n    def __init__(self, image, num_points, degree, iteration):\n        self.image = image\n        self.num_points = num_points\n        self.img_sz = image.shape[0]\n        self.degree = degree\n        self.iteration = iteration\n    def __call__(self):\n        data_points = generate_data_points(self.image, self.num_points)\n        control_points = self.coarse_fitting_ga(data_points)\n        # t_values = np.linspace(-2, 2, 1000)\n        # fitted_curve_points = np.array([bezier_curve(control_points, t) for t in t_values])\n        # mask = (fitted_curve_points[:, 0] &gt;= 0) &amp; (fitted_curve_points[:, 0] &lt;= 256) &amp; (fitted_curve_points[:, 1] &gt;= 0) &amp; (fitted_curve_points[:, 1] &lt;= 256)\n        # fitted_curve_points = fitted_curve_points[mask]\n        # filtered_t_values = t_values[mask]\n        # t_values = np.linspace(min(filtered_t_values), max(filtered_t_values), 500)\n        # fitted_curve_points = np.array([bezier_curve(control_points, t) for t in t_values])\n        return control_points\n    def loss_function(self, control_points_flat, data_points):\n        control_points = control_points_flat.reshape(self.degree+1, 2)\n        t_values = np.linspace(0, 1, len(data_points))\n        curve_points = np.array([bezier_curve(control_points, t) for t in t_values])\n        return np.sum((curve_points - data_points) ** 2)\n    def coarse_fitting_ga(self, data_points):\n        creator.create(\"FitnessMin\", base.Fitness, weights=(-1.0,))\n        creator.create(\"Individual\", np.ndarray, fitness=creator.FitnessMin)\n        toolbox = base.Toolbox()\n        toolbox.register(\"attr_float\", np.random.uniform, -self.img_sz // 2, self.img_sz // 2)\n        toolbox.register(\"individual\", tools.initRepeat, creator.Individual, toolbox.attr_float, n=(self.degree+1)*2)  # \u56db\u4e2a\u63a7\u5236\u70b9\uff0c\u6bcf\u4e2a\u63a7\u5236\u70b9\u6709\u4e24\u4e2a\u5750\u6807\uff0c\u6240\u4ee5n=8\n        toolbox.register(\"population\", tools.initRepeat, list, toolbox.individual)\n        # toolbox.register(\"evaluate\", lambda ind: (self.loss_function(np.array(ind), data_points),))\n        toolbox.register(\"evaluate\", coarsefit_evaluate_individual, obj=self, data_points=data_points)\n        toolbox.register(\"mate\", tools.cxBlend, alpha=0.5)\n        toolbox.register(\"mutate\", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)\n        toolbox.register(\"select\", tools.selTournament, tournsize=5)\n        pop = toolbox.population(n=100)\n        stats = tools.Statistics(lambda ind: ind.fitness.values)\n        stats.register(\"avg\", np.mean)\n        stats.register(\"std\", np.std)\n        stats.register(\"min\", np.min)\n        stats.register(\"max\", np.max)\n        algorithms.eaSimple(pop, toolbox, cxpb=0.6, mutpb=0.3, ngen=self.iteration, \n                                stats=stats, halloffame=None, verbose=True)\n        # best_individual = tools.selBest(pop, 1)[0]\n        # best_control_points = np.array(best_individual).reshape(4, 2)\n        # print(\"Best Control Points:\")\n        # print(best_control_points)\n        best_ind = tools.selBest(pop, 1)[0]\n        return np.array(best_ind).reshape(self.degree+1, 2)\n</pre> class Coarsefit:     def __init__(self, image, num_points, degree, iteration):         self.image = image         self.num_points = num_points         self.img_sz = image.shape[0]         self.degree = degree         self.iteration = iteration     def __call__(self):         data_points = generate_data_points(self.image, self.num_points)         control_points = self.coarse_fitting_ga(data_points)         # t_values = np.linspace(-2, 2, 1000)         # fitted_curve_points = np.array([bezier_curve(control_points, t) for t in t_values])         # mask = (fitted_curve_points[:, 0] &gt;= 0) &amp; (fitted_curve_points[:, 0] &lt;= 256) &amp; (fitted_curve_points[:, 1] &gt;= 0) &amp; (fitted_curve_points[:, 1] &lt;= 256)         # fitted_curve_points = fitted_curve_points[mask]         # filtered_t_values = t_values[mask]         # t_values = np.linspace(min(filtered_t_values), max(filtered_t_values), 500)         # fitted_curve_points = np.array([bezier_curve(control_points, t) for t in t_values])         return control_points     def loss_function(self, control_points_flat, data_points):         control_points = control_points_flat.reshape(self.degree+1, 2)         t_values = np.linspace(0, 1, len(data_points))         curve_points = np.array([bezier_curve(control_points, t) for t in t_values])         return np.sum((curve_points - data_points) ** 2)     def coarse_fitting_ga(self, data_points):         creator.create(\"FitnessMin\", base.Fitness, weights=(-1.0,))         creator.create(\"Individual\", np.ndarray, fitness=creator.FitnessMin)         toolbox = base.Toolbox()         toolbox.register(\"attr_float\", np.random.uniform, -self.img_sz // 2, self.img_sz // 2)         toolbox.register(\"individual\", tools.initRepeat, creator.Individual, toolbox.attr_float, n=(self.degree+1)*2)  # \u56db\u4e2a\u63a7\u5236\u70b9\uff0c\u6bcf\u4e2a\u63a7\u5236\u70b9\u6709\u4e24\u4e2a\u5750\u6807\uff0c\u6240\u4ee5n=8         toolbox.register(\"population\", tools.initRepeat, list, toolbox.individual)         # toolbox.register(\"evaluate\", lambda ind: (self.loss_function(np.array(ind), data_points),))         toolbox.register(\"evaluate\", coarsefit_evaluate_individual, obj=self, data_points=data_points)         toolbox.register(\"mate\", tools.cxBlend, alpha=0.5)         toolbox.register(\"mutate\", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)         toolbox.register(\"select\", tools.selTournament, tournsize=5)         pop = toolbox.population(n=100)         stats = tools.Statistics(lambda ind: ind.fitness.values)         stats.register(\"avg\", np.mean)         stats.register(\"std\", np.std)         stats.register(\"min\", np.min)         stats.register(\"max\", np.max)         algorithms.eaSimple(pop, toolbox, cxpb=0.6, mutpb=0.3, ngen=self.iteration,                                  stats=stats, halloffame=None, verbose=True)         # best_individual = tools.selBest(pop, 1)[0]         # best_control_points = np.array(best_individual).reshape(4, 2)         # print(\"Best Control Points:\")         # print(best_control_points)         best_ind = tools.selBest(pop, 1)[0]         return np.array(best_ind).reshape(self.degree+1, 2) In\u00a0[\u00a0]: Copied! <pre>class GA_Refine:\n    def __init__(self, image, pixel_size, penalty_threshold, dithering_range, iterations):\n        self.image = image\n        self.img_sz = image.shape[0]\n        physical_membrane_dist = 35.0\n        self.pixel_size = pixel_size\n        self.penalty_threshold = penalty_threshold\n        self.mem_dist = int(physical_membrane_dist / self.pixel_size)\n        self.dithering_range = dithering_range\n        self.iterations = iterations\n\n    # def __call__(self, initial_control_points, image):\n    #     refined_control_points = self.ga_refine_controlpoints(image, initial_control_points)\n    #     t_values = np.linspace(-2, 2, 1000)\n    #     fitted_curve_points = np.array([bezier_curve(refined_control_points, t) for t in t_values])\n    #     mask = (fitted_curve_points[:, 0] &gt;= 0) &amp; (fitted_curve_points[:, 0] &lt;= self.img_sz) &amp; (fitted_curve_points[:, 1] &gt;= 0) &amp; (fitted_curve_points[:, 1] &lt;= self.img_sz)\n    #     fitted_curve_points = fitted_curve_points[mask]\n    #     filtered_t_values = t_values[mask]\n    #     t_values = np.linspace(min(filtered_t_values), max(filtered_t_values), 500)\n    #     fitted_curve_points = np.array([bezier_curve(refined_control_points, t) for t in t_values])\n    #     average_1d_lst = self.average_1d(image, fitted_curve_points, points_along_normal(refined_control_points, t_values), self.mem_dist)\n    #     return refined_control_points, average_1d_lst\n    def __call__(self, initial_control_points, image):\n        self.degree = len(initial_control_points) - 1\n        refined_control_points = self.ga_refine_controlpoints(image, initial_control_points)\n        return refined_control_points\n\n    # def average_1d(self, image, fitted_points, normals, extra_mem_dist):\n    #     average_1d_lst = []\n    #     for membrane_dist in range(-extra_mem_dist, extra_mem_dist+1):\n    #         normals_points = fitted_points + membrane_dist * normals\n    #         # Ensure the points are within the image boundaries\n    #         mask = (normals_points[:, 0] &gt;= 0) &amp; (normals_points[:, 0] &lt; image.shape[1]) &amp; \\\n    #             (normals_points[:, 1] &gt;= 0) &amp; (normals_points[:, 1] &lt; image.shape[0])\n    #         normals_points = normals_points[mask]\n    #         # Get interpolated gray values for the normal points\n    #         interpolated_values = bilinear_interpolation(image, normals_points[:, 0], normals_points[:, 1])\n    #         # convert nan to 0\n    #         interpolated_values = np.nan_to_num(interpolated_values)\n    #         average_1d_lst.append(np.mean(interpolated_values))\n    #     return average_1d_lst\n    def generate_2d_average(self, image, fitted_points, average_1d_lst, membrane_distance):\n        # Create an empty image of the same size as the original\n        new_image = np.zeros_like(image)\n\n        # Create a meshgrid for the image\n        y, x = np.mgrid[:image.shape[0], :image.shape[1]]\n        coords = np.stack((x, y), axis=-1).reshape(-1, 2)\n\n        # Calculate distances from each pixel to the fitted_curve_points\n        distances = cdist(coords, fitted_points)\n        min_distances = np.min(distances, axis=1).reshape(image.shape)\n        edge_sigma = 5\n        mask_within_distance = np.abs(min_distances) &lt;= membrane_distance\n        gray_value = np.exp(-(np.abs(min_distances) - membrane_distance)**2 / (2 * edge_sigma**2))\n        mask_small_gray_value = gray_value &lt; 0.001\n        mask_outside_distance = ~mask_within_distance\n        membrane_mask = np.zeros_like(min_distances)\n        membrane_mask[mask_within_distance] = 1\n        membrane_mask[mask_outside_distance &amp; ~mask_small_gray_value] = gray_value[mask_outside_distance &amp; ~mask_small_gray_value]\n\n        # Use the distances to interpolate values from average_1d_lst\n        f = interp1d(np.arange(-membrane_distance, membrane_distance+1), average_1d_lst, kind='linear', bounds_error=False, fill_value=0)\n        new_image = f(min_distances) * membrane_mask\n\n        return new_image, membrane_mask\n    \n    def cross_correlation_fitness(self, control_points, base_image, penalty_threshold):\n        fitted_curve_points, filtered_t_values = generate_curve_within_boundaries(control_points, base_image.shape, 0.01)\n        curvatures = [bezier_curvature(control_points, t) for t in filtered_t_values]\n        curvatures_abs = [abs(curvature) for curvature in curvatures]\n        control_points_out_of_bounds = [max(0, point[0] - self.img_sz, point[1] - self.img_sz, -point[0], -point[1]) for point in control_points]\n        control_points_penalty = sum([10*(2**out_of_bound) for out_of_bound in control_points_out_of_bounds])\n        if any(curvature &gt; penalty_threshold for curvature in curvatures_abs):\n            cur_penalty = 1e4*max(curvatures_abs)\n        else:\n            cur_penalty = 0\n        std = 3\n        new_image, membrane_mask = self.generate_2d_average(base_image, fitted_curve_points, gaussian2(np.arange(-self.mem_dist*2, self.mem_dist*2+1), self.mem_dist, std, std), self.mem_dist*2)\n        cc_value = correlate2d(new_image, base_image*membrane_mask, mode='valid')\n        return cc_value - cur_penalty - control_points_penalty\n    def custom_mutGaussian(self, individual, mu, sigma, indpb):\n        for i in range(len(individual)):\n            if random.random() &lt; indpb:\n                individual[i] += random.gauss(mu, sigma)\n        return individual,\n    def ga_refine_controlpoints(self, base_image, initial_control_points):\n        initial_control_points = np.array(initial_control_points)\n        creator.create(\"FitnessMax\", base.Fitness, weights=(1.0,))\n        creator.create(\"Individual\", list, fitness=creator.FitnessMax)\n        def attr_around_initial(index):\n            return initial_control_points.flatten()[index] + np.random.uniform(-self.dithering_range, self.dithering_range)\n        toolbox = base.Toolbox()\n        toolbox.register(\"attr_float\", attr_around_initial, index=np.arange((self.degree+1)*2))\n        toolbox.register(\"individual\", tools.initIterate, creator.Individual, toolbox.attr_float)\n        toolbox.register(\"population\", tools.initRepeat, list, toolbox.individual)\n        toolbox.register(\"evaluate\", evaluate_individual, obj = self, base_image = base_image)\n        toolbox.register(\"mate\", tools.cxUniform, indpb=0.5)\n        toolbox.register(\"mutate\", self.custom_mutGaussian, mu=0, sigma=1, indpb=0.2)\n        toolbox.register(\"select\", tools.selTournament, tournsize=5)\n        pop = toolbox.population(n=30)\n        pop.append(creator.Individual(initial_control_points.flatten()))\n\n        stats = tools.Statistics(lambda ind: ind.fitness.values)\n        stats.register(\"avg\", np.mean)\n        stats.register(\"std\", np.std)\n        stats.register(\"min\", np.min)\n        stats.register(\"max\", np.max)\n\n        algorithms.eaSimple(pop, toolbox, cxpb=0.6, mutpb=0.4, ngen=self.iterations, \n                                stats=stats, halloffame=None, verbose=True)\n        best_individual = tools.selBest(pop, 1)[0]\n        best_control_points = np.array(best_individual).reshape(self.degree+1, 2)\n        return best_control_points\n</pre> class GA_Refine:     def __init__(self, image, pixel_size, penalty_threshold, dithering_range, iterations):         self.image = image         self.img_sz = image.shape[0]         physical_membrane_dist = 35.0         self.pixel_size = pixel_size         self.penalty_threshold = penalty_threshold         self.mem_dist = int(physical_membrane_dist / self.pixel_size)         self.dithering_range = dithering_range         self.iterations = iterations      # def __call__(self, initial_control_points, image):     #     refined_control_points = self.ga_refine_controlpoints(image, initial_control_points)     #     t_values = np.linspace(-2, 2, 1000)     #     fitted_curve_points = np.array([bezier_curve(refined_control_points, t) for t in t_values])     #     mask = (fitted_curve_points[:, 0] &gt;= 0) &amp; (fitted_curve_points[:, 0] &lt;= self.img_sz) &amp; (fitted_curve_points[:, 1] &gt;= 0) &amp; (fitted_curve_points[:, 1] &lt;= self.img_sz)     #     fitted_curve_points = fitted_curve_points[mask]     #     filtered_t_values = t_values[mask]     #     t_values = np.linspace(min(filtered_t_values), max(filtered_t_values), 500)     #     fitted_curve_points = np.array([bezier_curve(refined_control_points, t) for t in t_values])     #     average_1d_lst = self.average_1d(image, fitted_curve_points, points_along_normal(refined_control_points, t_values), self.mem_dist)     #     return refined_control_points, average_1d_lst     def __call__(self, initial_control_points, image):         self.degree = len(initial_control_points) - 1         refined_control_points = self.ga_refine_controlpoints(image, initial_control_points)         return refined_control_points      # def average_1d(self, image, fitted_points, normals, extra_mem_dist):     #     average_1d_lst = []     #     for membrane_dist in range(-extra_mem_dist, extra_mem_dist+1):     #         normals_points = fitted_points + membrane_dist * normals     #         # Ensure the points are within the image boundaries     #         mask = (normals_points[:, 0] &gt;= 0) &amp; (normals_points[:, 0] &lt; image.shape[1]) &amp; \\     #             (normals_points[:, 1] &gt;= 0) &amp; (normals_points[:, 1] &lt; image.shape[0])     #         normals_points = normals_points[mask]     #         # Get interpolated gray values for the normal points     #         interpolated_values = bilinear_interpolation(image, normals_points[:, 0], normals_points[:, 1])     #         # convert nan to 0     #         interpolated_values = np.nan_to_num(interpolated_values)     #         average_1d_lst.append(np.mean(interpolated_values))     #     return average_1d_lst     def generate_2d_average(self, image, fitted_points, average_1d_lst, membrane_distance):         # Create an empty image of the same size as the original         new_image = np.zeros_like(image)          # Create a meshgrid for the image         y, x = np.mgrid[:image.shape[0], :image.shape[1]]         coords = np.stack((x, y), axis=-1).reshape(-1, 2)          # Calculate distances from each pixel to the fitted_curve_points         distances = cdist(coords, fitted_points)         min_distances = np.min(distances, axis=1).reshape(image.shape)         edge_sigma = 5         mask_within_distance = np.abs(min_distances) &lt;= membrane_distance         gray_value = np.exp(-(np.abs(min_distances) - membrane_distance)**2 / (2 * edge_sigma**2))         mask_small_gray_value = gray_value &lt; 0.001         mask_outside_distance = ~mask_within_distance         membrane_mask = np.zeros_like(min_distances)         membrane_mask[mask_within_distance] = 1         membrane_mask[mask_outside_distance &amp; ~mask_small_gray_value] = gray_value[mask_outside_distance &amp; ~mask_small_gray_value]          # Use the distances to interpolate values from average_1d_lst         f = interp1d(np.arange(-membrane_distance, membrane_distance+1), average_1d_lst, kind='linear', bounds_error=False, fill_value=0)         new_image = f(min_distances) * membrane_mask          return new_image, membrane_mask          def cross_correlation_fitness(self, control_points, base_image, penalty_threshold):         fitted_curve_points, filtered_t_values = generate_curve_within_boundaries(control_points, base_image.shape, 0.01)         curvatures = [bezier_curvature(control_points, t) for t in filtered_t_values]         curvatures_abs = [abs(curvature) for curvature in curvatures]         control_points_out_of_bounds = [max(0, point[0] - self.img_sz, point[1] - self.img_sz, -point[0], -point[1]) for point in control_points]         control_points_penalty = sum([10*(2**out_of_bound) for out_of_bound in control_points_out_of_bounds])         if any(curvature &gt; penalty_threshold for curvature in curvatures_abs):             cur_penalty = 1e4*max(curvatures_abs)         else:             cur_penalty = 0         std = 3         new_image, membrane_mask = self.generate_2d_average(base_image, fitted_curve_points, gaussian2(np.arange(-self.mem_dist*2, self.mem_dist*2+1), self.mem_dist, std, std), self.mem_dist*2)         cc_value = correlate2d(new_image, base_image*membrane_mask, mode='valid')         return cc_value - cur_penalty - control_points_penalty     def custom_mutGaussian(self, individual, mu, sigma, indpb):         for i in range(len(individual)):             if random.random() &lt; indpb:                 individual[i] += random.gauss(mu, sigma)         return individual,     def ga_refine_controlpoints(self, base_image, initial_control_points):         initial_control_points = np.array(initial_control_points)         creator.create(\"FitnessMax\", base.Fitness, weights=(1.0,))         creator.create(\"Individual\", list, fitness=creator.FitnessMax)         def attr_around_initial(index):             return initial_control_points.flatten()[index] + np.random.uniform(-self.dithering_range, self.dithering_range)         toolbox = base.Toolbox()         toolbox.register(\"attr_float\", attr_around_initial, index=np.arange((self.degree+1)*2))         toolbox.register(\"individual\", tools.initIterate, creator.Individual, toolbox.attr_float)         toolbox.register(\"population\", tools.initRepeat, list, toolbox.individual)         toolbox.register(\"evaluate\", evaluate_individual, obj = self, base_image = base_image)         toolbox.register(\"mate\", tools.cxUniform, indpb=0.5)         toolbox.register(\"mutate\", self.custom_mutGaussian, mu=0, sigma=1, indpb=0.2)         toolbox.register(\"select\", tools.selTournament, tournsize=5)         pop = toolbox.population(n=30)         pop.append(creator.Individual(initial_control_points.flatten()))          stats = tools.Statistics(lambda ind: ind.fitness.values)         stats.register(\"avg\", np.mean)         stats.register(\"std\", np.std)         stats.register(\"min\", np.min)         stats.register(\"max\", np.max)          algorithms.eaSimple(pop, toolbox, cxpb=0.6, mutpb=0.4, ngen=self.iterations,                                  stats=stats, halloffame=None, verbose=True)         best_individual = tools.selBest(pop, 1)[0]         best_control_points = np.array(best_individual).reshape(self.degree+1, 2)         return best_control_points In\u00a0[\u00a0]: Copied! <pre>class MemAverage:\n    def __init__(self, image, control_points, pixel_size):\n        self.image = image\n        self.control_points = control_points\n        self.pixel_size = pixel_size\n        physical_membrane_dist = 35.0\n        self.mem_dist = int(physical_membrane_dist / self.pixel_size)\n    def generate_2d_mask(self, image, fitted_points, membrane_distance):\n        y, x = np.mgrid[:image.shape[0], :image.shape[1]]\n        coords = np.stack((x, y), axis=-1).reshape(-1, 2)\n        distances = cdist(coords, fitted_points)\n        min_distances = np.min(distances, axis=1).reshape(image.shape)\n        edge_sigma = 5\n        mask_within_distance = np.abs(min_distances) &lt;= membrane_distance\n        gray_value = np.exp(-(np.abs(min_distances) - membrane_distance)**2 / (2 * edge_sigma**2))\n        mask_small_gray_value = gray_value &lt; 0.001\n        mask_outside_distance = ~mask_within_distance\n        membrane_mask = np.zeros_like(min_distances)\n        membrane_mask[mask_within_distance] = 1\n        membrane_mask[mask_outside_distance &amp; ~mask_small_gray_value] = gray_value[mask_outside_distance &amp; ~mask_small_gray_value]\n        return membrane_mask\n    def average_1d(self, image, fitted_points, normals, extra_mem_dist):\n        average_1d_lst = []\n        for membrane_dist in range(-extra_mem_dist, extra_mem_dist+1):\n            normals_points = fitted_points + membrane_dist * normals\n            # Ensure the points are within the image boundaries\n            mask = (normals_points[:, 0] &gt;= 0) &amp; (normals_points[:, 0] &lt; image.shape[1]) &amp; \\\n                (normals_points[:, 1] &gt;= 0) &amp; (normals_points[:, 1] &lt; image.shape[0])\n            normals_points = normals_points[mask]\n            # Get interpolated gray values for the normal points\n            interpolated_values = bilinear_interpolation(image, normals_points[:, 0], normals_points[:, 1])\n            # convert nan to 0\n            interpolated_values = np.nan_to_num(interpolated_values)\n            average_1d_lst.append(np.mean(interpolated_values))\n        return average_1d_lst\n\n    def average_2d(self, image, fitted_points, normals, average_1d_lst, extra_mem_dist):\n        new_image = np.zeros_like(image)\n        count_image = np.zeros_like(image)\n        def distribute_bilinearly(image, count_image, x, y, value):\n            x1, y1 = int(x), int(y)\n            x2, y2 = x1 + 1, y1 + 1\n            if x2 &gt;= image.shape[1] or y2 &gt;= image.shape[0]:\n                image[y1, x1] += value  # \u5982\u679c\u8d85\u51fa\u8303\u56f4\uff0c\u5168\u90e8\u5206\u7ed9\u6700\u8fd1\u7684\u50cf\u7d20\n                count_image[y1, x1] += 1\n                return\n            # \u8ba1\u7b97\u53cc\u7ebf\u6027\u6743\u91cd\n            w11 = (x2 - x) * (y2 - y)\n            w21 = (x - x1) * (y2 - y)\n            w12 = (x2 - x) * (y - y1)\n            w22 = (x - x1) * (y - y1)\n            # \u5c06 value \u5206\u914d\u5230\u56db\u4e2a\u90bb\u8fd1\u50cf\u7d20\u4e0a\n            image[y1, x1] += value * w11\n            image[y1, x2] += value * w21\n            image[y2, x1] += value * w12\n            image[y2, x2] += value * w22\n            count_image[y1, x1] += w11\n            count_image[y1, x2] += w21\n            count_image[y2, x1] += w12\n            count_image[y2, x2] += w22\n        for membrane_dist, average_1d in zip(range(-extra_mem_dist, extra_mem_dist+1), average_1d_lst):\n            normals_points = fitted_points + membrane_dist * normals\n            # Ensure the points are within the image boundaries\n            mask = (normals_points[:, 0] &gt;= 0) &amp; (normals_points[:, 0] &lt; image.shape[1]) &amp; \\\n                (normals_points[:, 1] &gt;= 0) &amp; (normals_points[:, 1] &lt; image.shape[0])\n            normals_points = normals_points[mask]\n            # Give the normal points the average gray value with interpolation\n            for point in normals_points:\n                distribute_bilinearly(new_image, count_image, point[0], point[1], average_1d)\n            # Normalize the new_image by the count_image\n        with np.errstate(divide='ignore', invalid='ignore'):\n            new_image /= count_image\n            new_image[np.isnan(new_image)] = 0\n        return new_image.astype(image.dtype)\n    def mem_average(self):\n        fitted_curve_points, t_values = generate_curve_within_boundaries(self.control_points, self.image.shape, 0.001)\n        mem_mask = self.generate_2d_mask(self.image, fitted_curve_points, self.mem_dist)\n        extra_mem_dist = 10\n        average_1d_lst = self.average_1d(self.image, fitted_curve_points, points_along_normal(self.control_points, t_values), self.mem_dist+extra_mem_dist)\n        image_average_2d = self.average_2d(self.image, fitted_curve_points, points_along_normal(self.control_points, t_values), average_1d_lst, self.mem_dist+extra_mem_dist)\n        return mem_mask, image_average_2d\n</pre> class MemAverage:     def __init__(self, image, control_points, pixel_size):         self.image = image         self.control_points = control_points         self.pixel_size = pixel_size         physical_membrane_dist = 35.0         self.mem_dist = int(physical_membrane_dist / self.pixel_size)     def generate_2d_mask(self, image, fitted_points, membrane_distance):         y, x = np.mgrid[:image.shape[0], :image.shape[1]]         coords = np.stack((x, y), axis=-1).reshape(-1, 2)         distances = cdist(coords, fitted_points)         min_distances = np.min(distances, axis=1).reshape(image.shape)         edge_sigma = 5         mask_within_distance = np.abs(min_distances) &lt;= membrane_distance         gray_value = np.exp(-(np.abs(min_distances) - membrane_distance)**2 / (2 * edge_sigma**2))         mask_small_gray_value = gray_value &lt; 0.001         mask_outside_distance = ~mask_within_distance         membrane_mask = np.zeros_like(min_distances)         membrane_mask[mask_within_distance] = 1         membrane_mask[mask_outside_distance &amp; ~mask_small_gray_value] = gray_value[mask_outside_distance &amp; ~mask_small_gray_value]         return membrane_mask     def average_1d(self, image, fitted_points, normals, extra_mem_dist):         average_1d_lst = []         for membrane_dist in range(-extra_mem_dist, extra_mem_dist+1):             normals_points = fitted_points + membrane_dist * normals             # Ensure the points are within the image boundaries             mask = (normals_points[:, 0] &gt;= 0) &amp; (normals_points[:, 0] &lt; image.shape[1]) &amp; \\                 (normals_points[:, 1] &gt;= 0) &amp; (normals_points[:, 1] &lt; image.shape[0])             normals_points = normals_points[mask]             # Get interpolated gray values for the normal points             interpolated_values = bilinear_interpolation(image, normals_points[:, 0], normals_points[:, 1])             # convert nan to 0             interpolated_values = np.nan_to_num(interpolated_values)             average_1d_lst.append(np.mean(interpolated_values))         return average_1d_lst      def average_2d(self, image, fitted_points, normals, average_1d_lst, extra_mem_dist):         new_image = np.zeros_like(image)         count_image = np.zeros_like(image)         def distribute_bilinearly(image, count_image, x, y, value):             x1, y1 = int(x), int(y)             x2, y2 = x1 + 1, y1 + 1             if x2 &gt;= image.shape[1] or y2 &gt;= image.shape[0]:                 image[y1, x1] += value  # \u5982\u679c\u8d85\u51fa\u8303\u56f4\uff0c\u5168\u90e8\u5206\u7ed9\u6700\u8fd1\u7684\u50cf\u7d20                 count_image[y1, x1] += 1                 return             # \u8ba1\u7b97\u53cc\u7ebf\u6027\u6743\u91cd             w11 = (x2 - x) * (y2 - y)             w21 = (x - x1) * (y2 - y)             w12 = (x2 - x) * (y - y1)             w22 = (x - x1) * (y - y1)             # \u5c06 value \u5206\u914d\u5230\u56db\u4e2a\u90bb\u8fd1\u50cf\u7d20\u4e0a             image[y1, x1] += value * w11             image[y1, x2] += value * w21             image[y2, x1] += value * w12             image[y2, x2] += value * w22             count_image[y1, x1] += w11             count_image[y1, x2] += w21             count_image[y2, x1] += w12             count_image[y2, x2] += w22         for membrane_dist, average_1d in zip(range(-extra_mem_dist, extra_mem_dist+1), average_1d_lst):             normals_points = fitted_points + membrane_dist * normals             # Ensure the points are within the image boundaries             mask = (normals_points[:, 0] &gt;= 0) &amp; (normals_points[:, 0] &lt; image.shape[1]) &amp; \\                 (normals_points[:, 1] &gt;= 0) &amp; (normals_points[:, 1] &lt; image.shape[0])             normals_points = normals_points[mask]             # Give the normal points the average gray value with interpolation             for point in normals_points:                 distribute_bilinearly(new_image, count_image, point[0], point[1], average_1d)             # Normalize the new_image by the count_image         with np.errstate(divide='ignore', invalid='ignore'):             new_image /= count_image             new_image[np.isnan(new_image)] = 0         return new_image.astype(image.dtype)     def mem_average(self):         fitted_curve_points, t_values = generate_curve_within_boundaries(self.control_points, self.image.shape, 0.001)         mem_mask = self.generate_2d_mask(self.image, fitted_curve_points, self.mem_dist)         extra_mem_dist = 10         average_1d_lst = self.average_1d(self.image, fitted_curve_points, points_along_normal(self.control_points, t_values), self.mem_dist+extra_mem_dist)         image_average_2d = self.average_2d(self.image, fitted_curve_points, points_along_normal(self.control_points, t_values), average_1d_lst, self.mem_dist+extra_mem_dist)         return mem_mask, image_average_2d"},{"location":"tutorials/reference/src/calculate_curve/","title":"Calculate curve","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom ._utils import *\nfrom .template_centerfitting import *\nfrom .radon_analyser import *\nfrom .circle_mask_generator import *\nfrom scipy.signal import correlate2d\n</pre> import numpy as np import matplotlib.pyplot as plt from ._utils import * from .template_centerfitting import * from .radon_analyser import * from .circle_mask_generator import * from scipy.signal import correlate2d In\u00a0[\u00a0]: Copied! <pre>class Curve:\n    def __init__(self, image, y0, x0, theta, kappa, rlnSigma1, rlnSigma2, rlnMembraneDistance):\n        self.y0 = y0\n        self.x0 = x0\n        self.theta = theta\n        self.gray_image = image\n        self.image_size = image.shape[0]\n        self.sigma1, self.sigma2 = rlnSigma1, rlnSigma2\n        self.kappa = kappa\n        self.x_c = 0\n        self.y_c = 0\n        self.R = 0\n        self.membrane_distance = rlnMembraneDistance\n        self.distance_matrix = np.zeros((self.image_size, self.image_size))\n        self.simulate_membrane = np.zeros((self.image_size, self.image_size))\n    def compute(self):\n        if self.kappa == 0:\n            return self.compute_line_dist()\n        else:\n            return self.compute_arc_dist()\n    def compute_arc_center(self):\n        self.R = 1 / np.abs(self.kappa) if self.kappa != 0 else np.inf\n        if self.kappa &gt;= 0:\n            self.x_c = self.x0 - self.R * np.sin(self.theta)\n            self.y_c = self.y0 + self.R * np.cos(self.theta)\n        else:\n            self.x_c = self.x0 + self.R * np.sin(self.theta)\n            self.y_c = self.y0 - self.R * np.cos(self.theta)\n        return self.x_c, self.y_c\n    def if_in_arc(self, x_temp, y_temp):\n        x_c, y_c = self.compute_arc_center()\n        d = distance(x_c, y_c, x_temp, y_temp)\n        if d &lt;= self.R:\n            return True\n        else:\n            return False\n    def compute_arc_dist(self):\n        x_c, y_c = self.compute_arc_center()\n        x = range(self.image_size)\n        y = range(self.image_size)\n        for i in x:\n            for j in y:\n                distance_temp = distance(x_c, y_c, i, j) - self.R\n                self.distance_matrix[i, j] = distance_temp\n        return self.distance_matrix\n    def compute_line_dist(self):\n        x = range(self.image_size)\n        y = range(self.image_size)\n        if np.isclose(self.theta, np.pi/2) or np.isclose(self.theta, 3*np.pi/2):\n            for i in x:\n                for j in y:\n                    self.distance_matrix[i, j] = i - self.x0\n            return self.distance_matrix\n        else:\n            k = np.tan(self.theta)\n            b = self.y0 - k * self.x0\n            for i in x:\n                for j in y:\n                    self.distance_matrix[i, j] = (k * i - j + b) / np.sqrt(k**2 + 1)\n            return self.distance_matrix\n    def generate_membrane(self):\n        self.distance_matrix = self.compute()\n        if self.kappa &gt;= 0:\n            self.distance_matrix = -self.distance_matrix\n        self.simulate_membrane = gaussian2(self.distance_matrix, self.membrane_distance, self.sigma1, self.sigma2)\n        return self.simulate_membrane\n</pre> class Curve:     def __init__(self, image, y0, x0, theta, kappa, rlnSigma1, rlnSigma2, rlnMembraneDistance):         self.y0 = y0         self.x0 = x0         self.theta = theta         self.gray_image = image         self.image_size = image.shape[0]         self.sigma1, self.sigma2 = rlnSigma1, rlnSigma2         self.kappa = kappa         self.x_c = 0         self.y_c = 0         self.R = 0         self.membrane_distance = rlnMembraneDistance         self.distance_matrix = np.zeros((self.image_size, self.image_size))         self.simulate_membrane = np.zeros((self.image_size, self.image_size))     def compute(self):         if self.kappa == 0:             return self.compute_line_dist()         else:             return self.compute_arc_dist()     def compute_arc_center(self):         self.R = 1 / np.abs(self.kappa) if self.kappa != 0 else np.inf         if self.kappa &gt;= 0:             self.x_c = self.x0 - self.R * np.sin(self.theta)             self.y_c = self.y0 + self.R * np.cos(self.theta)         else:             self.x_c = self.x0 + self.R * np.sin(self.theta)             self.y_c = self.y0 - self.R * np.cos(self.theta)         return self.x_c, self.y_c     def if_in_arc(self, x_temp, y_temp):         x_c, y_c = self.compute_arc_center()         d = distance(x_c, y_c, x_temp, y_temp)         if d &lt;= self.R:             return True         else:             return False     def compute_arc_dist(self):         x_c, y_c = self.compute_arc_center()         x = range(self.image_size)         y = range(self.image_size)         for i in x:             for j in y:                 distance_temp = distance(x_c, y_c, i, j) - self.R                 self.distance_matrix[i, j] = distance_temp         return self.distance_matrix     def compute_line_dist(self):         x = range(self.image_size)         y = range(self.image_size)         if np.isclose(self.theta, np.pi/2) or np.isclose(self.theta, 3*np.pi/2):             for i in x:                 for j in y:                     self.distance_matrix[i, j] = i - self.x0             return self.distance_matrix         else:             k = np.tan(self.theta)             b = self.y0 - k * self.x0             for i in x:                 for j in y:                     self.distance_matrix[i, j] = (k * i - j + b) / np.sqrt(k**2 + 1)             return self.distance_matrix     def generate_membrane(self):         self.distance_matrix = self.compute()         if self.kappa &gt;= 0:             self.distance_matrix = -self.distance_matrix         self.simulate_membrane = gaussian2(self.distance_matrix, self.membrane_distance, self.sigma1, self.sigma2)         return self.simulate_membrane In\u00a0[\u00a0]: Copied! <pre>class Curvefitting:\n    def __init__(self, image, kappa_start, kappa_end, kappa_step, rlnCenterX, rlnCenterY, rlnAngleTheta, rlnMembraneDistance, rlnSigma1, rlnSigma2):\n        num = int((kappa_end - kappa_start) / kappa_step) + 1\n        self.kappa_lst = np.linspace(kappa_start, kappa_end, num)\n        self.corr_lst = []\n        self.yc, self.xc = rlnCenterX, rlnCenterY\n        self.sigma1, self.sigma2 = rlnSigma1, rlnSigma2\n        self.gray_image = image\n        self.image_size = image.shape[0]\n        self.membrane_distance = rlnMembraneDistance\n        self.theta = rlnAngleTheta * np.pi / 180\n        self.best_kappa = None\n\n    def generate_membrane(self, kappa):\n        gene_curve = Curve(self.gray_image, self.yc, self.xc, self.theta, kappa, self.sigma1, self.sigma2, self.membrane_distance)\n        self.simulated_membrane = gene_curve.generate_membrane()\n        return self.simulated_membrane\n    \n    def fit_curve(self):\n        i = 0\n        print('Start curve fitting...')\n        for kappa in self.kappa_lst:\n            # print(f'=====iter: {i}=====')\n            self.simulated_membrane  = self.generate_membrane(kappa)\n            self.simulated_membrane = self.simulated_membrane.astype(np.float64)\n            self.gray_image = self.gray_image.astype(np.float64)\n            self.simulated_membrane = (self.simulated_membrane - np.mean(self.simulated_membrane)) / np.std(self.simulated_membrane)\n            radius = (self.image_size/2) * 0.9\n            circle_masker = circle_mask(self.simulated_membrane, x0=self.image_size/2, y0=self.image_size/2, radius=radius, sigma=3)\n            self.simulated_membrane = circle_masker.apply_mask()\n            self.gray_image = (self.gray_image - np.mean(self.gray_image)) / np.std(self.gray_image)\n            correlation_result = correlate2d(self.simulated_membrane, self.gray_image, mode='full')\n            corr_score = np.max(correlation_result)\n            self.corr_lst.append(corr_score)\n            print(f'iter{i} finished, kappa: {kappa}, corr_score: {corr_score}')\n            i += 1\n        self.corr_max = max(self.corr_lst)\n        self.corr_max_index = self.corr_lst.index(self.corr_max)\n        self.best_kappa = self.kappa_lst[self.corr_max_index]\n        print('Best kappa:', self.best_kappa)\n        self.mem_best = self.generate_membrane(self.best_kappa)\n        return self.best_kappa\n    def fit_curve_visualize(self):\n        fig, axes = plt.subplots(1, 3, figsize=(10, 5))\n        axes[0].set_title('CC Score')\n        axes[0].plot(self.kappa_lst, self.corr_lst, 'x', color = 'red')\n        axes[1].set_title('Original Image')\n        axes[1].imshow(self.gray_image, cmap='gray', origin='lower')\n        axes[2].set_title('Membrane with Best Kappa')\n        axes[2].imshow(self.mem_best, cmap='gray', origin='lower')\n        \n        plt.show()\n</pre> class Curvefitting:     def __init__(self, image, kappa_start, kappa_end, kappa_step, rlnCenterX, rlnCenterY, rlnAngleTheta, rlnMembraneDistance, rlnSigma1, rlnSigma2):         num = int((kappa_end - kappa_start) / kappa_step) + 1         self.kappa_lst = np.linspace(kappa_start, kappa_end, num)         self.corr_lst = []         self.yc, self.xc = rlnCenterX, rlnCenterY         self.sigma1, self.sigma2 = rlnSigma1, rlnSigma2         self.gray_image = image         self.image_size = image.shape[0]         self.membrane_distance = rlnMembraneDistance         self.theta = rlnAngleTheta * np.pi / 180         self.best_kappa = None      def generate_membrane(self, kappa):         gene_curve = Curve(self.gray_image, self.yc, self.xc, self.theta, kappa, self.sigma1, self.sigma2, self.membrane_distance)         self.simulated_membrane = gene_curve.generate_membrane()         return self.simulated_membrane          def fit_curve(self):         i = 0         print('Start curve fitting...')         for kappa in self.kappa_lst:             # print(f'=====iter: {i}=====')             self.simulated_membrane  = self.generate_membrane(kappa)             self.simulated_membrane = self.simulated_membrane.astype(np.float64)             self.gray_image = self.gray_image.astype(np.float64)             self.simulated_membrane = (self.simulated_membrane - np.mean(self.simulated_membrane)) / np.std(self.simulated_membrane)             radius = (self.image_size/2) * 0.9             circle_masker = circle_mask(self.simulated_membrane, x0=self.image_size/2, y0=self.image_size/2, radius=radius, sigma=3)             self.simulated_membrane = circle_masker.apply_mask()             self.gray_image = (self.gray_image - np.mean(self.gray_image)) / np.std(self.gray_image)             correlation_result = correlate2d(self.simulated_membrane, self.gray_image, mode='full')             corr_score = np.max(correlation_result)             self.corr_lst.append(corr_score)             print(f'iter{i} finished, kappa: {kappa}, corr_score: {corr_score}')             i += 1         self.corr_max = max(self.corr_lst)         self.corr_max_index = self.corr_lst.index(self.corr_max)         self.best_kappa = self.kappa_lst[self.corr_max_index]         print('Best kappa:', self.best_kappa)         self.mem_best = self.generate_membrane(self.best_kappa)         return self.best_kappa     def fit_curve_visualize(self):         fig, axes = plt.subplots(1, 3, figsize=(10, 5))         axes[0].set_title('CC Score')         axes[0].plot(self.kappa_lst, self.corr_lst, 'x', color = 'red')         axes[1].set_title('Original Image')         axes[1].imshow(self.gray_image, cmap='gray', origin='lower')         axes[2].set_title('Membrane with Best Kappa')         axes[2].imshow(self.mem_best, cmap='gray', origin='lower')                  plt.show()"},{"location":"tutorials/reference/src/circle_mask_generator/","title":"Circle mask generator","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom ._utils import *\n</pre> import numpy as np import matplotlib.pyplot as plt from ._utils import * In\u00a0[\u00a0]: Copied! <pre>class circle_mask:\n    def __init__(self, image_array, x0, y0, radius, sigma):\n        self.image = image_array\n        self.image_size = self.image.shape[0]\n        self.x0 = x0\n        self.y0 = y0\n        self.radius = radius\n        self.sigma = sigma\n        self.distance_matrix = np.zeros((self.image_size, self.image_size))\n        self.mask = np.zeros((self.image_size, self.image_size))\n    def calculate_distance(self):\n        Y, X = np.meshgrid(np.arange(self.image_size), np.arange(self.image_size))\n        self.distance_matrix = np.sqrt((X - self.x0)**2 + (Y - self.y0)**2) - self.radius\n        return self.distance_matrix\n    def generate_mask(self):\n        mask_positive = self.distance_matrix &lt;= 0\n        self.mask = np.where(mask_positive, 1, np.exp(-self.distance_matrix**2 / (2 * self.sigma**2)))\n        return self.mask\n\n    def apply_mask(self):\n        self.distance_matrix = self.calculate_distance()\n        self.mask = self.generate_mask()\n        self.masked_image = self.image * self.mask\n        return self.masked_image\n    def visualize_mask(self):\n        plt.imshow(self.masked_image, cmap='gray')\n        plt.show()\n</pre> class circle_mask:     def __init__(self, image_array, x0, y0, radius, sigma):         self.image = image_array         self.image_size = self.image.shape[0]         self.x0 = x0         self.y0 = y0         self.radius = radius         self.sigma = sigma         self.distance_matrix = np.zeros((self.image_size, self.image_size))         self.mask = np.zeros((self.image_size, self.image_size))     def calculate_distance(self):         Y, X = np.meshgrid(np.arange(self.image_size), np.arange(self.image_size))         self.distance_matrix = np.sqrt((X - self.x0)**2 + (Y - self.y0)**2) - self.radius         return self.distance_matrix     def generate_mask(self):         mask_positive = self.distance_matrix &lt;= 0         self.mask = np.where(mask_positive, 1, np.exp(-self.distance_matrix**2 / (2 * self.sigma**2)))         return self.mask      def apply_mask(self):         self.distance_matrix = self.calculate_distance()         self.mask = self.generate_mask()         self.masked_image = self.image * self.mask         return self.masked_image     def visualize_mask(self):         plt.imshow(self.masked_image, cmap='gray')         plt.show()"},{"location":"tutorials/reference/src/generate_gaussian_template/","title":"Generate gaussian template","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nfrom scipy.stats import norm\nfrom ._utils import *\n</pre> import numpy as np from scipy.stats import norm from ._utils import * In\u00a0[\u00a0]: Copied! <pre>def gaussian_pdf(x, mean, std):\n    coefficient = 1.0 / (std * np.sqrt(2 * np.pi))\n    exponential = np.exp(- (x - mean) ** 2 / (2 * std ** 2))\n    return coefficient * exponential\n</pre> def gaussian_pdf(x, mean, std):     coefficient = 1.0 / (std * np.sqrt(2 * np.pi))     exponential = np.exp(- (x - mean) ** 2 / (2 * std ** 2))     return coefficient * exponential In\u00a0[\u00a0]: Copied! <pre>def gaussian2(x, membrane_dist, std1, std2):\n    mean1 = - membrane_dist / 2\n    mean2 = membrane_dist / 2\n    gaussian1 = norm.pdf(x, mean1, std1)\n    gaussian2 = norm.pdf(x, mean2, std2)\n    g = gaussian1 + gaussian2\n    g = g / np.sum(g)\n    g = g * 255\n    return g\n</pre> def gaussian2(x, membrane_dist, std1, std2):     mean1 = - membrane_dist / 2     mean2 = membrane_dist / 2     gaussian1 = norm.pdf(x, mean1, std1)     gaussian2 = norm.pdf(x, mean2, std2)     g = gaussian1 + gaussian2     g = g / np.sum(g)     g = g * 255     return g In\u00a0[\u00a0]: Copied! <pre>def generate_template(size, theta, membrane_dist, std1, std2):\n    distance_matrix = np.zeros((size, size))\n    theta = (theta - 90) * np.pi / 180\n    x = range(size)\n    y = range(size)\n    x0 = size / 2\n    y0 = size / 2\n    if np.isclose(theta, np.pi/2) or np.isclose(theta, 3*np.pi/2):\n        for i in x:\n            for j in y:\n                distance_matrix[i, j] = i - x0\n    else:\n        k = np.tan(theta)\n        b = y0 - k * x0\n        for i in x:\n            for j in y:\n                distance_matrix[i, j] = (k * i - j + b) / np.sqrt(k**2 + 1)\n    template = gaussian2(-distance_matrix, membrane_dist, std1, std2)\n    return template\n</pre> def generate_template(size, theta, membrane_dist, std1, std2):     distance_matrix = np.zeros((size, size))     theta = (theta - 90) * np.pi / 180     x = range(size)     y = range(size)     x0 = size / 2     y0 = size / 2     if np.isclose(theta, np.pi/2) or np.isclose(theta, 3*np.pi/2):         for i in x:             for j in y:                 distance_matrix[i, j] = i - x0     else:         k = np.tan(theta)         b = y0 - k * x0         for i in x:             for j in y:                 distance_matrix[i, j] = (k * i - j + b) / np.sqrt(k**2 + 1)     template = gaussian2(-distance_matrix, membrane_dist, std1, std2)     return template"},{"location":"tutorials/reference/src/generate_membrane_mask/","title":"Generate membrane mask","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom ._utils import *\nfrom .template_centerfitting import *\nfrom .radon_analyser import *\nfrom .calculate_curve import *\n</pre> import numpy as np import matplotlib.pyplot as plt from ._utils import * from .template_centerfitting import * from .radon_analyser import * from .calculate_curve import * In\u00a0[\u00a0]: Copied! <pre>class mem_mask:\n    def __init__(self, image, edge_sigma, rlnSigma1, rlnSigma2, rlnMembraneDistance, rlnCurveKappa, rlnAngleTheta, rlnCenterX, rlnCenterY):\n        self.gray_image = image\n        self.edge_sigma = edge_sigma\n        self.x0, self.y0 = rlnCenterY, rlnCenterX\n        self.theta = rlnAngleTheta * np.pi / 180\n        self.membrane_distance = rlnMembraneDistance\n        self.kappa = rlnCurveKappa\n        self.sigma1, self.sigma2 = rlnSigma1, rlnSigma2\n        self.edge_sigma = edge_sigma\n        self.image_size = image.shape[0]\n        self.distance_mat = np.zeros((self.image_size, self.image_size))\n        self.membrane_mask = np.zeros((self.image_size, self.image_size))\n        self.masked_image = np.zeros((self.image_size, self.image_size))\n    def compute_dist_mat(self):\n        curve_generator = Curve(self.gray_image, self.y0, self.x0, self.theta, self.kappa, self.sigma1, self.sigma2, self.membrane_distance)\n        self.distance_mat = curve_generator.compute()\n        return self.distance_mat\n    def generate_mem_mask(self):\n        distance_mat_gpu = self.compute_dist_mat()\n        mask_within_distance = np.abs(distance_mat_gpu) &lt;= self.membrane_distance\n        gray_value = np.exp(-(np.abs(distance_mat_gpu) - self.membrane_distance)**2 / (2 * self.edge_sigma**2))\n        mask_small_gray_value = gray_value &lt; 0.001\n        mask_outside_distance = ~mask_within_distance\n        membrane_mask = np.zeros_like(distance_mat_gpu)\n        membrane_mask[mask_within_distance] = 1\n        membrane_mask[mask_outside_distance &amp; ~mask_small_gray_value] = gray_value[mask_outside_distance &amp; ~mask_small_gray_value]\n        self.membrane_mask = membrane_mask\n        return self.membrane_mask\n    # def apply_mem_mask(self):\n    #     self.membrane_mask = self.generate_mem_mask()\n    #     self.masked_image = self.gray_image * self.membrane_mask\n    #     return self.masked_image\n    def visualize_mem_mask(self):\n        self.masked_image = self.apply_mem_mask()\n        fig, ax = plt.subplots(1,3,figsize=(15,5))\n        ax[0].imshow(self.gray_image, cmap='gray', origin='lower')\n        ax[1].imshow(self.membrane_mask, cmap='gray', origin='lower')\n        ax[2].imshow(self.masked_image, cmap='gray', origin='lower')\n        plt.show()\n</pre> class mem_mask:     def __init__(self, image, edge_sigma, rlnSigma1, rlnSigma2, rlnMembraneDistance, rlnCurveKappa, rlnAngleTheta, rlnCenterX, rlnCenterY):         self.gray_image = image         self.edge_sigma = edge_sigma         self.x0, self.y0 = rlnCenterY, rlnCenterX         self.theta = rlnAngleTheta * np.pi / 180         self.membrane_distance = rlnMembraneDistance         self.kappa = rlnCurveKappa         self.sigma1, self.sigma2 = rlnSigma1, rlnSigma2         self.edge_sigma = edge_sigma         self.image_size = image.shape[0]         self.distance_mat = np.zeros((self.image_size, self.image_size))         self.membrane_mask = np.zeros((self.image_size, self.image_size))         self.masked_image = np.zeros((self.image_size, self.image_size))     def compute_dist_mat(self):         curve_generator = Curve(self.gray_image, self.y0, self.x0, self.theta, self.kappa, self.sigma1, self.sigma2, self.membrane_distance)         self.distance_mat = curve_generator.compute()         return self.distance_mat     def generate_mem_mask(self):         distance_mat_gpu = self.compute_dist_mat()         mask_within_distance = np.abs(distance_mat_gpu) &lt;= self.membrane_distance         gray_value = np.exp(-(np.abs(distance_mat_gpu) - self.membrane_distance)**2 / (2 * self.edge_sigma**2))         mask_small_gray_value = gray_value &lt; 0.001         mask_outside_distance = ~mask_within_distance         membrane_mask = np.zeros_like(distance_mat_gpu)         membrane_mask[mask_within_distance] = 1         membrane_mask[mask_outside_distance &amp; ~mask_small_gray_value] = gray_value[mask_outside_distance &amp; ~mask_small_gray_value]         self.membrane_mask = membrane_mask         return self.membrane_mask     # def apply_mem_mask(self):     #     self.membrane_mask = self.generate_mem_mask()     #     self.masked_image = self.gray_image * self.membrane_mask     #     return self.masked_image     def visualize_mem_mask(self):         self.masked_image = self.apply_mem_mask()         fig, ax = plt.subplots(1,3,figsize=(15,5))         ax[0].imshow(self.gray_image, cmap='gray', origin='lower')         ax[1].imshow(self.membrane_mask, cmap='gray', origin='lower')         ax[2].imshow(self.masked_image, cmap='gray', origin='lower')         plt.show()"},{"location":"tutorials/reference/src/mem_average/","title":"Mem average","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom ._utils import *\nfrom .template_centerfitting import *\nfrom .radon_analyser import *\nfrom .calculate_curve import *\nfrom .generate_membrane_mask import *\nfrom scipy.interpolate import interp1d\n</pre> import numpy as np import matplotlib.pyplot as plt from ._utils import * from .template_centerfitting import * from .radon_analyser import * from .calculate_curve import * from .generate_membrane_mask import * from scipy.interpolate import interp1d In\u00a0[\u00a0]: Copied! <pre>class average_membrane:\n    def __init__(self, image, extra_mem_dist, edge_sigma, rlnCenterY, rlnCenterX, rlnAngleTheta, rlnMembraneDistance, rlnSigma1, rlnSigma2, rlnCurveKappa):\n        self.image = image\n        self.x0 = rlnCenterY\n        self.y0 = rlnCenterX\n        self.theta = rlnAngleTheta * np.pi / 180\n        self.membrane_distance = rlnMembraneDistance\n        self.kappa = rlnCurveKappa\n        self.edge_sigma = edge_sigma\n        self.sigma1 = rlnSigma1\n        self.sigma2 = rlnSigma2\n        self.image_size = image.shape[0]\n        self.distance_mat = np.zeros((self.image_size, self.image_size))\n        self.test_img = np.zeros((self.image_size, self.image_size))\n        self.membrane_average_1d = []\n        self.membrane_average_2d = np.zeros((self.image_size, self.image_size))\n        self.membrane_dist_lst = [i for i in np.arange(-self.membrane_distance-extra_mem_dist, self.membrane_distance+extra_mem_dist+1)]\n    def generate_dist_mat(self):\n        curve_generator = Curve(self.image, y0=self.y0, x0=self.x0, theta=self.theta, kappa=self.kappa, rlnSigma1=self.sigma1, rlnSigma2=self.sigma2, rlnMembraneDistance=self.membrane_distance)\n        distance_mat = curve_generator.compute()\n        return distance_mat\n    \n    def calculate_membrane_average(self):\n        self.distance_mat = self.generate_dist_mat()\n        for k in self.membrane_dist_lst:\n            mask = (k - 1 &lt; self.distance_mat) &amp; (self.distance_mat &lt;= k)\n            gray_values = self.image[mask]\n            gray_value_average = np.average(gray_values)\n            self.membrane_average_1d.append(gray_value_average)\n        self.membrane_average_1d = np.array(self.membrane_average_1d)\n        return self.membrane_average_1d\n\n    def generate_2d_average_mem(self):\n        membrane_average_2d = np.zeros_like(self.distance_mat)\n        self.membrane_dist_lst = np.array(self.membrane_dist_lst)\n        min_mem_dist = min(self.membrane_dist_lst)\n        max_mem_dist = max(self.membrane_dist_lst)\n        f = interp1d(self.membrane_dist_lst, self.membrane_average_1d, kind='linear')\n        in_range_mask = (self.distance_mat &gt;= min_mem_dist) &amp; (self.distance_mat &lt;= max_mem_dist)\n        membrane_average_2d[in_range_mask] = np.array(f(self.distance_mat[in_range_mask]))\n        gray_value = np.exp(-(np.abs(self.distance_mat) - self.membrane_distance)**2 / (2 * self.edge_sigma**2))\n        membrane_average_2d[np.abs(self.distance_mat) &gt; self.membrane_distance] *= gray_value[np.abs(self.distance_mat) &gt; self.membrane_distance]\n        membrane_average_2d[(gray_value &lt; 0.001) &amp; (np.abs(self.distance_mat) &gt; self.membrane_distance)] = 0\n        self.membrane_average_2d = membrane_average_2d\n        return membrane_average_2d\n    \n    def visualize_membrane_average(self):\n        fig, ax = plt.subplots(1,3,figsize=(10,5))\n        ax[0].title.set_text('Original Image')\n        ax[0].imshow(self.image, cmap='gray', origin='lower')\n        ax[1].title.set_text('1D Membrane Average')\n        ax[1].plot(self.membrane_average_1d, '-x', color='red')    \n        ax[2].title.set_text('2D Membrane Average')\n        ax[2].imshow(self.membrane_average_2d, cmap='gray', origin='lower')\n        plt.show()\n</pre> class average_membrane:     def __init__(self, image, extra_mem_dist, edge_sigma, rlnCenterY, rlnCenterX, rlnAngleTheta, rlnMembraneDistance, rlnSigma1, rlnSigma2, rlnCurveKappa):         self.image = image         self.x0 = rlnCenterY         self.y0 = rlnCenterX         self.theta = rlnAngleTheta * np.pi / 180         self.membrane_distance = rlnMembraneDistance         self.kappa = rlnCurveKappa         self.edge_sigma = edge_sigma         self.sigma1 = rlnSigma1         self.sigma2 = rlnSigma2         self.image_size = image.shape[0]         self.distance_mat = np.zeros((self.image_size, self.image_size))         self.test_img = np.zeros((self.image_size, self.image_size))         self.membrane_average_1d = []         self.membrane_average_2d = np.zeros((self.image_size, self.image_size))         self.membrane_dist_lst = [i for i in np.arange(-self.membrane_distance-extra_mem_dist, self.membrane_distance+extra_mem_dist+1)]     def generate_dist_mat(self):         curve_generator = Curve(self.image, y0=self.y0, x0=self.x0, theta=self.theta, kappa=self.kappa, rlnSigma1=self.sigma1, rlnSigma2=self.sigma2, rlnMembraneDistance=self.membrane_distance)         distance_mat = curve_generator.compute()         return distance_mat          def calculate_membrane_average(self):         self.distance_mat = self.generate_dist_mat()         for k in self.membrane_dist_lst:             mask = (k - 1 &lt; self.distance_mat) &amp; (self.distance_mat &lt;= k)             gray_values = self.image[mask]             gray_value_average = np.average(gray_values)             self.membrane_average_1d.append(gray_value_average)         self.membrane_average_1d = np.array(self.membrane_average_1d)         return self.membrane_average_1d      def generate_2d_average_mem(self):         membrane_average_2d = np.zeros_like(self.distance_mat)         self.membrane_dist_lst = np.array(self.membrane_dist_lst)         min_mem_dist = min(self.membrane_dist_lst)         max_mem_dist = max(self.membrane_dist_lst)         f = interp1d(self.membrane_dist_lst, self.membrane_average_1d, kind='linear')         in_range_mask = (self.distance_mat &gt;= min_mem_dist) &amp; (self.distance_mat &lt;= max_mem_dist)         membrane_average_2d[in_range_mask] = np.array(f(self.distance_mat[in_range_mask]))         gray_value = np.exp(-(np.abs(self.distance_mat) - self.membrane_distance)**2 / (2 * self.edge_sigma**2))         membrane_average_2d[np.abs(self.distance_mat) &gt; self.membrane_distance] *= gray_value[np.abs(self.distance_mat) &gt; self.membrane_distance]         membrane_average_2d[(gray_value &lt; 0.001) &amp; (np.abs(self.distance_mat) &gt; self.membrane_distance)] = 0         self.membrane_average_2d = membrane_average_2d         return membrane_average_2d          def visualize_membrane_average(self):         fig, ax = plt.subplots(1,3,figsize=(10,5))         ax[0].title.set_text('Original Image')         ax[0].imshow(self.image, cmap='gray', origin='lower')         ax[1].title.set_text('1D Membrane Average')         ax[1].plot(self.membrane_average_1d, '-x', color='red')             ax[2].title.set_text('2D Membrane Average')         ax[2].imshow(self.membrane_average_2d, cmap='gray', origin='lower')         plt.show()"},{"location":"tutorials/reference/src/pickpoints/","title":"Pickpoints","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nfrom scipy.ndimage import maximum_filter\n</pre> import numpy as np from scipy.ndimage import maximum_filter In\u00a0[\u00a0]: Copied! <pre>def max_filter(image):\n    max_filtered_image = maximum_filter(image, size=9, mode='constant')\n    threshold = np.sum(max_filtered_image) / np.sum(max_filtered_image &gt; 0)\n    max_filtered_image[max_filtered_image &lt;= threshold * max_filtered_image.max()] = 0\n    # normalization\n    max_filtered_image = max_filtered_image / max_filtered_image.max()\n    return max_filtered_image\n</pre> def max_filter(image):     max_filtered_image = maximum_filter(image, size=9, mode='constant')     threshold = np.sum(max_filtered_image) / np.sum(max_filtered_image &gt; 0)     max_filtered_image[max_filtered_image &lt;= threshold * max_filtered_image.max()] = 0     # normalization     max_filtered_image = max_filtered_image / max_filtered_image.max()     return max_filtered_image In\u00a0[\u00a0]: Copied! <pre>def pickpoints(image, num_points):\n    points = []\n    for _ in range(num_points):\n        while True:\n            i, j = np.random.randint(0, image.shape[0]), np.random.randint(0, image.shape[1])\n            if np.random.random() &lt; image[i, j]:\n                points.append((j, i))  # \u4fdd\u5b58(x, y)\u5750\u6807\uff0c\u6ce8\u610f\u7d22\u5f15\u7684\u987a\u5e8f\n                break\n\n    return points\n</pre> def pickpoints(image, num_points):     points = []     for _ in range(num_points):         while True:             i, j = np.random.randint(0, image.shape[0]), np.random.randint(0, image.shape[1])             if np.random.random() &lt; image[i, j]:                 points.append((j, i))  # \u4fdd\u5b58(x, y)\u5750\u6807\uff0c\u6ce8\u610f\u7d22\u5f15\u7684\u987a\u5e8f                 break      return points In\u00a0[\u00a0]: Copied! <pre>def generate_data_points(image, num_points):\n    max_filtered_image = max_filter(image)\n    data_points = np.array(pickpoints(max_filtered_image, num_points))\n    if np.std(data_points[:, 1]) &gt; np.std(data_points[:, 0]):\n        data_points = data_points[np.argsort(data_points[:, 1])]\n    else:\n        data_points = data_points[np.argsort(data_points[:, 0])]\n    return data_points\n</pre> def generate_data_points(image, num_points):     max_filtered_image = max_filter(image)     data_points = np.array(pickpoints(max_filtered_image, num_points))     if np.std(data_points[:, 1]) &gt; np.std(data_points[:, 0]):         data_points = data_points[np.argsort(data_points[:, 1])]     else:         data_points = data_points[np.argsort(data_points[:, 0])]     return data_points"},{"location":"tutorials/reference/src/radon_analyser/","title":"Radon analyser","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom skimage.transform import radon\nfrom scipy.ndimage import maximum_filter\nfrom ._utils import *\nfrom .circle_mask_generator import *\n</pre> import numpy as np import matplotlib.pyplot as plt from skimage.transform import radon from scipy.ndimage import maximum_filter from ._utils import * from .circle_mask_generator import * In\u00a0[\u00a0]: Copied! <pre>class RadonAnalyzer:\n    def __init__(self, image, crop_rate, thr, theta_start=0, theta_end=180, print_results=True):\n        self.gray_image = image\n        self.theta_start = theta_start\n        self.theta_end = theta_end\n        self.image_size = self.gray_image.shape[0]\n        self.crop_rate = crop_rate\n        radius = (self.image_size/2) * self.crop_rate\n        circle_masker = circle_mask(self.gray_image, x0=self.image_size/2, y0=self.image_size/2, radius=radius, sigma=3)\n        self.image_masked = circle_masker.apply_mask()\n        self.threshold = thr\n        self.print_results = print_results\n        try:\n            self.theta, self.projection, self.peaks = self.find_2_peaks()\n        except:\n            self.theta, self.projection, self.peaks = None, None, None\n            print('No peaks found, try again')\n        \n        if self.theta is not None:\n            self.average_theta = np.average(self.peaks[1]+self.theta_start)\n            self.membrane_distance = self.get_mem_dist()\n            self.a = np.cos(self.average_theta * np.pi / 180)\n            self.b = np.sin(self.average_theta * np.pi / 180)\n            if print_results:     \n                print('average_theta:', self.average_theta)\n                print('membrane_distance:', self.membrane_distance)\n    \n    def radon_transform(self, theta_start, theta_end):\n        theta = np.linspace(theta_start, theta_end, abs(theta_end-theta_start))\n        projection = radon(self.image_masked, theta=theta)\n        return theta, projection\n\n    def find_peaks_2d(self, image, neighborhood_size, threshold):\n        image = np.asarray(image)\n        filtered = maximum_filter(image, size=neighborhood_size, mode='constant')\n        peaks = (image == filtered) &amp; (image &gt; threshold)\n        peaks_positions = np.where(peaks)\n        return peaks_positions\n\n\n    def find_2_peaks(self):\n        theta_start = self.theta_start\n        theta_end = self.theta_end\n        theta, projection = self.radon_transform(theta_start, theta_end)\n        peaks = self.find_peaks_2d(np.flipud(projection), 7, self.threshold * np.max(projection))\n        if self.print_results:\n            print('peaks:', peaks)\n            print(f'point1: {peaks[0][0]}, {peaks[1][0]}; point2: {peaks[0][1]}, {peaks[1][1]}')\n        return theta, projection, peaks\n\n    def get_mem_dist(self):\n        self.x0 = self.image_size / 2\n        self.y0 = self.image_size / 2\n        self.c1 = self.peaks[0][1] - self.x0\n        self.c2 = self.peaks[0][0] - self.x0\n        self.cc = (self.c1 + self.c2) / 2\n        membrane_distance = abs(self.c1 - self.c2)\n        # print('membrane_distance:', membrane_distance)\n        return membrane_distance\n\n    def get_vertical_points(self): \n        x = np.linspace(0, self.image_size, self.image_size*5)\n        if not np.isclose(self.a, 0):\n            vertical_k =  - self.b / self.a\n            y = vertical_k * (x-self.image_size/2)  + self.image_size/2\n            mask = (x &gt; 0) &amp; (x &lt; (self.image_size-1)) &amp; (y &gt; 0) &amp; (y &lt; (self.image_size-1))\n            x = np.linspace(min(x[mask]), max(x[mask]), 500)\n            y = vertical_k * (x-self.image_size/2)  + self.image_size/2\n        else:\n            x = (self.image_size / 2) * np.ones(self.image_size)\n            y = np.linspace(0, self.image_size-1, self.image_size)\n        return x, y\n\n    def visualize_analyze(self):\n        theta_start = min(self.theta)\n        theta_end = max(self.theta)\n        # \u663e\u793a\u539f\u59cb\u56fe\u50cf\u548cRadon\u53d8\u6362\u7ed3\u679c\n        fig, axes = plt.subplots(1, 3, figsize=(15, 5))\n        axes[0].imshow(self.gray_image, cmap='gray', origin='lower')\n        axes[0].set_title(\"Original Image\")\n        axes[1].imshow(self.image_masked, cmap='gray', origin='lower')\n        axes[1].set_title(\"Masked Image\")\n        axes[2].imshow(self.projection, cmap='gray', aspect='auto', extent=(theta_start, theta_end, 0, self.projection.shape[0]))\n        axes[2].set_title(\"Radon Transform\")\n        axes[2].set_xlabel(\"Angle (degrees)\")\n        axes[2].set_ylabel(\"Projection Distance\")\n        axes[2].scatter(self.peaks[1]+self.theta_start, self.peaks[0], color='red', marker='x')\n        print('b:', self.b)\n        if self.b != 0:\n           x = np.linspace(0, self.image_size, 100)\n           y1 = (self.c1 + self.a * x) / self.b - self.a/self.b * self.x0 + self.y0\n           y2 = (self.c2 + self.a * x) / self.b - self.a/self.b * self.x0 + self.y0\n           ycc = (self.cc + self.a * x) / self.b - self.a/self.b * self.x0 + self.y0\n           mask1 = (x &gt; 0) &amp; (x &lt; self.image_size) &amp; (y1 &gt; 0) &amp; (y1 &lt; self.image_size)\n           mask2 = (x &gt; 0) &amp; (x &lt; self.image_size) &amp; (y2 &gt; 0) &amp; (y2 &lt; self.image_size)\n           maskcc = (x &gt; 0) &amp; (x &lt; self.image_size) &amp; (ycc &gt; 0) &amp; (ycc &lt; self.image_size)\n           axes[1].plot(x[mask1], y1[mask1], color='red')\n           axes[1].plot(x[mask2], y2[mask2], color='red')\n           axes[1].plot(x[maskcc], ycc[maskcc], color='blue')\n        else:\n           x1 = (self.x0 + self.c1) * np.ones(self.image_size)\n           x2 = (self.x0 + self.c2) * np.ones(self.image_size)\n           xcc = (self.x0 + self.cc) * np.ones(self.image_size)\n           y = np.linspace(0, self.image_size, self.image_size)\n           axes[1].plot(x1, y, color='red')\n           axes[1].plot(x2, y, color='red')\n           axes[1].plot(xcc, y, color='blue')\n        x_v, y_v = self.get_vertical_points() \n        axes[1].plot(x_v, y_v, 'x', color='yellow')\n        plt.tight_layout()\n        plt.show()\n    \n    def return_results(self):\n        if self.theta is not None:\n            average_theta = np.average(self.peaks[1]+self.theta_start)\n            membrane_distance = self.get_mem_dist()\n            if self.print_results:\n                print('====Radon Analysis Results====')\n                print('average_theta:', average_theta)\n                print('membrane_distance:', membrane_distance)\n        return average_theta, membrane_distance\n</pre> class RadonAnalyzer:     def __init__(self, image, crop_rate, thr, theta_start=0, theta_end=180, print_results=True):         self.gray_image = image         self.theta_start = theta_start         self.theta_end = theta_end         self.image_size = self.gray_image.shape[0]         self.crop_rate = crop_rate         radius = (self.image_size/2) * self.crop_rate         circle_masker = circle_mask(self.gray_image, x0=self.image_size/2, y0=self.image_size/2, radius=radius, sigma=3)         self.image_masked = circle_masker.apply_mask()         self.threshold = thr         self.print_results = print_results         try:             self.theta, self.projection, self.peaks = self.find_2_peaks()         except:             self.theta, self.projection, self.peaks = None, None, None             print('No peaks found, try again')                  if self.theta is not None:             self.average_theta = np.average(self.peaks[1]+self.theta_start)             self.membrane_distance = self.get_mem_dist()             self.a = np.cos(self.average_theta * np.pi / 180)             self.b = np.sin(self.average_theta * np.pi / 180)             if print_results:                      print('average_theta:', self.average_theta)                 print('membrane_distance:', self.membrane_distance)          def radon_transform(self, theta_start, theta_end):         theta = np.linspace(theta_start, theta_end, abs(theta_end-theta_start))         projection = radon(self.image_masked, theta=theta)         return theta, projection      def find_peaks_2d(self, image, neighborhood_size, threshold):         image = np.asarray(image)         filtered = maximum_filter(image, size=neighborhood_size, mode='constant')         peaks = (image == filtered) &amp; (image &gt; threshold)         peaks_positions = np.where(peaks)         return peaks_positions       def find_2_peaks(self):         theta_start = self.theta_start         theta_end = self.theta_end         theta, projection = self.radon_transform(theta_start, theta_end)         peaks = self.find_peaks_2d(np.flipud(projection), 7, self.threshold * np.max(projection))         if self.print_results:             print('peaks:', peaks)             print(f'point1: {peaks[0][0]}, {peaks[1][0]}; point2: {peaks[0][1]}, {peaks[1][1]}')         return theta, projection, peaks      def get_mem_dist(self):         self.x0 = self.image_size / 2         self.y0 = self.image_size / 2         self.c1 = self.peaks[0][1] - self.x0         self.c2 = self.peaks[0][0] - self.x0         self.cc = (self.c1 + self.c2) / 2         membrane_distance = abs(self.c1 - self.c2)         # print('membrane_distance:', membrane_distance)         return membrane_distance      def get_vertical_points(self):          x = np.linspace(0, self.image_size, self.image_size*5)         if not np.isclose(self.a, 0):             vertical_k =  - self.b / self.a             y = vertical_k * (x-self.image_size/2)  + self.image_size/2             mask = (x &gt; 0) &amp; (x &lt; (self.image_size-1)) &amp; (y &gt; 0) &amp; (y &lt; (self.image_size-1))             x = np.linspace(min(x[mask]), max(x[mask]), 500)             y = vertical_k * (x-self.image_size/2)  + self.image_size/2         else:             x = (self.image_size / 2) * np.ones(self.image_size)             y = np.linspace(0, self.image_size-1, self.image_size)         return x, y      def visualize_analyze(self):         theta_start = min(self.theta)         theta_end = max(self.theta)         # \u663e\u793a\u539f\u59cb\u56fe\u50cf\u548cRadon\u53d8\u6362\u7ed3\u679c         fig, axes = plt.subplots(1, 3, figsize=(15, 5))         axes[0].imshow(self.gray_image, cmap='gray', origin='lower')         axes[0].set_title(\"Original Image\")         axes[1].imshow(self.image_masked, cmap='gray', origin='lower')         axes[1].set_title(\"Masked Image\")         axes[2].imshow(self.projection, cmap='gray', aspect='auto', extent=(theta_start, theta_end, 0, self.projection.shape[0]))         axes[2].set_title(\"Radon Transform\")         axes[2].set_xlabel(\"Angle (degrees)\")         axes[2].set_ylabel(\"Projection Distance\")         axes[2].scatter(self.peaks[1]+self.theta_start, self.peaks[0], color='red', marker='x')         print('b:', self.b)         if self.b != 0:            x = np.linspace(0, self.image_size, 100)            y1 = (self.c1 + self.a * x) / self.b - self.a/self.b * self.x0 + self.y0            y2 = (self.c2 + self.a * x) / self.b - self.a/self.b * self.x0 + self.y0            ycc = (self.cc + self.a * x) / self.b - self.a/self.b * self.x0 + self.y0            mask1 = (x &gt; 0) &amp; (x &lt; self.image_size) &amp; (y1 &gt; 0) &amp; (y1 &lt; self.image_size)            mask2 = (x &gt; 0) &amp; (x &lt; self.image_size) &amp; (y2 &gt; 0) &amp; (y2 &lt; self.image_size)            maskcc = (x &gt; 0) &amp; (x &lt; self.image_size) &amp; (ycc &gt; 0) &amp; (ycc &lt; self.image_size)            axes[1].plot(x[mask1], y1[mask1], color='red')            axes[1].plot(x[mask2], y2[mask2], color='red')            axes[1].plot(x[maskcc], ycc[maskcc], color='blue')         else:            x1 = (self.x0 + self.c1) * np.ones(self.image_size)            x2 = (self.x0 + self.c2) * np.ones(self.image_size)            xcc = (self.x0 + self.cc) * np.ones(self.image_size)            y = np.linspace(0, self.image_size, self.image_size)            axes[1].plot(x1, y, color='red')            axes[1].plot(x2, y, color='red')            axes[1].plot(xcc, y, color='blue')         x_v, y_v = self.get_vertical_points()          axes[1].plot(x_v, y_v, 'x', color='yellow')         plt.tight_layout()         plt.show()          def return_results(self):         if self.theta is not None:             average_theta = np.average(self.peaks[1]+self.theta_start)             membrane_distance = self.get_mem_dist()             if self.print_results:                 print('====Radon Analysis Results====')                 print('average_theta:', average_theta)                 print('membrane_distance:', membrane_distance)         return average_theta, membrane_distance <p>if name == 'main': image = readmrc('J320/templates_selected.mrc', section=3, mode='gpu') analyzer = RadonAnalyzer(0, image, crop_rate=0.9, thr=0.8) analyzer.visualize_analyze()</p>"},{"location":"tutorials/reference/src/template_centerfitting/","title":"Template centerfitting","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.ndimage import zoom\nfrom scipy.signal import correlate2d\nfrom .generate_gaussian_template import *\nfrom ._utils import *\nfrom .radon_analyser import *\n</pre> import numpy as np import matplotlib.pyplot as plt from scipy.ndimage import zoom from scipy.signal import correlate2d from .generate_gaussian_template import * from ._utils import * from .radon_analyser import * In\u00a0[\u00a0]: Copied! <pre>class Template_centerfitting:\n    def __init__(self, sigma1, sigma2, image, crop_rate, thr, theta_start, theta_end, template_size, sigma_range, sigma_step):\n        radonanalyze = RadonAnalyzer(image, crop_rate=crop_rate, thr=thr, theta_start=theta_start, theta_end=theta_end, print_results=False)\n        self.gray_image = image\n        self.image_size = self.gray_image.shape[0]\n        self.theta, self.membrane_distance = radonanalyze.return_results()\n        self.template_size = template_size\n        self.sigma1 = sigma1\n        self.sigma2 = sigma2\n        self.sigma_range = sigma_range\n        self.sigma_step = sigma_step\n        self.template = generate_template(self.template_size, self.theta+90, self.membrane_distance, self.sigma1, self.sigma2)\n        self.y0, self.x0 = radonanalyze.get_vertical_points()\n        self.y, self.x = radonanalyze.get_vertical_points()\n        self.n = self.template_size\n        self.x = self.x.astype(np.int32)\n        self.y = self.y.astype(np.int32)\n        self.corr_lst = []\n\n    def get_region(self, i):\n        center_x = self.x[i]\n        center_y = self.y[i]\n        padding = self.n // 2\n        padded_array = np.pad(self.gray_image, padding, mode='constant', constant_values=0)\n        region = padded_array[center_x: center_x + self.n, center_y: center_y + self.n]\n        return region\n\n    def centerfinder(self):\n        for i in range(len(self.x)):\n            region = self.get_region(i)\n            region = (region - np.mean(region)) / np.std(region)\n            template = (self.template - np.mean(self.template)) / np.std(self.template)\n            correlation_result = correlate2d(region, template, mode='full')\n            corr_score = np.max(correlation_result)\n            self.corr_lst.append(corr_score)\n        self.corr_max = max(self.corr_lst)\n        self.corr_max_index = self.corr_lst.index(self.corr_max)\n        self.yc = self.x0[self.corr_max_index]\n        self.xc = self.y0[self.corr_max_index]\n        print('====Center fitting results====')\n        print('membrane center y:', self.yc)\n        print('membrane center x:', self.xc)\n        return self.xc, self.yc\n\n    def visualize_center(self):\n        fig, axes = plt.subplots(1, 4, figsize=(10, 5))\n        axes[0].title.set_text('Cross-Correlation score')\n        axes[0].plot(self.corr_lst, 'x-', color = 'yellow')\n        axes[1].title.set_text('Template')\n        axes[1].imshow(self.template, cmap='gray', origin='lower')\n        axes[2].title.set_text('Region(max score)')\n        axes[2].imshow(self.get_region(self.corr_max_index), cmap='gray', origin='lower')\n        axes[3].title.set_text('Original image with center')\n        axes[3].imshow(self.gray_image, cmap='gray', origin='lower')\n        axes[3].plot(self.xc, self.yc, 'x', color = 'yellow')\n        plt.show()\n    \n    def fit_sigma(self):\n        self.cc_region = self.get_region(self.corr_max_index)\n        self.cc_region = (self.cc_region - np.mean(self.cc_region)) / np.std(self.cc_region)\n        self.corr_sigma_score1 = []\n        number1 = int(self.sigma_range*self.sigma1/self.sigma_step)\n        number2 = int(self.sigma_range*self.sigma2/self.sigma_step)\n        corr_sigma = np.linspace(0.1, self.sigma_range*self.sigma1, number1)\n        print('====Sigma fitting results====')\n        for i in corr_sigma:\n            sigma_temp = i\n            template_n = generate_template(self.template_size, self.theta+90, self.membrane_distance, sigma_temp, self.sigma2)\n            template_n = (template_n - np.mean(template_n)) / np.std(template_n)\n            corr_result = correlate2d(self.cc_region, template_n, mode='same')\n            self.corr_sigma_score1.append(np.max(corr_result))\n        corr_best_sigma_score = max(self.corr_sigma_score1)\n        corr_best_sigma_index = self.corr_sigma_score1.index(corr_best_sigma_score)\n        best_sigma1 = corr_sigma[corr_best_sigma_index]\n        print('best sigma1:', best_sigma1)\n        self.corr_sigma_score2 = []\n        corr_sigma = np.linspace(0.1, self.sigma_range*self.sigma2, number2)\n        for i in corr_sigma:\n            sigma_temp = i\n            template_n_n = generate_template(self.template_size, self.theta+90, self.membrane_distance, best_sigma1, sigma_temp)\n            template_n_n = (template_n - np.mean(template_n_n)) / np.std(template_n_n)\n            corr_result = correlate2d(self.cc_region, template_n_n, mode='same')\n            self.corr_sigma_score2.append(np.max(corr_result))\n        corr_best_sigma_score = max(self.corr_sigma_score2)\n        corr_best_sigma_index = self.corr_sigma_score2.index(corr_best_sigma_score)\n        best_sigma2 = corr_sigma[corr_best_sigma_index]\n        print('best sigma2:', best_sigma2)\n        self.template = generate_template(self.template_size, self.theta+90, self.membrane_distance, best_sigma1, best_sigma2)\n        return best_sigma1, best_sigma2\n    \n    def fit_sigma_visualize(self):\n        fig, axes = plt.subplots(1, 4, figsize=(10, 5))\n        axes[0].title.set_text('Center Region')\n        axes[0].imshow(self.cc_region, cmap='gray', origin='lower')\n        axes[1].title.set_text('Template with best sigmas')\n        axes[1].imshow(self.template, cmap='gray', origin='lower')\n        axes[2].title.set_text('CC score(sigma1)')\n        axes[2].plot(self.corr_sigma_score1, 'x')\n        axes[3].title.set_text('CC score(sigma2)')\n        axes[3].plot(self.corr_sigma_score2, 'x')\n        plt.show()\n</pre> class Template_centerfitting:     def __init__(self, sigma1, sigma2, image, crop_rate, thr, theta_start, theta_end, template_size, sigma_range, sigma_step):         radonanalyze = RadonAnalyzer(image, crop_rate=crop_rate, thr=thr, theta_start=theta_start, theta_end=theta_end, print_results=False)         self.gray_image = image         self.image_size = self.gray_image.shape[0]         self.theta, self.membrane_distance = radonanalyze.return_results()         self.template_size = template_size         self.sigma1 = sigma1         self.sigma2 = sigma2         self.sigma_range = sigma_range         self.sigma_step = sigma_step         self.template = generate_template(self.template_size, self.theta+90, self.membrane_distance, self.sigma1, self.sigma2)         self.y0, self.x0 = radonanalyze.get_vertical_points()         self.y, self.x = radonanalyze.get_vertical_points()         self.n = self.template_size         self.x = self.x.astype(np.int32)         self.y = self.y.astype(np.int32)         self.corr_lst = []      def get_region(self, i):         center_x = self.x[i]         center_y = self.y[i]         padding = self.n // 2         padded_array = np.pad(self.gray_image, padding, mode='constant', constant_values=0)         region = padded_array[center_x: center_x + self.n, center_y: center_y + self.n]         return region      def centerfinder(self):         for i in range(len(self.x)):             region = self.get_region(i)             region = (region - np.mean(region)) / np.std(region)             template = (self.template - np.mean(self.template)) / np.std(self.template)             correlation_result = correlate2d(region, template, mode='full')             corr_score = np.max(correlation_result)             self.corr_lst.append(corr_score)         self.corr_max = max(self.corr_lst)         self.corr_max_index = self.corr_lst.index(self.corr_max)         self.yc = self.x0[self.corr_max_index]         self.xc = self.y0[self.corr_max_index]         print('====Center fitting results====')         print('membrane center y:', self.yc)         print('membrane center x:', self.xc)         return self.xc, self.yc      def visualize_center(self):         fig, axes = plt.subplots(1, 4, figsize=(10, 5))         axes[0].title.set_text('Cross-Correlation score')         axes[0].plot(self.corr_lst, 'x-', color = 'yellow')         axes[1].title.set_text('Template')         axes[1].imshow(self.template, cmap='gray', origin='lower')         axes[2].title.set_text('Region(max score)')         axes[2].imshow(self.get_region(self.corr_max_index), cmap='gray', origin='lower')         axes[3].title.set_text('Original image with center')         axes[3].imshow(self.gray_image, cmap='gray', origin='lower')         axes[3].plot(self.xc, self.yc, 'x', color = 'yellow')         plt.show()          def fit_sigma(self):         self.cc_region = self.get_region(self.corr_max_index)         self.cc_region = (self.cc_region - np.mean(self.cc_region)) / np.std(self.cc_region)         self.corr_sigma_score1 = []         number1 = int(self.sigma_range*self.sigma1/self.sigma_step)         number2 = int(self.sigma_range*self.sigma2/self.sigma_step)         corr_sigma = np.linspace(0.1, self.sigma_range*self.sigma1, number1)         print('====Sigma fitting results====')         for i in corr_sigma:             sigma_temp = i             template_n = generate_template(self.template_size, self.theta+90, self.membrane_distance, sigma_temp, self.sigma2)             template_n = (template_n - np.mean(template_n)) / np.std(template_n)             corr_result = correlate2d(self.cc_region, template_n, mode='same')             self.corr_sigma_score1.append(np.max(corr_result))         corr_best_sigma_score = max(self.corr_sigma_score1)         corr_best_sigma_index = self.corr_sigma_score1.index(corr_best_sigma_score)         best_sigma1 = corr_sigma[corr_best_sigma_index]         print('best sigma1:', best_sigma1)         self.corr_sigma_score2 = []         corr_sigma = np.linspace(0.1, self.sigma_range*self.sigma2, number2)         for i in corr_sigma:             sigma_temp = i             template_n_n = generate_template(self.template_size, self.theta+90, self.membrane_distance, best_sigma1, sigma_temp)             template_n_n = (template_n - np.mean(template_n_n)) / np.std(template_n_n)             corr_result = correlate2d(self.cc_region, template_n_n, mode='same')             self.corr_sigma_score2.append(np.max(corr_result))         corr_best_sigma_score = max(self.corr_sigma_score2)         corr_best_sigma_index = self.corr_sigma_score2.index(corr_best_sigma_score)         best_sigma2 = corr_sigma[corr_best_sigma_index]         print('best sigma2:', best_sigma2)         self.template = generate_template(self.template_size, self.theta+90, self.membrane_distance, best_sigma1, best_sigma2)         return best_sigma1, best_sigma2          def fit_sigma_visualize(self):         fig, axes = plt.subplots(1, 4, figsize=(10, 5))         axes[0].title.set_text('Center Region')         axes[0].imshow(self.cc_region, cmap='gray', origin='lower')         axes[1].title.set_text('Template with best sigmas')         axes[1].imshow(self.template, cmap='gray', origin='lower')         axes[2].title.set_text('CC score(sigma1)')         axes[2].plot(self.corr_sigma_score1, 'x')         axes[3].title.set_text('CC score(sigma2)')         axes[3].plot(self.corr_sigma_score2, 'x')         plt.show()"}]}